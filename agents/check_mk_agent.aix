#!/usr/bin/ksh93
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

: "${MK_RUN_SYNC_PARTS=true}"

$MK_RUN_SYNC_PARTS || {
    echo "Exclusive cache update and live-update (MK_RUN_SYNC_PARTS=false) is not suported on this system" >&2
    exit 1
}

# force load of environment

if [ -e $HOME/.profile ]
then
    . $HOME/.profile >/dev/null 2>&1
fi

# Remove locale settings to eliminate localized outputs where possible
export LC_ALL=C
unset LANG

export MK_LIBDIR=${MK_LIBDIR:-/usr/check_mk/lib}
export MK_CONFDIR=${MK_CONFDIR:-/usr/check_mk/conf}
export MK_VARDIR=${MK_VARDIR:-/tmp/check_mk}

# Optionally set a tempdir for all subsequent calls
#export TMPDIR=

# Provide information about the remote host. That helps when data
# is being sent only once to each remote host.
if [ "$REMOTE_HOST" ] ; then
    export REMOTE=$REMOTE_HOST
elif [ "$SSH_CLIENT" ] ; then
    export REMOTE=${SSH_CLIENT%% *}
fi

# All executables in PLUGINSDIR will simply be executed and their
# ouput appended to the output of the agent. Plugins define their own
# sections and must output headers with '<<<' and '>>>'
PLUGINSDIR=$MK_LIBDIR/plugins

# All executables in LOCALDIR will by executabled and their
# output inserted into the section <<<local>>>. Please refer
# to online documentation for details.
LOCALDIR=$MK_LIBDIR/local

# All files in SPOOLDIR will simply appended to the agent
# output if they are not outdated (see below)
SPOOLDIR=$MK_VARDIR/spool

#Avoid problems with wrong decimal separators in other language verions of aix
export LC_NUMERIC="en_US"

# close standard input (for security reasons) and stderr
if [ "$1" = -d ]
then
    set -xv
else
    exec </dev/null 2>/dev/null
fi

# Function to replace "if type [somecmd]" idiom
# 'command -v' tends to be more robust vs 'which' and 'type' based tests
inpath() {
    command -v "${1:?No command to test}" >/dev/null 2>&1
}

read_python_version() {
    if inpath "$1"; then
        version=$($1 -c 'import sys; print("%s.%s"%(sys.version_info[0], sys.version_info[1]))')

        major=${version%%.*}
        minor=${version##*.}

        if [ "$major" -eq "$2" ] && [ "$minor" -ge "$3" ]; then
            echo "$1"
            return 0
        fi
    fi
    return 1
}


PYTHON3=$(read_python_version python3 3 4 || read_python_version python 3 4)
PYTHON2=$(read_python_version python2 2 6 || read_python_version python 2 6)
if [ -f "$MK_CONFDIR/python_path.cfg" ]; then
    # shellcheck source=/dev/null
    . "$MK_CONFDIR/python_path.cfg"
fi
export PYTHON2 PYTHON3

if [ -z "$PYTHON2" ] && [ -z "$PYTHON3" ]; then
    NO_PYTHON=true
elif [ -n "$PYTHON3" ] && [ "$($PYTHON3 -c 'pass' > /dev/null 2>&1; echo $?)" -eq 127 ]; then
    WRONG_PYTHON_COMMAND=true
elif [ -z "$PYTHON3" ] && [ "$($PYTHON2 -c 'pass' > /dev/null 2>&1; echo $?)" -eq 127 ]; then
    WRONG_PYTHON_COMMAND=true
fi


# Shell version of the waitmax utility, that limits the runtime of
# commands. This version does not conserve the original exit code
# of the command. It is successfull if the command terminated
# in time.
function waitmax
{
   TIMEOUT=${1}0
   SIGNAL=9
   shift

   # Run command in background
   ksh -c "$*" &
   PID=$!

   # Wait for termination within TIMOUT seconds
   while [ $TIMEOUT -gt 0 ]
   do
       TIMEOUT=$((TIMEOUT - 1))
       if [ ! -e /proc/$PID ] ; then
           return 0
       fi
       perl -e "select(undef, undef, undef, 0.1);"
   done

   # Process did not terminate in time. Kill and
   # return with an error
   kill -9 $PID
   return 255
}

function run_cached {
    NAME=$1
    # Be aware: Maxage was expected to be given in minutes but this was
    # confusing because all other agents use seconds here. So this has
    # been changed to be compatible.
    MAXAGE=$2
    shift 2
    CMDLINE=$*

    if [ ! -e $MK_VARDIR/cache ] ; then mkdir -p $MK_VARDIR/cache ; fi
    CACHEFILE=$MK_VARDIR/cache/$NAME.cache

    USE_CACHEFILE=""
    # Check if file exists and is recent enough
    if [ -s $CACHEFILE ]
    then
        AGE=$(/usr/bin/perl -e 'if (! -f $ARGV[0]){die "0000000"};$mtime=(stat($ARGV[0]))[9];print ($^T-$mtime);' $CACHEFILE )
        if (( $AGE < $MAXAGE )) ; then
            USE_CACHEFILE=1
        fi
        # get file time for cache
        MTIME=$(/usr/bin/perl -e 'print((stat shift)[9])' $CACHEFILE)
        CACHE_INFO="cached($MTIME,$MAXAGE)"
        if [[ $NAME == local_* ]]; then
            # prefix CACHE_INFO, but skip any headers and lines with existing CACHE_INFO
            sed -e "/^<<<.*>>>/{p;d;}; /^cached([0-9]*,[0-9]*)/{p;d;}; s/^/${CACHE_INFO} /" "${CACHEFILE}"
        else
            # insert CACHE_INFO in header, but skip headers with existing CACHE_INFO
            sed -e '/^<<<.*\(:cached(\).*>>>/{p;d;}; s/^<<<\([^>]*\)>>>$/<<<\1:'"${CACHE_INFO}"'>>>/' "${CACHEFILE}"
        fi
    fi
    if [ -z "$USE_CACHEFILE" -a ! -e "$CACHEFILE.new" ]
    then
        nohup sh -c "$CMDLINE" > "$CACHEFILE.new" 2> /dev/null && mv -f "$CACHEFILE.new" "$CACHEFILE" || rm -f "$CACHEFILE.new" "$CACHEFILE"  &
    fi
}

function add_failed_python_plugin {
    if [ -z "$FAILED_PYTHON_PLUGINS" ]; then
        FAILED_PYTHON_PLUGINS=("$1")
    else
        FAILED_PYTHON_PLUGINS=("${FAILED_PYTHON_PLUGINS[@]}" "$1")
    fi
}

function may_get_plugin_interpreter {
    # run_cached::sh -c "COMMAND-STRING"
    # ksh/dash/...: it's not allowed to use function within COMMAND-STRING

    if [ "${1:0:2}" == "./" ]; then
        agent_plugin="${1:2}"
    else
        agent_plugin="$1"
    fi

    extension="${agent_plugin##*.}"
    filename="${agent_plugin%.*}"
    # Execute all non python plugins with ./foo
    if [ "$extension" != "py" ]; then
        return 0
    fi

    if [ "${filename#${filename%??}}" != "_2" ]; then
        if [ -n "$NO_PYTHON" ] || [ -n "$WRONG_PYTHON_COMMAND" ]; then
            add_failed_python_plugin "$agent_plugin"
            return 1
        fi

        if [ -n "$PYTHON3" ]; then
            echo "$PYTHON3"
            return 0
        fi

        if [ ! -e "${filename}_2.py" ]; then
            add_failed_python_plugin "$agent_plugin (Missing Python 3 installation)"
            return 1
        fi

        # Python2 file but no Python interpreter found.
        return 1
    fi

    if [ -x "${filename%??}.py" ] && [ -n "$PYTHON3" ]; then
        return 1
    fi

    if [ -n "$PYTHON2" ]; then
        echo "$PYTHON2"
        return 0
    fi

    add_failed_python_plugin "$agent_plugin (missing Python 2 installation)"
    return 1
}

echo "<<<check_mk>>>"
echo "Version: 2.0.0p26"
echo "AgentOS: aix"
echo "Hostname: $(hostname)"
echo "AgentDirectory: $MK_CONFDIR"
echo "DataDirectory: $MK_VARDIR"
echo "SpoolDirectory: $SPOOLDIR"
echo "PluginsDirectory: $PLUGINSDIR"
echo "LocalDirectory: $LOCALDIR"

echo '<<<df>>>'
if [ -x /usr/opt/freeware/bin/df ] ; then
    excludefs="-x smbfs -x cifs -x iso9660 -x udf -x nfsv4 -x nfs -x mvfs -x zfs -x cdrfs"
    # shellcheck disable=SC2086
    /usr/opt/freeware/bin/df -PTlk $excludefs | sed 1d

    # df inodes information
    echo '<<<df>>>'
    echo '[df_inodes_start]'
    # shellcheck disable=SC2086
    /usr/opt/freeware/bin/df -PTli $excludefs | sed 1d
    echo '[df_inodes_end]'
else
    df -kP | sed 's/ / - /' | grep -v ^/proc | grep -v ^Filesystem | grep -v :
fi

# Check for hanging NFS mounts. This needs a GNU stat installed in the PATH
if type stat >/dev/null 2>&1 ; then
    echo '<<<nfsmounts>>>'
    mount | grep ' nfs' | awk '{print $3;}' | \
        while read MP
    do
        waitmax 5 stat -f -c '"'$MP' ok - - - -"' "$MP" || \
            echo "$MP hanging 0 0 0 0"
    done
    echo '<<<cifsmounts>>>'
    mount | grep ' cifs' | awk '{print $3;}' | \
        while read MP
    do
        if [ ! -r $MP ]; then
            echo "$MP Permission denied"
        else
            waitmax 2 stat -f -c '"'$MP' ok - - - -"' "$MP" || \
                echo "$MP hanging 0 0 0 0"
        fi
    done
fi

echo '<<<ps>>>'
ps -ef -F user,vszsize,rssize,pcpu,etime,pid,args | sed -e 1d -e 's/ *\([^ ]*\) *\([^ ]*\) *\([^ ]*\) *\([^ ]*\) *\([^ ]*\) *\([^ ]*\) */(\1,\2,\3,\4\/\5,\6) /'

if type lparstat >/dev/null 2>&1
then
  echo '<<<lparstat_aix>>>'
  lparstat 1 1
fi

echo '<<<vmstat_aix>>>'
vmstat | tail -n1

echo '<<<aix_diskiod>>>'
iostat -d | tr -s ' ' | grep hdisk

echo '<<<aix_memory>>>'
vmstat -v  | tr -s ' '
swap -s

echo '<<<mpstat_aix>>>'
mpstat -a | tail -n1

echo '<<<aix_paging>>>'
lsps -a

# CPU output of Linux agent simulated
# (thanks to Cameron Pierce)
echo '<<<cpu>>>'
load=`uptime|sed -e 's;.*average: \([[:digit:]]\{1,\}\.[[:digit:]]\{1,\}\), \([[:digit:]]\{1,\}\.[[:digit:]]\{1,\}\), \([[:digit:]]\{1,\}\.[[:digit:]]\{1,\}\);\1 \2 \3;'`
ps=`ps -eo thcount | awk '{SUM+=$1} END {print SUM}'`
procs=`vmstat|grep lcpu|sed -e 's;.*lcpu=\([[:digit:]]\{1,4\}\).*;\1;'`
echo $load 1/$ps $$ $procs


echo "<<<aix_if>>>"
for ent in $(ifconfig -a | grep '^en' | cut -d ":" -f 1)
do
    echo "[$ent]"
    entstat "$ent" | grep -E "(^Hardware|^Bytes:|^Packets:|^Transmit|^Broadcast:|^Multicast:)"
    entstat "$ent" | grep -p "Driver Flags:"
done


if which ntpq > /dev/null 2>&1 ; then
    if [ $(lssrc -s xntpd|grep -c active) -gt 0 ] ; then
        echo '<<<ntp>>>'
        ntpq -np | sed -e 1,2d -e 's/^\(.\)/\1 /' -e 's/^ /%/'
    fi
fi


echo '<<<aix_multipath>>>'
    lspath -F"name parent status"


echo '<<<aix_lvm>>>'
    # -L disables LVM lock for the query. Avoids blocking while LVM is
    # doing changes. For rootvg that is fine.
    lsvg -L -l rootvg


echo '<<<tcp_conn_stats>>>'
netstat -ntfinet | awk ' /^tcp/ { c[$6]++; } END { for (x in c) { print x, c[x]; } }'

# Libelle Business Shadow
if type trd >/dev/null 2>&1
then
  echo '<<<libelle_business_shadow:sep(58)>>>'
  $(which trd) -s
fi

if [ -x /usr/sbin/sendmail ] ; then
    echo '<<<postfix_mailq>>>';
    mailq 2>&1 | tail -n 6
fi

# uptime formats
# 12:55pm  up 105 days, 21 hrs,  2 users, load average: 0.26, 0.26, 0.26 --> 9147600
# 1:41pm   up 105 days, 21:46,   2 users, load average: 0.28, 0.28, 0.27 --> 9150360
# 05:26PM  up           1:16,    1 user,  load average: 0.33, 0.21, 0.20 --> 4560
# 06:13PM  up           2:03,    1 user,  load average: 1.16, 1.07, 0.91 --> 7380
# 08:43AM  up 29 mins,           1 user,  load average: 0.09, 0.18, 0.21 --> 1740
# 08:47AM  up 66 days,  18:34,   1 user,  load average: 2.25, 2.43, 2.61 --> 5769240
# 08:45AM  up 76 days,  34 mins, 1 user,  load average: 2.25, 2.43, 2.61 --> 5769240
echo '<<<uptime>>>'
UPTIME=$(uptime | sed -e 's/^.*up//g' -e 's/[0-9]* user.*//g')
case $UPTIME in
    *day* ) DAYS=$(echo $UPTIME | sed -e 's/days\{0,1\},.*//g') ;;
    * ) DAYS="0" ;;
esac

case $UPTIME in
    *:* )
        HOURS=$(echo $UPTIME | sed -e 's/.*days\{0,1\},//g' -e 's/:.*//g')
        MINS=$(echo $UPTIME | sed -e 's/.*days\{0,1\},//g' -e 's/.*://g' -e 's/,.*//g') ;;
    *hr* )
        HOURS=$(echo $UPTIME | sed -e 's/hrs\{0,1\},.*//g' -e 's/.*,//g')
        MINS=0 ;;
    *min* )
        HOURS=0
        MINS=$(echo $UPTIME | sed -e 's/mins\{0,1\},.*//g' -e 's/.*hrs\{0,1\},//g' -e 's/.*days\{0,1\},//g') ;;
    * )
        HOURS="0"
        MINS=0 ;;
esac

echo $(((DAYS*86400)+(HOURS*3600)+(MINS*60)))


if cd $PLUGINSDIR 2>/dev/null; then
    for skript in $(ls); do
        if [ ! -d "$skript" ] && [ -x "$skript" ] ; then
            if plugin_interpreter=$(may_get_plugin_interpreter "$skript"); then
                $plugin_interpreter "./$skript"
            fi
        fi
    done

    # Call some plugins only every X'th second
    for skript in [1-9]*/* ; do
        if [ -x "$skript" ] ; then
            if plugin_interpreter=$(may_get_plugin_interpreter "$skript"); then
                run_cached plugins_${skript//\//\#} ${skript%/*} "$plugin_interpreter $skript"
            fi
        fi
    done
fi




# Fileinfo-Check: put patterns for files into /etc/check_mk/fileinfo.cfg
perl -e '
use File::Glob "bsd_glob";
my @patterns = ();
foreach (bsd_glob("$ARGV[0]/fileinfo.cfg"), bsd_glob("$ARGV[0]/fileinfo.d/*")) {
    open my $handle, "<", $_ or next;
    while (<$handle>) {
        chomp;
        next if /^\s*(#|$)/;
        my $pattern = $_;
        $pattern =~ s/\$DATE:(.*?)\$/substr(`date +"$1"`, 0, -1)/eg;
        push @patterns, $pattern;
    }
    warn "error while reading $_: $!\n" if $!;
    close $handle;
}
exit if ! @patterns;

print "<<<fileinfo:sep(124)>>>\n", time, "\n[[[header]]]\nname|status|size|time\n[[[content]]]\n";

foreach (@patterns) {
    foreach (bsd_glob("$_")) {
        if (! -f) {
            print "$_|missing\n" if ! -d;
        } elsif (my @infos = stat) {
            print "$_|ok|$infos[7]|$infos[9]\n";
        } else {
            print "$_|stat failed: $!\n";
        }
    }
}
' -- "$MK_CONFDIR"


# powerHA
if type lslpp >/dev/null 2>&1
then
    cluster_cmd_output=$(lslpp -l cluster.es.server.rte)
    if ! echo $cluster_cmd_output | grep -q "not installed"
    then
        # now the following commands should be available
        nodes=$(cllsnode | grep "NODE" | sed -e s/NODE//g -e s/://g)
        list_active_nodes=""
        for node in $nodes
        do
            active_nodes=$(clgetactivenodes -n $node)
            if echo $active_nodes | grep -q $node
            then
                list_active_nodes=$list_active_nodes"\n$node"
            fi
        done

        if [ "$list_active_nodes" ]
        then
            echo '<<<aix_hacmp_nodes>>>'
            echo -e $list_active_nodes
            cllsnode
        fi

        echo '<<<aix_hacmp_services>>>'
        if type clshowsrv ; then
            waitmax 5 clshowsrv -v
        else # fallback, hardcoded base installation path
            waitmax 5 /usr/es/sbin/cluster/utilities/clshowsrv -v
        fi

        echo '<<<aix_hacmp_resources:sep(58)>>>'
        waitmax 5 clRGinfo -s
    fi
fi

echo '<<<local:sep(0)>>>'
if cd $LOCALDIR 2>/dev/null
then
  for skript in $(ls)
  do
    if [ -x "$skript" ] ; then
        ./$skript
    fi
  done

  # Call some local checks only every X'th second
  for skript in [1-9]*/* ; do
      if [ -x "$skript" ] ; then
          run_cached local_${skript//\//\#} ${skript%/*} "$skript"
      fi
  done
fi

# MK's Remote Plugin Executor
if [ -e "$MK_CONFDIR/mrpe.cfg" ]
then
    echo '<<<mrpe>>>'
    grep -Ev '^[[:space:]]*($|#)' "$MK_CONFDIR/mrpe.cfg" | \
    while read descr cmdline
    do
        PLUGIN=${cmdline%% *}
        OUTPUT=$(eval "$cmdline")
        echo "(${PLUGIN##*/}) $descr $? $OUTPUT" | tr \\n \\1
        echo
    done
fi

# Agent output snippets created by cronjobs, etc.
if [ -d "$SPOOLDIR" ] && [ -r "$SPOOLDIR" ]; then
    cd "$SPOOLDIR" > /dev/null
    now=$(date +%s)

    for file in *
    do
        # output every file in this directory. If the file is prefixed
        # with a number, then that number is the maximum age of the
        # file in seconds. If the file is older than that, it is ignored.
        maxage=""
        part="$file"

        # Each away all digits from the front of the filename and
        # collect them in the variable maxage.
        while [ "${part/#[0-9]/}" != "$part" ]
        do
            maxage=$maxage${part:0:1}
            part=${part:1}
        done

        # If there is at least one digit, than we honor that.
        if [ "$maxage" ] ; then
            mtime=$(stat -c %Y "$file")
            if [ $((now - mtime)) -gt $maxage ] ; then
                continue
            fi
        fi

        # Output the file
        cat "$file"
    done
    cd - > /dev/null
fi


# Get statistics about monitored jobs. Below the job directory there
# is a sub directory per user that ran a job. That directory must be
# owned by the user so that a symlink or hardlink attack for reading
# arbitrary files can be avoided.
if [ -d "$MK_VARDIR/job" ]; then
    echo '<<<job>>>'
    CDIR=$(pwd)
    cd "$MK_VARDIR/job" 2> /dev/null || exit
    for username in *; do
        if [ -d "$username" ] && cd "$username"; then
            for i in *; do
               echo "==> $i <=="
               cat "$i"
            done
            cd .. > /dev/null
        fi
    done
    cd "$CDIR" 2> /dev/null || exit
fi

if [ -n "$FAILED_PYTHON_PLUGINS" ]; then
    echo "<<<check_mk>>>"
    echo "FailedPythonPlugins: ${FAILED_PYTHON_PLUGINS[*]}"
    if [ -n "$NO_PYTHON" ]; then
        echo "FailedPythonReason: No suitable python installation found."
    elif [ -n "$WRONG_PYTHON_COMMAND" ]; then
        echo "FailedPythonReason: Configured python command not found."
    fi
fi
