#!/bin/sh
# Copyright (C) 2019 Checkmk GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# Author: Lars Michelsen <lm@mathias-kettner.de>
#         Florian Heigl <florian.heigl@gmail.com>
#	  Christian Zigotzky <chzigotzky@xenosoft.de>

# NOTE: This agent has been adapted from the Checkmk FreeBSD agent.

: "${MK_RUN_SYNC_PARTS=true}"

$MK_RUN_SYNC_PARTS || {
    echo "Exclusive cache update and live-update (MK_RUN_SYNC_PARTS=false) is not suported on this system" >&2
    exit 1
}

# Remove locale settings to eliminate localized outputs where possible
export LC_ALL=C
unset LANG

export MK_LIBDIR="/usr/lib/check_mk_agent"
export MK_CONFDIR="/etc"

# Optionally set a tempdir for all subsequent calls
#export TMPDIR=

# Make sure, locally installed binaries are found
PATH=$PATH:/usr/local/bin

# All executables in PLUGINSDIR will simply be executed and their
# ouput appended to the output of the agent. Plugins define their own
# sections and must output headers with '<<<' and '>>>'
PLUGINSDIR=$MK_LIBDIR/plugins

# All executables in LOCALDIR will by executabled and their
# output inserted into the section <<<local>>>. Please refer
# to online documentation for details.
LOCALDIR=$MK_LIBDIR/local


# close standard input (for security reasons) and stderr
if [ "$1" = -d ]
then
    set -xv
else
    exec </dev/null 2>/dev/null
fi

_free_mem_index_vmstat() {
    # The number of output columns in the vmstat command changed in newer versions. We want the
    # entry under 'fre' (not a typo).
    # https://man.openbsd.org/OpenBSD-6.0/vmstat.8
    # https://man.openbsd.org/vmstat.8
    idx=1
    for col in "$@"; do
        if [ "$col" = "fre" ]; then
            printf "%s" "$idx"
            return 0
        fi
        idx=$((idx + 1))
    done
    return 1
}

_free_mem_with_unit_vmstat() {
    # Newer vmstat versions print "1M" instead of "1024" as free memory
    # SUP-11138
    # https://github.com/openbsd/src/blob/1c702c4a4395025332d4340f326500c590811dc8/usr.bin/vmstat/vmstat.c#L368
    case "${1}" in
        *M)
            mem_free_mb_with_unit="${1}"
            printf "%s" "${mem_free_mb_with_unit%?} MB"
            ;;
        *)
            printf "%s" "${1} kB"
            ;;
    esac
}

_free_mem_with_unit() {
    vmstat_output=$(vmstat)

    # shellcheck disable=SC2046  # we want word splitting here
    if ! mem_free_idx="$(_free_mem_index_vmstat $(echo "$vmstat_output" | tail -n2 | head -1))"; then
        return 1
    fi

    _free_mem_with_unit_vmstat "$(echo "$vmstat_output" | tail -n1 | awk -v idx="$mem_free_idx" '{ print $idx }')"

    return 0
}

section_openbsd_mem() {
    if ! mem_free_with_unit=$(_free_mem_with_unit); then
        return 1
    fi
    mem_total=$(sysctl hw.usermem | cut -d= -f2)
    mem_total=$(echo "$mem_total/1024" | bc)

    swapctl_output=$(swapctl -k -s)
    swap_free=$(echo "$swapctl_output" | awk '{ print $7 }')
    swap_total=$(echo "$swapctl_output" | awk '{ print $2 }')

    # if there is no swap space swap values are 0
    if [ -z "$swapctl_output" ]; then
        swap_free=0
        swap_total=0
    fi

    printf "<<<openbsd_mem>>>\n"
    printf "MemTotal:\t %s kB\n" "$mem_total"
    printf "MemFree:\t %s\n" "$mem_free_with_unit"
    printf "SwapTotal:\t %s kB\n" "$swap_total"
    printf "SwapFree:\t %s kB\n" "$swap_free"

    return 0
}

echo "<<<check_mk>>>"
echo "Version: 2.0.0p39"
echo "AgentOS: openbsd"
echo "Hostname: $(hostname)"
echo "AgentDirectory: $MK_CONFDIR"
echo "DataDirectory: $MK_VARDIR"
echo "SpoolDirectory: $SPOOLDIR"
echo "PluginsDirectory: $PLUGINSDIR"
echo "LocalDirectory: $LOCALDIR"

osver="$(uname -r)"

echo '<<<df>>>'
df -kPt ffs | sed -e 's/^\([^ ][^ ]*\) \(.*\)$/\1 ffs \2/' | sed 1d

# processes including username, without kernel processes
echo '<<<ps>>>'
ps ax -ww -o user,vsz,rss,pcpu,command | sed -e 1d -e 's/ *\([^ ]*\) *\([^ ]*\) *\([^ ]*\) *\([^ ]*\) */(\1,\2,\3,\4) /'

echo '<<<cpu>>>'
echo `sysctl -n vm.loadavg | tr -d '{}'` `top -b -n 1 | grep -E '^[0-9]+ processes' | awk '{print $3"/"$1}'` `sysctl -n hw.ncpu`

echo '<<<uptime>>>'
echo `date +%s` - `sysctl -n kern.boottime | cut -d' ' -f 4,7 | tr ',' '.' | tr -d ' '` | bc

section_openbsd_mem

echo '<<<lnx_if:sep(58)>>>'
# MC= MAC address
# BI= Bytes in
# PI= Packets in
# EI= Errors in
# EO= Errors out
# BO= Bytes out
# PO= Packets out
# CO= Colls
# NI= Number of interfaces
# INTERFACES= Array of interfaces

set -A INTERFACES
set -A MC
set -A BI
set -A BO
set -A PI
set -A PO
set -A EI
set -A EO
set -A CO

NI=0
# special (lo/pfsync/pflog/enc) and inactive (*) interfaces are not needed
NETSTAT_OUTPUT=$(netstat -in | grep '<Link>' | egrep -v "\*|lo|pfsync|enc")
NETSTAT_OUTPUT_BYTES=$(netstat -inb | grep '<Link>' | egrep -v "\*|lo|pfsync|enc")

# adjust internal field separator to get lines from netstat and backup it before
OFS=$IFS
IFS='
'
# collect netstat values and interface number
for NS in $NETSTAT_OUTPUT
    do
    NI=$(($NI+1))
    INTERFACES[$NI]=$(echo $NS | awk '{print $1}')
    MC[$NI]=$(echo $NS | awk '{print $4}')
    PI[$NI]=$(echo $NS | awk '{print $5}')
    EI[$NI]=$(echo $NS | awk '{print $6}')
    PO[$NI]=$(echo $NS | awk '{print $7}')
    EO[$NI]=$(echo $NS | awk '{print $8}')
    CO[$NI]=$(echo $NS | awk '{print $9}')
done

# need NIC counter again for byte values - reset it
NI=0
for NS in $NETSTAT_OUTPUT_BYTES
    do
    NI=$(($NI+1))
    BI[$NI]=$(echo $NS | awk '{print $5}')
    BO[$NI]=$(echo $NS | awk '{print $6}')
done

# what is this for?
[ "${NI}" -ge 1 ] || NI=15

# jot is OpenBSD "range"
for i in $(jot $NI)
    do
    echo "${INTERFACES[$i]}:${BI[$i]} ${PI[$i]} ${EI[$i]} 0 0 0 0 0 ${BO[$i]} ${PO[$i]} ${EO[$i]} 0 0 ${CO[$i]} 0 0"
done

for IF in $(jot $NI)
	do
	echo \[${INTERFACES[$IF]}\]

	IFCONFIG_OUTPUT=$(ifconfig ${INTERFACES[$IF]})
	for IO in $IFCONFIG_OUTPUT
		do
		# Speed
		SP=$(echo "$IO" | egrep "media:.*base" | cut -d\( -f2 | cut -db -f1)
		if [ "$SP" ]
			then
			echo "\tSpeed: "$SP"Mb/s"
		fi
		# Detect duplexity - in reality only available for physical devices but
		# virtual ones like CARP devices will get at least a half duplex
		if [ "$(echo "$IO" | egrep "media:.*full-duplex")" ]
			then
			echo "\tDuplex: Full"
		elif [ "$(echo "$IO" | grep "media:" | grep -v "full-duplex")" ]
			then
			echo "\tDuplex: Half"
		fi
		# Auto-negotiation
		if [ "$(echo "$IO" | egrep "media:.*autoselect")" ]
			then
			echo "\tAuto-negotiation: on"
		elif [ "$(echo "$IO" | grep "media:" | grep -v "autoselect")" ]
			then
			echo "\tAuto-negotiation: off"
		fi
		# Detect detected link
		if [ "$(echo "$IO" | grep "status:" | egrep "active|backup|master")" ]
			then
			echo "\tLink detected: yes"
		fi
	done

	echo "\tAddress: "${MC[$IF]}

done

# reset IFS to default
IFS=$OFS

# IPMI-Data (Fans, CPU, temperature, etc)
# needs the sysutils/ipmitool and kldload ipmi.ko
if which ipmitool >/dev/null ; then
    echo '<<<ipmi>>>'
    ipmitool sensor list \
        | grep -v 'command failed' \
        | sed -e 's/ *| */|/g' -e "s/ /_/g" -e 's/_*$//' -e 's/|/ /g' \
        | egrep -v '^[^ ]+ na ' \
        | grep -v ' discrete '
fi

if which mailq >/dev/null 2>&1 && getent passwd postfix >/dev/null 2>&1; then
  echo '<<<postfix_mailq>>>'
  mailq | tail -n 6
fi


# Einbinden von lokalen Plugins, die eine eigene Sektion ausgeben
if cd $PLUGINSDIR
then
  for skript in $(ls)
  do
    if [ -x "$skript" ] ; then
        ./$skript
    fi
  done
fi

# Lokale Einzelchecks
echo '<<<local:sep(0)>>>'
if cd $LOCALDIR
then
  for skript in $(ls)
  do
    if [ -x "$skript" ] ; then
        ./$skript
    fi
  done
fi

# MK's Remote Plugin Executor
if [ -e "$MK_CONFDIR/mrpe.cfg" ]
then
    echo '<<<mrpe>>>'
    grep -Ev '^[[:space:]]*($|#)' "$MK_CONFDIR/mrpe.cfg" | \
    while read descr cmdline
    do
        PLUGIN=${cmdline%% *}
        OUTPUT=$(eval "$cmdline")
        echo -n "(${PLUGIN##*/}) $descr $? $OUTPUT" | tr \\n \\1
        echo
    done
fi
