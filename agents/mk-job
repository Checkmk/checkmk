#!/bin/bash
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# Exempt from indentation rules as it's a heredoc
help() {
cat << EOF >&2
Usage: mk-job ident PROGRAM [ARGS...]

Execute PROGRAM as subprocess while measuring performance information
about the running process and writing it to an output file. This file
can be monitored using checkmk. The checkmk Agent will forward the
information of all job files to the monitoring server.

This file is being distributed with the checkmk Agent.
EOF

exit "${1:-0}"
}

# If args is less than 2, or 0, call `help()` and exit 1
[ "${#}" -lt 2 ] && help 1
[ "${#}" -eq 0 ] && help 1

# If help is requested, deliver it
[ "${1}" = "-h" ] && help 0
[ "${1}" = "--help" ] && help 0

# Source the agent, as it has a bunch of functions and variables for us to use
# shellcheck disable=SC1090
. "$(command -v check_mk_agent)" || exit 1

# Set up the variables that are specific to this script
output_path="${MK_VARDIR}/job/${USER}"
ident="${1:?}"
running_file="${output_path}/${ident}.$$running"
tmp_file="${running_file}.tmp"

# Shift to the rest of the positional parameters
shift

if [ ! -d "${output_path}" ]; then
    if [ "${USER}" = root ]; then
        mkdir -p "${output_path}"
    else
        echo "ERROR: Missing output directory ${output_path} for non-root user '${USER}'." >&2
        exit 1
    fi
fi

if ! inpath "${1}"; then
    echo "ERROR: Cannot run '${1}'. Command not found." >&2
    help 1
fi

echo "start_time $(get_epoch)" > "${running_file}" 2>/dev/null

if [ ! -w "${running_file}" ] ; then
  # Looks like we are lacking the permissions to create this file..
  # In this scenario no mk-job status file is created. We simply execute the command
  exec "$@"
fi

case "${MK_OSSTR}" in
    (aix)
        /usr/bin/time -p "$@" > "${tmp_file}"                   # execute the command
        return_code="${?}"                                      # save return code
        echo "exit_code ${return_code}" >> "${running_file}"    # then add the return code
        # and finally add the output of /usr/bin/time
        grep -E  '^real   |^user   |^sys    ' "${tmp_file}" | 
            sed -e 's/,/\./g' \
                -e 's/^real  /real_time/g' \
                -e 's/^user  /user_time/g' \
                -e 's/^sys   /system_time/g' \
            >> "${running_file}"
        echo "reads 0\nwrites 0\nmax_res_kbytes 0\navg_mem_kbytes 0\ninvol_context_switches 0\nvol_context_switches 0" >> "${running_file}"
    ;;
    (linux)
        /usr/bin/time -o "${running_file}" --append \
            -f "exit_code %x\nreal_time %E\nuser_time %U\nsystem_time %S\nreads %I\nwrites %O\nmax_res_kbytes %M\navg_mem_kbytes %K\ninvol_context_switches %c\nvol_context_switches %w" "$@"
        return_code="${?}"
    ;;
    (solaris)
        info=$( (/usr/bin/time -p sh -c "$* 2>/dev/null 1>&2" 2>&1; echo $?) | sed -e 's/,/\./g')
        return_code=$(echo "${info}" | awk '{print $7}')

        (echo "${info}" | 
            awk '{print "exit_code "$7"\nreal_time "$2"\nuser_time "$4"\nsystem_time "$6""}'
        ) >> "${running_file}"

        (echo -e "reads 0\nwrites 0\nmax_res_kbytes 0\navg_mem_kbytes 0\ninvol_context_switches 0\nvol_context_switches 0";
        ) >> "${running_file}"
    ;;
esac

mv "${running_file}" "${output_path}/${ident}"
[ -e "${tmp_file}" ] && rm -f "${tmp_file}"
exit "${return_code}"
