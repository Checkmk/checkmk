#!/bin/bash
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# Reason for this no-op: shellcheck disable=... before the first command disables the error for the
# entire script.
:

# Disable unused variable error (needed to keep track of version)
# shellcheck disable=SC2034
CMK_VERSION="2.1.0b2"

# Checkmk agent plugin for monitoring ORACLE databases
# This plugin is a result of the common work of Thorsten Bruhns
# and Mathias Kettner. Thorsten is responsible for the ORACLE
# stuff, Mathias for the shell hacking...

# This plugin works for Linux, Solaris and AIX.
# See http://docs.checkmk.com/master/en/monitoring_oracle.html
# for more details regarding configuration.

# TODO
# - cleanup ORACLE_SID, MK_SID, local sid
# - separate remote instance, local, ASM

#   .--default config------------------------------------------------------.
#   |       _       __             _ _                      __ _           |
#   |    __| | ___ / _| __ _ _   _| | |_    ___ ___  _ __  / _(_) __ _     |
#   |   / _` |/ _ \ |_ / _` | | | | | __|  / __/ _ \| '_ \| |_| |/ _` |    |
#   |  | (_| |  __/  _| (_| | |_| | | |_  | (_| (_) | | | |  _| | (_| |    |
#   |   \__,_|\___|_|  \__,_|\__,_|_|\__|  \___\___/|_| |_|_| |_|\__, |    |
#   |                                                            |___/     |
#   '----------------------------------------------------------------------'

load_default_config() {
    SYNC_SECTIONS="instance sessions logswitches undostat recovery_area processes recovery_status longactivesessions dataguard_stats performance locks systemparameter"
    ASYNC_SECTIONS="tablespaces rman jobs resumable iostats"
    SYNC_ASM_SECTIONS="instance processes"
    ASYNC_ASM_SECTIONS="asm_diskgroup"
    CACHE_MAXAGE=600
    OLRLOC=/etc/oracle/olr.loc
    MAX_TASKS=1
}

#.
#   .--usage---------------------------------------------------------------.
#   |                                                                      |
#   |                     _   _ ___  __ _  __ _  ___                       |
#   |                    | | | / __|/ _` |/ _` |/ _ \                      |
#   |                    | |_| \__ \ (_| | (_| |  __/                      |
#   |                     \__,_|___/\__,_|\__, |\___|                      |
#   |                                     |___/                            |
#   '----------------------------------------------------------------------'

display_usage() {
    load_default_config
    cat <<MK-ORA-USAGE

USAGE:
  mk_oracle [OPTIONS]

DESCRIPTION:
  Check_MK agent plugin for monitoring ORACLE databases. This plugin works for
  Linux, Solaris and AIX. See https://docs.checkmk.com/master/en/monitoring_oracle.html for
  more details regarding configuration.

OPTIONS:
  -h, --help            Shows this help message and exit

  -d                    Enable full bash debugging

  -t                    Just check the connection

  -l, --log             Logs certain steps while execution.
                        Note: These sections are executed as synchronous sections
                        The logfile is in the folder \$MK_VARDIR/log.

  -s, --sections <section>,...
                        Execute only these sections.
                        Note: These sections are execute as synchronous sections

  --oratestversion      Set a custom Oracleversion during execution.
                        This parameter is only for development. Example: 12.1

CONFIGURATION:
  The following variables can be used in the configuration file mk_oracle.cfg;
  mk_oracle.cfg is in the folder \$MK_CONFDIR or \$MK_VARDIR.

  SYNC_SECTIONS="<section> ..."
                        Specify which sections will be executed sychronously.
                        Default is "$SYNC_SECTIONS"

  ASYNC_SECTIONS="<section> ..."
                        Specify which sections will be executed asychronously.
                        Default is "$ASYNC_SECTIONS"

  SYNC_ASM_SECTIONS="<section> ..."
                        Specify which ASM sections will be executed sychronously.
                        Default is "$SYNC_ASM_SECTIONS"

  ASYNC_ASM_SECTIONS="<section> ..."
                        Specify which ASM sections will be executed asychronously.
                        Default is "$ASYNC_ASM_SECTIONS"

  CACHE_MAXAGE=<age>    Interval for running async checks (in seconds).
                        Default is "$CACHE_MAXAGE"

  OLRLOC=/PATH/TO/olr.loc
                        Disable the discovery from GI/Restart. A fully configured
                        oratab is mandatory, when this has been disabled. Be aware!
                        Please disable OLRLOC for failover cluster with custom
                        clusterware resources.
                        Default is "$OLRLOC"

  ONLY_SIDS="<sid> ..." Specify which SIDs will be checked.
                        This variable has priority 1.
                        Default is empty.

  SKIP_SIDS="<sid> ..." Specify which SIDs will not be checked.
                        This variable has priority 2.
                        Default is empty.

  EXCLUDE_<sid>="<section> ..."
                        Exclude sections for a specific SID. Valid values
                        are "ALL" or specific section names.
                        For ASM SIDs you cannot use this concept but you
                        can use SKIP_SIDS="+ASM1 ..." instead.
                        This variable has priority 3.
                        Default is empty.

  MAX_TASKS=<Number>    Specify how many SIDs to check in parallel
                        Default is "$MAX_TASKS"

CONFIGURATION REMOTE INSTANCES:
  REMOTE_INSTANCE_<id>="<user>:<password>:<role>:<host>:<port>:<piggybackhost>:<sid>:<version>:<tnsalias>"
                        <piggybackhost> and <tnsalias> are optional.

CONFIGURATION CUSTOM SQLS:
  The following variables for custom SQLs can be used in the configuration file
  mk_oracle.cfg. Global variables can be set in mk_oracle.cfg; local variables
  can be set within a section definition. Sections are defined in mk_oracle.cfg.
  There are global and local variables. The local variables have precedence and
  overwrite the global ones.
  The variable "\$ORACLE_SID" can be used within every section.

  SQLS_SECTIONS="<section>,..."
                        Registry of custom SQL sections. If this configuration
                        variable is not set or empty then no custom SQL sections
                        will be executed. A custom SQL section looks like:

                            section () {
                                VAR=VALUE
                                ...
                            }

                        Can only be set globally.
                        Default is empty.

  SQLS_SIDS="<sid>,..." List of SIDs for which the custom SQLs will be executed.
                        If not set then the section will be ignored. You can use
                        "\$SIDS" in order to execute the custom SQLs for all SIDs.
                        Can be set globally or within a section definition.

  SQLS_DIR=/PATH/TO/SQLDIR
                        Path of the directory where the SQLs are stored.
                        Can be set globally or within a section definition.

  SQLS_SQL=<name.sql>   File containing a SQL statement.
                        Can be set globally or within a section definition.

  SQLS_PARAMETERS=<params>
                        Parameters as a string, double quotes will be removed.
                        Can be set globally or within a section definition.

  SQLS_SECTION_NAME="<name>"
                        By default the section header is 'oracle_sql' is used and
                        the check plugin "oracle_sql" processes this data. The data
                        must have a fixed form:

                            <<<oracle_sql:sep(58)>>>
                            [[[<item>]]]
                            details:DETAILS
                            perfdata:NAME=VAL;WARN;CRIT;MIN;MAX ...
                            long:LONG
                            ...
                            exit:CODE

                        By default the <item> is "<sid>|<sql-name>".
                        Can be set globally or within a section definition.

  SQLS_SECTION_SEP="<sep>"
                        Only useful if SQLS_SECTION_NAME is not 'oracle_sql'.
                        ASCII code, eg. '58' means ':'.
                        Can be set globally or within a section definition.

  SQLS_ITEM_NAME=item_name
                        Only useful if SQLS_SECTION_NAME is 'oracle_sql'. In
                        this case the <item> is "<sid>|\$SQLS_ITEM_NAME".
                        Can only be set within a section definition.

  SQLS_MAX_CACHE_AGE=<age>
                        See CACHE_MAX_AGE.
                        Can be set globally or within a section definition.

MK-ORA-USAGE
}

#.
#   .--args----------------------------------------------------------------.
#   |                                                                      |
#   |                          __ _ _ __ __ _ ___                          |
#   |                         / _` | '__/ _` / __|                         |
#   |                        | (_| | | | (_| \__ \                         |
#   |                         \__,_|_|  \__, |___/                         |
#   |                                   |___/                              |
#   '----------------------------------------------------------------------'

MK_ORA_DEBUG=false
MK_ORA_DEBUG_CONNECT=false
MK_ORA_LOGGING=false
export MK_ORA_LOGGING

while test -n "$1"; do
    case "$1" in
        -h | --help)
            display_usage
            exit 0
            ;;

        -d)
            set -xv
            MK_ORA_DEBUG=true
            shift
            ;;

        -t)
            MK_ORA_DEBUG_CONNECT=true
            shift
            ;;

        -l | --log)
            MK_ORA_LOGGING=true
            shift
            ;;

        -s | --sections)
            shift
            MK_ORA_SECTIONS=$(echo "$1" | tr ',' ' ')
            shift
            ;;
        --oratestversion)
            shift
            MK_ORA_TESTVERSION="$1"
            shift
            ;;

        *)
            shift
            ;;
    esac
done

#.
#   .--config--------------------------------------------------------------.
#   |                                      __ _                            |
#   |                      ___ ___  _ __  / _(_) __ _                      |
#   |                     / __/ _ \| '_ \| |_| |/ _` |                     |
#   |                    | (_| (_) | | | |  _| | (_| |                     |
#   |                     \___\___/|_| |_|_| |_|\__, |                     |
#   |                                           |___/                      |
#   '----------------------------------------------------------------------'

filter_sections() {
    OPT_SYNC_SECTIONS=
    OPT_ASYNC_SECTIONS=
    OPT_SYNC_ASM_SECTIONS=
    OPT_ASYNC_ASM_SECTIONS=
    OPT_SQLS_SECTIONS=
    for section in $MK_ORA_SECTIONS; do
        if [ -n "$SYNC_SECTIONS" ] && [[ "$SYNC_SECTIONS" == *"$section"* ]]; then
            OPT_SYNC_SECTIONS="$OPT_SYNC_SECTIONS $section"
        elif [ -n "$ASYNC_SECTIONS" ] && [[ "$ASYNC_SECTIONS" == *"$section"* ]]; then
            OPT_ASYNC_SECTIONS="$OPT_ASYNC_SECTIONS $section"
        fi

        if [ -n "$SYNC_ASM_SECTIONS" ] && [[ "$SYNC_ASM_SECTIONS" == *"$section"* ]]; then
            OPT_SYNC_ASM_SECTIONS="$OPT_SYNC_ASM_SECTIONS $section"
        elif [ -n "$ASYNC_ASM_SECTIONS" ] && [[ "$ASYNC_ASM_SECTIONS" == *"$section"* ]]; then
            OPT_ASYNC_ASM_SECTIONS="$OPT_ASYNC_ASM_SECTIONS $section"
        fi

        if [ -n "$SQLS_SECTIONS" ] && [[ "$SQLS_SECTIONS" == *"$section"* ]]; then
            OPT_SQLS_SECTIONS="$OPT_SQLS_SECTIONS $section"
        fi
    done
    SYNC_SECTIONS=$OPT_SYNC_SECTIONS
    ASYNC_SECTIONS=$OPT_ASYNC_SECTIONS
    SYNC_ASM_SECTIONS=$OPT_SYNC_ASM_SECTIONS
    ASYNC_ASM_SECTIONS=$OPT_ASYNC_ASM_SECTIONS
    SQLS_SECTIONS=$OPT_SQLS_SECTIONS
}

load_config() {
    if [ ! "$MK_CONFDIR" ]; then
        echo "MK_CONFDIR not set!" >&2
        exit 1
    fi

    if [ ! "$MK_VARDIR" ]; then
        #TODO Which default? (run_cached/ mk_oracle.found, log file)
        export MK_VARDIR=$MK_CONFDIR
    fi

    if [ ! -d "$MK_VARDIR/log" ]; then
        mkdir "$MK_VARDIR/log"
    fi

    load_default_config

    # Source the optional configuration file for this agent plugin
    if [ -e "$MK_CONFDIR/mk_oracle.cfg" ]; then
        # shellcheck source=../cfg_examples/mk_oracle.cfg
        . "$MK_CONFDIR/mk_oracle.cfg"
    fi

    if [ -d "$MK_CONFDIR/mk_oracle.d" ] && [ "$(ls -A "$MK_CONFDIR/mk_oracle.d")" ]; then
        for cfg in "$MK_CONFDIR"/mk_oracle.d/*.cfg; do
            # shellcheck disable=SC1090
            . "$cfg"
        done
    fi

    if [ -n "$MK_ORA_SECTIONS" ]; then
        filter_sections
    fi

    # globals
    custom_sqls_sections=$(echo "$SQLS_SECTIONS" | tr ',' ' ')

    # globals and locals
    custom_sqls_section_name="oracle_sql" # SQLS_SECTION_NAME
    custom_sqls_section_sep="$SQLS_SECTION_SEP"
    custom_sqls_sids="$SQLS_SIDS"
    custom_sqls_dir="$SQLS_DIR"
    custom_sqls_sql="$SQLS_SQL"
    custom_sqls_parameters="$SQLS_PARAMETERS"
    custom_sqls_max_cache_age="$SQLS_MAX_CACHE_AGE"
    unset_custom_sqls_vars

    if $MK_ORA_LOGGING || [ -n "$MK_ORA_SECTIONS" ]; then
        MK_DEBUG_MODE=true
    else
        MK_DEBUG_MODE=false
    fi
}

#.
#   .--OS env--------------------------------------------------------------.
#   |                     ___  ____                                        |
#   |                    / _ \/ ___|    ___ _ ____   __                    |
#   |                   | | | \___ \   / _ \ '_ \ \ / /                    |
#   |                   | |_| |___) | |  __/ | | \ V /                     |
#   |                    \___/|____/   \___|_| |_|\_/                      |
#   |                                                                      |
#   '----------------------------------------------------------------------'

OS_TYPE=$(uname -s)

unsupported_os() {
    logging -c -e "[set_os_env]" "Unsupported OS: ${OS_TYPE}"
    exit 1
}

file_mtime() {
    /usr/bin/perl -e 'if (! -f $ARGV[0]){die "0000000"};$mtime=(stat($ARGV[0]))[9];print ($mtime);' "$1"
}

set_os_env() {
    if [ "$OS_TYPE" = 'Linux' ]; then
        GREP="grep"
        AWK="awk"

    elif [ "$OS_TYPE" = 'SunOS' ]; then
        # expand the PATH for inetd. Otherwise some stuff in /opt/sfw/bin is not found!
        export PATH=$PATH:/usr/ucb:/usr/proc/bin:opt/sfw/bin:/opt/sfw/sbin:/usr/sfw/bin:/usr/sfw/sbin:/opt/csw/bin
        GREP="/usr/xpg4/bin/grep"
        if [ ! -x "$GREP" ]; then
            logging -c -e "[set_os_env]" "Please make sure that ${GREP} is existing on Solaris. Aborting mk_oracle plugin."
            exit 127
        fi

        AWK="nawk"

    elif [ "$OS_TYPE" = 'AIX' ]; then
        GREP="grep"
        AWK="awk"

    elif [ "$OS_TYPE" = 'HP-UX' ]; then
        GREP="grep"
        AWK="awk"

    else
        unsupported_os

    fi

    export GREP AWK
}

mk_ora_atime() {
    case $OS_TYPE in
        Linux) stat -c %X "$@" ;;
        SunOS | AIX) file_mtime "$@" ;;
        HP-UX) perl -le 'print((stat shift)[8])' "$@" ;;
        *) unsupported_os ;;
    esac
}

mk_ora_mtime() {
    case $OS_TYPE in
        Linux) stat -c %Y "$@" ;;
        SunOS | AIX) file_mtime "$@" ;;
        HP-UX) perl -le 'print((stat shift)[9])' "$@" ;;
        *) unsupported_os ;;
    esac
}

#.
#   .--logging-------------------------------------------------------------.
#   |                  _                   _                               |
#   |                 | | ___   __ _  __ _(_)_ __   __ _                   |
#   |                 | |/ _ \ / _` |/ _` | | '_ \ / _` |                  |
#   |                 | | (_) | (_| | (_| | | | | | (_| |                  |
#   |                 |_|\___/ \__, |\__, |_|_| |_|\__, |                  |
#   |                          |___/ |___/         |___/                   |
#   '----------------------------------------------------------------------'

# How to use logging function:
# Basic form:
#   logging "[WHEREIAM]"
#
# Logging without ID ELSEWHERE:
#   logging "[ELSEWHERE]"
#
# Logging with ID:
#   logging "[ID]"
#
# Logging with ID in function:
#   logging "[ID] [FUNC-NAME]"
#
# Logging with ID elsewhere:
#   logging "[ID] [ELSEWHERE]"
#
# Add some useful messages:
#   logging "" "Set ORACLE_HOME=${ORACLE_HOME}"
#
# There are some optional flags for prefix in log lines:
#   Flag        Criticality         Meaning
# --------------------------------------------------------------
#   '-o'        0 (OK)              clear
#   '-w'        1 (WARNING)         error but plugin goes on
#   '-c'        2 (CRITICAL)        error and plugin exits
#   '-u'        3 (UNKNOWN)         ?
#   '-e'                            Writes message to stderr, too
#
# Add some useful messages:
#   logging "" "Set OS environment" "OS: ${OS_TYPE}" "GREP: ${GREP}"
#
# Examples:
#   logging "[${SID}] [set_ora_env]" "Found local ORACLE_HOME: ${ORACLE_HOME}"
#   >>> 2018-05-15 16:27:43 [0] [352] [this-sid] [set_ora_env] Found local ORACLE_HOME: /path/to/ora/home
#
#   logging "[preliminaries]" "Set OS environment" "OS: ${OS_TYPE}" "GREP: ${GREP}" "AWK: ${AWK}"
#   >>> 2018-05-15 16:27:43 [0] [1748] [preliminaries] Set OS environment
#   >>> 2018-05-15 16:27:44 [0] [1748] [preliminaries] OS: Linux
#   >>> 2018-05-15 16:27:45 [0] [1748] [preliminaries] GREP: /bin/grep
#   >>> 2018-05-15 16:27:46 [0] [1748] [preliminaries] AWK: /usr/bin/awk
#
#   logging -c "[${SID}] [set_ora_env]" "ORA-99999 oratab not found in local mode"
#   >>> 2018-05-15 16:27:43 [2] [362] [this-sid] [set_ora_env] ORA-99999 oratab not found in local mode
#
# If you need to declare some headers:
#   logging "" "-- Set OS environment --" "OS: ${OS_TYPE}" "GREP: ${GREP}"
#   >>> 2018-05-15 16:27:43 [0] [1748] [preliminaries] -- Set OS environment --
#   >>> 2018-05-15 16:27:44 [0] [1748] [preliminaries] OS: Linux
#   >>> 2018-05-15 16:27:45 [0] [1748] [preliminaries] GREP: /bin/grep

logging() {
    if $MK_ORA_LOGGING; then
        local log_file=${MK_VARDIR}/log/mk_oracle_task_${TASK_NR:-0}.log
        local criticality=
        local args=
        local header=
        local to_stderr=false

        i=0
        while test -n "$1"; do
            case "$1" in
                -o)
                    criticality="0" # OK, default
                    shift
                    ;;

                -w)
                    criticality="1" # WARNING
                    shift
                    ;;

                -c)
                    criticality="2" # CRITICAL
                    shift
                    ;;

                -u)
                    criticality="3" # UNKNOWN
                    shift
                    ;;

                -e)
                    to_stderr=true
                    shift
                    ;;

                *)
                    args[$i]="$1"
                    i=$((i + 1))
                    shift
                    ;;
            esac
        done

        if [ -z "${criticality}" ]; then
            criticality="0"
        fi

        header="$(perl -MPOSIX -le 'print strftime "%F %T", localtime $^T') [${criticality}] ${args[0]}"

        if [ "${#args[@]}" -le 1 ]; then
            echo "$header" >>"$log_file"
            if [ $to_stderr = true ]; then
                echo "$header" >&2
            fi
        else
            for arg in "${args[@]:1}"; do
                echo "${header} $arg" >>"$log_file"
                if [ $to_stderr = true ]; then
                    echo "${header} $arg" >&2
                fi
            done
        fi
    fi
}

#.
#   .--ORA env-------------------------------------------------------------.
#   |                ___  ____      _                                      |
#   |               / _ \|  _ \    / \      ___ _ ____   __                |
#   |              | | | | |_) |  / _ \    / _ \ '_ \ \ / /                |
#   |              | |_| |  _ <  / ___ \  |  __/ | | \ V /                 |
#   |               \___/|_| \_\/_/   \_\  \___|_| |_|\_/                  |
#   |                                                                      |
#   '----------------------------------------------------------------------'

set_ora_env() {
    local sid=${1}
    ORACLE_SID="$sid"
    unset ORA_HOME_SOURCE

    if [[ "$sid" =~ ^REMOTE_INSTANCE_.* ]]; then
        # we get the ORACLE_HOME from mk_oracle.cfg for REMOTE execution
        ORACLE_HOME=${ORACLE_HOME:-${REMOTE_ORACLE_HOME}}
        export ORA_HOME_SOURCE="(remote):"

    else
        # we work in local mode
        # GI/Restart installed?
        if [ -f ${OLRLOC} ]; then
            # oratab is not supported in Grid-Infrastructure 12.2+
            # => fetch ORACLE_HOME from cluster repository for all GI/Restart Environments!
            # OLRLOC holds CRS_HOME
            # shellcheck disable=SC1090
            . ${OLRLOC}
            export ORA_HOME_SOURCE="(GI):    "

            # set ORACLE_HOME = crs_home for ASM
            if [ "${ORACLE_SID:0:1}" = '+' ]; then
                # shellcheck disable=SC2154
                ORACLE_HOME=${crs_home}
            else
                # get ORACLE_HOME with crsctl from Oracle Grid Infrastructure / Restart
                ORACLE_HOME=$("${crs_home}"/bin/crsctl stat res -p -w "((TYPE = ora.database.type) and (GEN_USR_ORA_INST_NAME = ${ORACLE_SID}))" | grep -m1 "^ORACLE_HOME=" | cut -d"=" -f2)
            fi
        else
            # Single Instance with oratab
            test -f /etc/oratab && ORATAB=/etc/oratab
            # /var/opt/oracle/oratab is needed for Oracle Solaris
            test -f /var/opt/oracle/oratab && ORATAB=/var/opt/oracle/oratab
            if ! test -f ${ORATAB:-""}; then
                logging -c -e "[${sid}] [set_ora_env]" "ORA-99999 oratab not found in local mode"
                exit 1
            fi
            ORACLE_HOME=$("${GREP}" "^${ORACLE_SID}:" <"${ORATAB}" | cut -d":" -f2)
            export ORA_HOME_SOURCE="(oratab):"
        fi

        if [ -z "${ORACLE_HOME}" ]; then
            # cut last number from SID for Oracle RAC to find entry in oratab
            ORACLE_HOME=$("${GREP}" "^${ORACLE_SID/%[0-9]/}:" <"${ORATAB}" | cut -d":" -f2)
        fi
    fi

    LD_LIBRARY_PATH=$ORACLE_HOME/lib
    if [ ! -d "${ORACLE_HOME:-'not_found'}" ]; then
        logging -c -e "[${sid}] [set_ora_env]" "ORA-99999 ORACLE_HOME for SID '${ORACLE_SID}' not found or not existing!"
        return 2
    fi

    TNS_ADMIN=${TNS_ADMIN:-$MK_CONFDIR}
    if ! test -f "${TNS_ADMIN}/sqlnet.ora"; then
        logging -c -e "[${sid}] [set_ora_env]" "TNS_ADMIN/sqlnet.ora: ${TNS_ADMIN}/sqlnet.ora"
        exit 1
    fi
    export ORACLE_HOME TNS_ADMIN ORACLE_SID LD_LIBRARY_PATH
}

set_ora_version() {
    if [ "$MK_ORA_TESTVERSION" ]; then
        ORACLE_VERSION="$MK_ORA_TESTVERSION"
        logging -o -e "[${sid}] [set_ora_version]" "Custom ORACLE_VERSION: ${ORACLE_VERSION}"
    else
        ORACLE_VERSION="$1"
    fi

    NUMERIC_ORACLE_VERSION=${ORACLE_VERSION//./}
    export NUMERIC_ORACLE_VERSION

}

#.
#   .--SQL Queries---------------------------------------------------------.
#   |        ____   ___  _        ___                  _                   |
#   |       / ___| / _ \| |      / _ \ _   _  ___ _ __(_) ___  ___         |
#   |       \___ \| | | | |     | | | | | | |/ _ \ '__| |/ _ \/ __|        |
#   |        ___) | |_| | |___  | |_| | |_| |  __/ |  | |  __/\__ \        |
#   |       |____/ \__\_\_____|  \__\_\\__,_|\___|_|  |_|\___||___/        |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   | The following functions create SQL queries for ORACLE and output     |
#   | them to stdout. All queries output the database name or the instane  |
#   | name as first column.                                                |
#   | V$BUFFER_POOL_STATISTICS: Convert Instancedata to cdb$root in        |
#   |                           cdb-environments (only con_id = 0!)        |
#   | V$SGAINFO: Convert Instancedata to cdb$root in cdb-environments      |
#   '----------------------------------------------------------------------'

#TODO Create subsections in query and parse them in related check plugin.
sql_iostats() {
    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then
        echo 'PROMPT <<<oracle_performance:sep(124)>>>'
        echo "WITH iostat_file AS (
                SELECT con_id,
                    filetype_name,
                    SUM(large_read_reqs) large_read_reqs,
                    SUM(large_read_servicetime) large_read_servicetime,
                    SUM(large_write_reqs) large_write_reqs,
                    SUM(large_write_servicetime) large_write_servicetime,
                    SUM(small_read_reqs) small_read_reqs,
                    SUM(small_read_servicetime) small_read_servicetime,
                    SUM(small_sync_read_reqs) small_sync_read_reqs,
                    SUM(small_write_reqs) small_write_reqs,
                    SUM(small_write_servicetime) small_write_servicetime,
                    SUM(small_read_megabytes * 1024 * 1024) small_read_bytes,
                    SUM(large_read_megabytes * 1024 * 1024) large_read_bytes,
                    SUM(small_write_megabytes * 1024 * 1024) small_write_bytes,
                    SUM(large_write_megabytes * 1024 * 1024) large_write_bytes
                FROM v\$iostat_file
                GROUP BY con_id,
                    filetype_name
            )
            SELECT upper(
                    DECODE(
                        d.cdb,
                        'NO',
                        i.instance_name,
                        i.instance_name || '.' || vd.name
                    )
                )
                || '|iostat_file'
                || '|' || filetype_name
                || '|' || small_read_reqs
                || '|' || large_read_reqs
                || '|' || small_write_reqs
                || '|' || large_write_reqs
                || '|' || small_read_servicetime
                || '|' || large_read_servicetime
                || '|' || small_write_servicetime
                || '|' || large_write_servicetime
                || '|' || small_read_bytes
                || '|' || large_read_bytes
                || '|' || small_write_bytes
                || '|' || large_write_bytes
            FROM iostat_file io
                JOIN v\$containers vd ON io.con_id = vd.con_id
                JOIN v\$instance i ON 1 = 1
                JOIN v\$database d ON 1 = 1
            ORDER BY vd.con_id,
                io.filetype_name;"
    fi
}

sql_performance() {

    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then
        echo 'PROMPT <<<oracle_performance:sep(124)>>>'
        echo "        select upper(DECODE(cdb,'NO',instance_name
                                             ,instance_name || '.' || con_name) )
                     ||'|'|| 'sys_time_model'
                     ||'|'|| STAT_NAME
                     ||'|'|| Round(value/1000000)
              from (
              select d.cdb, i.instance_name, s.stat_name, s.value, vd.name con_name
                  from v\$instance i
                  join v\$con_sys_time_model s on s.stat_name in('DB time', 'DB CPU')
                  join v\$containers vd on vd.con_id = s.con_id
                  join v\$database d on d.cdb = 'YES'
                  where vd.con_id <> 2
                  union all
                  select d.cdb, i.instance_name, s.stat_name, s.value, null
                  from v\$instance i
                  join v\$sys_time_model s on s.stat_name in('DB time', 'DB CPU')
                  join v\$database d on d.cdb = 'NO'
                  order by stat_name);
              select upper(decode(cdb, 'NO', instance_name
                                           ,instance_name || '.'||con_name))
                     ||'|'|| 'sys_wait_class'
                     ||'|'|| WAIT_CLASS
                     ||'|'|| Round(total_waits)
                     ||'|'|| Round(time_waited)
                     ||'|'|| Round(total_waits_fg)
                     ||'|'|| Round(time_waited_fg)
              from (
                  select i.instance_name, vd.con_id, S.WAIT_CLASS
                        , s.total_waits, s.time_waited, s.total_waits_fg
                        , s.time_waited_fg, vd.name con_name, d.cdb
                  from v\$instance i
                  join v\$database d on d.cdb = 'YES'
                  join v\$containers vd on 1=1
                  join v\$con_system_wait_class s on vd.con_id = s.con_id
                  where s.WAIT_CLASS <> 'Idle'
                  union all
                  select i.instance_name, 0, S.WAIT_CLASS
                        , s.total_waits, s.time_waited, s.total_waits_fg
                        , s.time_waited_fg, null, d.cdb
                  from v\$instance i
                  join v\$database d on d.cdb = 'NO'
                  join v\$system_wait_class s on s.WAIT_CLASS <> 'Idle'
                   )
              order by con_name, wait_class;
              select upper(DECODE(d.cdb,'NO',i.instance_name
                                     ,i.instance_name || '.CDB\$ROOT') )
                     ||'|'|| 'buffer_pool_statistics'
                     ||'|'|| b.name
                     ||'|'|| b.db_block_gets
                     ||'|'|| b.db_block_change
                     ||'|'|| b.consistent_gets
                     ||'|'|| b.physical_reads
                     ||'|'|| b.physical_writes
                     ||'|'|| b.FREE_BUFFER_WAIT
                     ||'|'|| b.BUFFER_BUSY_WAIT
              from v\$instance i
              join V\$BUFFER_POOL_STATISTICS b on b.con_id = 0
              join v\$database d on 1=1;
              select upper(DECODE(d.cdb,'NO',i.instance_name
                                     ,i.instance_name || '.CDB\$ROOT') )
                     ||'|'|| 'SGA_info'
                     ||'|'|| s.name
                     ||'|'|| s.bytes
              from v\$instance i
              join V\$sgainfo s on s.con_id = 0
              join v\$database d on 1=1;
              select upper(DECODE(d.cdb,'NO',i.instance_name
                                     ,i.instance_name || '.CDB\$ROOT') )
                     ||'|'|| 'librarycache'
                     ||'|'|| b.namespace
                     ||'|'|| b.gets
                     ||'|'|| b.gethits
                     ||'|'|| b.pins
                     ||'|'|| b.pinhits
                     ||'|'|| b.reloads
                     ||'|'|| b.invalidations
              from v\$instance i
              join V\$librarycache b on b.con_id = 0
              join v\$database d on 1=1;
SET SERVEROUTPUT ON
SET FEEDBACK OFF
DECLARE
    l_i_cursor_id     INTEGER;
    l_n_rowcount      NUMBER;
    l_vc_name   VARCHAR2(200);
    l_vc_value  VARCHAR2(200);
    l_vc_unit   VARCHAR2(20);
    l_vc_sql    VARCHAR2(200);
    l_vc_step   VARCHAR2(20);
BEGIN
    dbms_output.enable(200000);
    l_i_cursor_id := dbms_sql.open_cursor(security_level => 2);
    l_vc_step := 'before con';
    FOR con IN (
        SELECT
         upper(DECODE(d.cdb,'NO',i.instance_name
                           ,i.instance_name || '.' || c.name
                     )
              ) iname, c.name
        FROM
            v\$containers c,
            v\$database d,
            v\$instance i
        WHERE
            c.open_mode LIKE 'READ %'
            AND c.name <> 'PDB\$SEED'
        ORDER BY c.con_id) LOOP
        l_vc_sql := 'select name, value, unit from v\$pgastat order by name';
        l_vc_step := 'parse: ' || con.name;
        dbms_sql.parse(c => l_i_cursor_id, statement => l_vc_sql, language_flag => dbms_sql
        .native, container => con.name);
        dbms_sql.define_column(l_i_cursor_id, 1, l_vc_name, 200);
        dbms_sql.define_column(l_i_cursor_id, 2, l_vc_value, 200);
        dbms_sql.define_column(l_i_cursor_id, 3, l_vc_unit, 200);
        l_vc_step := 'execute: ' || con.name;
        l_n_rowcount := dbms_sql.execute_and_fetch(l_i_cursor_id);
        LOOP
            EXIT WHEN dbms_sql.fetch_rows(l_i_cursor_id) = 0;
            dbms_sql.column_value(l_i_cursor_id, 1, l_vc_name);
            dbms_sql.column_value(l_i_cursor_id, 2, l_vc_value);
            dbms_sql.column_value(l_i_cursor_id, 3, l_vc_unit);
            dbms_output.put_line(con.iname ||'|PGA_info|'||l_vc_name||'|'||l_vc_value||'|'||l_vc_unit);
        END LOOP;
    END LOOP;
    dbms_sql.close_cursor(l_i_cursor_id);
EXCEPTION
    WHEN OTHERS THEN
        FOR cur1 in (select upper(i.instance_name) instance_name from  v\$instance i) LOOP
            dbms_output.put_line(cur1.instance_name || '| Debug: '|| l_vc_step || ': ' || sqlerrm);
        END LOOP;
END;
/
"

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 101 ]; then
        echo "PROMPT <<<oracle_performance:sep(124)>>>"
        echo "select upper(i.INSTANCE_NAME)
                     ||'|'|| 'sys_time_model'
                     ||'|'|| S.STAT_NAME
                     ||'|'|| Round(s.value/1000000)
              from v\$instance i,
                   v\$sys_time_model s
              where s.stat_name in('DB time', 'DB CPU')
              order by s.stat_name;
              select upper(i.INSTANCE_NAME)
                     ||'|'|| 'buffer_pool_statistics'
                     ||'|'|| b.name
                     ||'|'|| b.db_block_gets
                     ||'|'|| b.db_block_change
                     ||'|'|| b.consistent_gets
                     ||'|'|| b.physical_reads
                     ||'|'|| b.physical_writes
                     ||'|'|| b.FREE_BUFFER_WAIT
                     ||'|'|| b.BUFFER_BUSY_WAIT
              from v\$instance i, V\$BUFFER_POOL_STATISTICS b;
              select upper(i.INSTANCE_NAME)
                     ||'|'|| 'SGA_info'
                     ||'|'|| s.name
                     ||'|'|| s.bytes
              from v\$sgainfo s, v\$instance i;
              select upper(i.INSTANCE_NAME)
                     ||'|'|| 'librarycache'
                     ||'|'|| b.namespace
                     ||'|'|| b.gets
                     ||'|'|| b.gethits
                     ||'|'|| b.pins
                     ||'|'|| b.pinhits
                     ||'|'|| b.reloads
                     ||'|'|| b.invalidations
              from v\$instance i, V\$librarycache b;"
    fi
}

sql_tablespaces() {

    echo "PROMPT <<<oracle_tablespaces:sep(124)>>>"
    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then

        echo "SET SERVEROUTPUT ON feedback off
              DECLARE
                  type x is table of varchar2(20000) index by pls_integer;
                  xx x;
              begin
                  begin
                      execute immediate 'select upper(decode(${IGNORE_DB_NAME:-0}
                                 , 0, decode(vp.con_id, null, d.NAME
                                            ,d.NAME||''.''||vp.name)
                                 , i.instance_name))
                  || ''|'' || dbf.file_name
                  || ''|'' || dbf.tablespace_name
                  || ''|'' || dbf.fstatus
                  || ''|'' || dbf.AUTOEXTENSIBLE
                  || ''|'' || dbf.blocks
                  || ''|'' || dbf.maxblocks
                  || ''|'' || dbf.USER_BLOCKS
                  || ''|'' || dbf.INCREMENT_BY
                  || ''|'' || dbf.ONLINE_STATUS
                  || ''|'' || dbf.BLOCK_SIZE
                  || ''|'' || decode(tstatus,''READ ONLY'', ''READONLY'', tstatus)
                  || ''|'' || dbf.free_blocks
                  || ''|'' || dbf.contents
                  || ''|'' || i.version
           from v\$database d
           join v\$instance i on 1=1
           join (
                    select f.con_id, f.file_name, f.tablespace_name, f.status fstatus, f.AUTOEXTENSIBLE,
                    f.blocks, f.maxblocks, f.USER_BLOCKS, f.INCREMENT_BY,
                    f.ONLINE_STATUS, t.BLOCK_SIZE, t.status tstatus, nvl(sum(fs.blocks),0) free_blocks, t.contents
                    from cdb_data_files f
                    join cdb_tablespaces t on f.tablespace_name = t.tablespace_name
                                          and f.con_id = t.con_id
                    left outer join cdb_free_space fs on f.file_id = fs.file_id
                                                     and f.con_id = fs.con_id
                    group by f.con_id, f.file_name, f.tablespace_name, f.status, f.autoextensible,
                    f.blocks, f.maxblocks, f.user_blocks, f.increment_by, f.online_status,
                    t.block_size, t.status, t.contents
                ) dbf on 1=1
           left outer join v\$pdbs vp on dbf.con_id = vp.con_id
           where d.database_role = ''PRIMARY'''
                      bulk collect into xx;
                      if xx.count >= 1 then
                          for i in 1 .. xx.count loop
                              dbms_output.put_line(xx(i));
                          end loop;
                      end if;
                  exception
                      when others then
                          for cur1 in (select upper(name) name from  v\$database) loop
                              dbms_output.put_line(cur1.name || '| Debug (121) 1: ' ||sqlerrm);
                          end loop;
                  end;
              END;
              /
              set serverout off"

        echo "SET SERVEROUTPUT ON feedback off
              DECLARE
                  type x is table of varchar2(20000) index by pls_integer;
                  xx x;
              begin
                  begin
                      execute immediate 'select upper(decode(${IGNORE_DB_NAME:-0}
                                 , 0, decode(dbf.con_id, null, d.NAME
                                            ,dbf.name)
                                 , i.instance_name))
                  || ''|'' || dbf.file_name
                  || ''|'' || dbf.tablespace_name
                  || ''|'' || dbf.fstatus
                  || ''|'' || dbf.AUTOEXTENSIBLE
                  || ''|'' || dbf.blocks
                  || ''|'' || dbf.maxblocks
                  || ''|'' || dbf.USER_BLOCKS
                  || ''|'' || dbf.INCREMENT_BY
                  || ''|'' || dbf.ONLINE_STATUS
                  || ''|'' || dbf.BLOCK_SIZE
                  || ''|'' || decode(tstatus,''READ ONLY'', ''READONLY'', tstatus)
                  || ''|'' || dbf.free_blocks
                  || ''|'' || ''TEMPORARY''
                  || ''|'' || i.version
           FROM v\$database d
           JOIN v\$instance i ON 1 = 1
           JOIN (
                 SELECT vp.name,
                        vp.con_id,
                        f.file_name,
                        t.tablespace_name,
                        f.status fstatus,
                        f.autoextensible,
                        f.blocks,
                        f.maxblocks,
                        f.user_blocks,
                        f.increment_by,
                        ''ONLINE'' online_status,
                        t.block_size,
                        t.status tstatus,
                        f.blocks - nvl(SUM(tu.blocks),0) free_blocks,
                        t.contents
                 FROM cdb_tablespaces t
                 JOIN (
                       SELECT vp.con_id
                             ,d.name || ''.''|| vp.name name
                       FROM v\$containers vp
                       JOIN v\$database d ON 1 = 1
                       WHERE d.cdb = ''YES''
                         AND vp.con_id <> 2
                       UNION ALL
                       SELECT 0
                             ,name
                       FROM v\$database
                      ) vp ON t.con_id = vp.con_id
                 LEFT OUTER JOIN cdb_temp_files f ON t.con_id = f.con_id
                                                 AND t.tablespace_name = f.tablespace_name
                 LEFT OUTER JOIN gv\$tempseg_usage tu ON f.con_id = tu.con_id
                                                      AND f.tablespace_name = tu.tablespace
                                                      AND f.RELATIVE_FNO = tu.SEGRFNO#
                 WHERE t.contents = ''TEMPORARY''
                 GROUP BY vp.name,
                          vp.con_id,
                          f.file_name,
                          t.tablespace_name,
                          f.status,
                          f.autoextensible,
                          f.blocks,
                          f.maxblocks,
                          f.user_blocks,
                          f.increment_by,
                          t.block_size,
                          t.status,
                          t.contents
                ) dbf ON 1 = 1
           where d.database_role = ''PRIMARY'''
                      bulk collect into xx;
                      if xx.count >= 1 then
                          for i in 1 .. xx.count loop
                              dbms_output.put_line(xx(i));
                          end loop;
                      end if;
                  exception
                      when others then
                          for cur1 in (select upper(name) name from  v\$database) loop
                              dbms_output.put_line(cur1.name || '| Debug (121) 2: ' ||sqlerrm);
                          end loop;
                  end;
              END;
              /
              set serverout off"

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 102 ]; then
        echo "SET SERVEROUTPUT ON feedback off
              DECLARE
                  type x is table of varchar2(20000) index by pls_integer;
                  xx x;
              begin
                  begin
                      execute immediate 'select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                  || ''|'' || file_name ||''|''|| tablespace_name ||''|''|| fstatus ||''|''|| AUTOEXTENSIBLE
                  ||''|''|| blocks ||''|''|| maxblocks ||''|''|| USER_BLOCKS ||''|''|| INCREMENT_BY
                  ||''|''|| ONLINE_STATUS ||''|''|| BLOCK_SIZE
                  ||''|''|| decode(tstatus,''READ ONLY'', ''READONLY'', tstatus) || ''|'' || free_blocks
                  ||''|''|| contents
                  ||''|''|| iversion
           from v\$database d , v\$instance i, (
                    select f.file_name, f.tablespace_name, f.status fstatus, f.AUTOEXTENSIBLE,
                    f.blocks, f.maxblocks, f.USER_BLOCKS, f.INCREMENT_BY,
                    f.ONLINE_STATUS, t.BLOCK_SIZE, t.status tstatus, nvl(sum(fs.blocks),0) free_blocks, t.contents,
                    (select version from v\$instance) iversion
                    from dba_data_files f, dba_tablespaces t, dba_free_space fs
                    where f.tablespace_name = t.tablespace_name
                    and f.file_id = fs.file_id(+)
                    group by f.file_name, f.tablespace_name, f.status, f.autoextensible,
                    f.blocks, f.maxblocks, f.user_blocks, f.increment_by, f.online_status,
                    t.block_size, t.status, t.contents)
           where d.database_role = ''PRIMARY'''
                      bulk collect into xx;
                      if xx.count >= 1 then
                          for i in 1 .. xx.count loop
                              dbms_output.put_line(xx(i));
                          end loop;
                      end if;
                  exception
                      when others then
                          for cur1 in (select upper(name) name from  v\$database) loop
                              dbms_output.put_line(cur1.name || '| Debug (102) 1: ' ||sqlerrm);
                          end loop;
                  end;
              END;
              /
              set serverout off"

        echo "SET SERVEROUTPUT ON feedback off
              DECLARE
                  type x is table of varchar2(20000) index by pls_integer;
                  xx x;
              begin
                  begin
                      execute immediate 'select upper(decode(${IGNORE_DB_NAME:-0}
                                 , 0, dbf.name
                                 , i.instance_name))
                  || ''|'' || dbf.file_name
                  || ''|'' || dbf.tablespace_name
                  || ''|'' || dbf.fstatus
                  || ''|'' || dbf.AUTOEXTENSIBLE
                  || ''|'' || dbf.blocks
                  || ''|'' || dbf.maxblocks
                  || ''|'' || dbf.USER_BLOCKS
                  || ''|'' || dbf.INCREMENT_BY
                  || ''|'' || dbf.ONLINE_STATUS
                  || ''|'' || dbf.BLOCK_SIZE
                  || ''|'' || decode(tstatus,''READ ONLY'', ''READONLY'', tstatus)
                  || ''|'' || dbf.free_blocks
                  || ''|'' || ''TEMPORARY''
                  || ''|'' || i.version
           FROM v\$database d
           JOIN v\$instance i ON 1 = 1
           JOIN (
                 SELECT vp.name,
                        f.file_name,
                        t.tablespace_name,
                        f.status fstatus,
                        f.autoextensible,
                        f.blocks,
                        f.maxblocks,
                        f.user_blocks,
                        f.increment_by,
                        ''ONLINE'' online_status,
                        t.block_size,
                        t.status tstatus,
                        f.blocks - nvl(SUM(tu.blocks),0) free_blocks,
                        t.contents
                 FROM dba_tablespaces t
                 JOIN ( SELECT 0
                             ,name
                       FROM v\$database
                      ) vp ON 1=1
                 LEFT OUTER JOIN dba_temp_files f ON t.tablespace_name = f.tablespace_name
                 LEFT OUTER JOIN gv\$tempseg_usage tu ON f.tablespace_name = tu.tablespace
                                                      AND f.RELATIVE_FNO = tu.SEGRFNO#
                 WHERE t.contents = ''TEMPORARY''
                 GROUP BY vp.name,
                          f.file_name,
                          t.tablespace_name,
                          f.status,
                          f.autoextensible,
                          f.blocks,
                          f.maxblocks,
                          f.user_blocks,
                          f.increment_by,
                          t.block_size,
                          t.status,
                          t.contents
                ) dbf ON 1 = 1'
                      bulk collect into xx;
                      if xx.count >= 1 then
                          for i in 1 .. xx.count loop
                              dbms_output.put_line(xx(i));
                          end loop;
                      end if;
                  exception
                      when others then
                          for cur1 in (select upper(name) name from  v\$database) loop
                              dbms_output.put_line(cur1.name || '| Debug (102) 2: ' ||sqlerrm);
                          end loop;
                  end;
              END;
              /
              set serverout off"

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 92 ]; then
        echo "select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                  || '|' || file_name ||'|'|| tablespace_name ||'|'|| fstatus ||'|'|| AUTOEXTENSIBLE
                  ||'|'|| blocks ||'|'|| maxblocks ||'|'|| USER_BLOCKS ||'|'|| INCREMENT_BY
                  ||'|'|| ONLINE_STATUS ||'|'|| BLOCK_SIZE
                  ||'|'|| decode(tstatus,'READ ONLY', 'READONLY', tstatus) || '|' || free_blocks
                  ||'|'|| contents
           from v\$database d , v\$instance i, (
                    select f.file_name, f.tablespace_name, f.status fstatus, f.AUTOEXTENSIBLE,
                    f.blocks, f.maxblocks, f.USER_BLOCKS, f.INCREMENT_BY,
                    'ONLINE' ONLINE_STATUS, t.BLOCK_SIZE, t.status tstatus, nvl(sum(fs.blocks),0) free_blocks, t.contents
                    from dba_data_files f, dba_tablespaces t, dba_free_space fs
                    where f.tablespace_name = t.tablespace_name
                    and f.file_id = fs.file_id(+)
                    group by f.file_name, f.tablespace_name, f.status, f.autoextensible,
                    f.blocks, f.maxblocks, f.user_blocks, f.increment_by, 'ONLINE',
                    t.block_size, t.status, t.contents
                    UNION
                    select f.file_name, f.tablespace_name, 'ONLINE' status, f.AUTOEXTENSIBLE,
                    f.blocks, f.maxblocks, f.USER_BLOCKS, f.INCREMENT_BY, 'TEMP',
                    t.BLOCK_SIZE, 'TEMP' status, sum(sh.blocks_free) free_blocks, 'TEMPORARY'
                    from v\$thread th, dba_temp_files f, dba_tablespaces t, v\$temp_space_header sh
                    WHERE f.tablespace_name = t.tablespace_name and f.file_id = sh.file_id
                    GROUP BY th.instance, f.file_name, f.tablespace_name, 'ONLINE',
                    f.autoextensible, f.blocks, f.maxblocks, f.user_blocks, f.increment_by,
                    'TEMP', t.block_size, t.status);"
    fi
}

sql_dataguard_stats() {
    if [ "$NUMERIC_ORACLE_VERSION" -ge 102 ]; then
        echo 'PROMPT <<<oracle_dataguard_stats:sep(124)>>>'
        echo "SELECT upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                     ||'|'|| upper(d.DB_UNIQUE_NAME)
                     ||'|'|| d.DATABASE_ROLE
                     ||'|'|| ds.name
                     ||'|'|| ds.value
                     ||'|'|| d.SWITCHOVER_STATUS
                     ||'|'|| d.DATAGUARD_BROKER
                     ||'|'|| d.PROTECTION_MODE
                     ||'|'|| d.FS_FAILOVER_STATUS
                     ||'|'|| d.FS_FAILOVER_OBSERVER_PRESENT
                     ||'|'|| d.FS_FAILOVER_OBSERVER_HOST
                     ||'|'|| d.FS_FAILOVER_CURRENT_TARGET
                     ||'|'|| ms.status
                     ||'|'|| d.open_mode
              FROM  v\$database d
              JOIN  v\$parameter vp on 1=1
              JOIN v\$instance i on 1=1
              left outer join V\$dataguard_stats ds on 1=1
              left outer join v\$managed_standby ms on ms.process = 'MRP0'
              WHERE vp.name = 'log_archive_config'
              AND   vp.value is not null
              ORDER BY 1;"
    fi
}

sql_recovery_status() {
    echo 'PROMPT <<<oracle_recovery_status:sep(124)>>>'
    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then
        echo "SELECT upper(decode(${IGNORE_DB_NAME:-0}
                                 , 0, decode(vp.con_id, null, d.NAME
                                            ,d.NAME||'.'||vp.name)
                                 , i.instance_name))
                     ||'|'|| d.DB_UNIQUE_NAME
                     ||'|'|| d.DATABASE_ROLE
                     ||'|'|| d.open_mode
                     ||'|'|| dh.file#
                     ||'|'|| round((dh.CHECKPOINT_TIME-to_date('01.01.1970','dd.mm.yyyy'))*24*60*60)
                     ||'|'|| round((sysdate-dh.CHECKPOINT_TIME)*24*60*60)
                     ||'|'|| dh.STATUS
                     ||'|'|| dh.RECOVER
                     ||'|'|| dh.FUZZY
                     ||'|'|| dh.CHECKPOINT_CHANGE#
                     ||'|'|| nvl(vb.STATUS, 'unknown')
                     ||'|'|| nvl2(vb.TIME, round((sysdate-vb.TIME)*24*60*60), 0)
              FROM  V\$datafile_header dh
              JOIN v\$database d on 1=1
              JOIN v\$instance i on 1=1
              LEFT OUTER JOIN v\$backup vb on vb.file# = dh.file#
              LEFT OUTER JOIN V\$PDBS vp on dh.con_id = vp.con_id
              ORDER BY dh.file#;"
    elif [ "$NUMERIC_ORACLE_VERSION" -ge 101 ]; then
        echo "SELECT upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                     ||'|'|| d.DB_UNIQUE_NAME
                     ||'|'|| d.DATABASE_ROLE
                     ||'|'|| d.open_mode
                     ||'|'|| dh.file#
                     ||'|'|| round((dh.CHECKPOINT_TIME-to_date('01.01.1970','dd.mm.yyyy'))*24*60*60)
                     ||'|'|| round((sysdate-dh.CHECKPOINT_TIME)*24*60*60)
                     ||'|'|| dh.STATUS
                     ||'|'|| dh.RECOVER
                     ||'|'|| dh.FUZZY
                     ||'|'|| dh.CHECKPOINT_CHANGE#
              FROM  V\$datafile_header dh, v\$database d, v\$instance i
              ORDER BY dh.file#;
             "
    elif [ "$NUMERIC_ORACLE_VERSION" -ge 92 ]; then
        echo "SELECT upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                     ||'|'|| upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                     ||'|'|| d.DATABASE_ROLE
                     ||'|'|| d.open_mode
                     ||'|'|| dh.file#
                     ||'|'|| round((dh.CHECKPOINT_TIME-to_date('01.01.1970','dd.mm.yyyy'))*24*60*60)
                     ||'|'|| round((sysdate-dh.CHECKPOINT_TIME)*24*60*60)
                     ||'|'|| dh.STATUS
                     ||'|'|| dh.RECOVER
                     ||'|'|| dh.FUZZY
                     ||'|'|| dh.CHECKPOINT_CHANGE#
              FROM  V\$datafile_header dh, v\$database d, v\$instance i
              ORDER BY dh.file#;
             "
    fi
}

sql_rman() {
    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then

        local archive_target="'PRIMARY'"
        if [ "$NUMERIC_ORACLE_VERSION" -ge 122 ]; then
            archive_target="'PRIMARY', 'LOCAL'"
        fi

        echo 'PROMPT <<<oracle_rman:sep(124)>>>'
        echo "select /*$HINT_RMAN check_mk rman1 */ upper(name)
                     || '|'|| 'COMPLETED'
                     || '|'|| to_char(COMPLETION_TIME, 'YYYY-mm-dd_HH24:MI:SS')
                     || '|'|| to_char(COMPLETION_TIME, 'YYYY-mm-dd_HH24:MI:SS')
                     || '|'|| case when INCREMENTAL_LEVEL IS NULL
                              then 'DB_FULL'
                              else 'DB_INCR'
                              end
                     || '|'|| INCREMENTAL_LEVEL
                     || '|'|| round(((sysdate-COMPLETION_TIME) * 24 * 60), 0)
                     || '|'|| INCREMENTAL_CHANGE#
                from (select upper(decode(${IGNORE_DB_NAME:-0}, 0, vd.NAME, i.instance_name)) name
                           , bd2.INCREMENTAL_LEVEL, bd2.INCREMENTAL_CHANGE#, min(bd2.COMPLETION_TIME) COMPLETION_TIME
                      from (select bd.file#, bd.INCREMENTAL_LEVEL, max(bd.COMPLETION_TIME) COMPLETION_TIME
                            from v\$backup_datafile bd
                            join v\$datafile_header dh on dh.file# = bd.file#
                            where dh.status = 'ONLINE'
                              and dh.con_id <> 2
                            group by bd.file#, bd.INCREMENTAL_LEVEL
                                           ) bd
                     join v\$backup_datafile bd2 on bd2.file# = bd.file#
                                               and bd2.COMPLETION_TIME = bd.COMPLETION_TIME
                     join v\$database vd on vd.RESETLOGS_CHANGE# = bd2.RESETLOGS_CHANGE#
                     join v\$instance i on 1=1
                     group by upper(decode(${IGNORE_DB_NAME:-0}, 0, vd.NAME, i.instance_name))
                            , bd2.INCREMENTAL_LEVEL
                            , bd2.INCREMENTAL_CHANGE#
                     order by name, bd2.INCREMENTAL_LEVEL);

              select /*$HINT_RMAN check_mk rman2 */ name
                    || '|' || 'COMPLETED'
                    || '|'
                    || '|' || to_char(CHECKPOINT_TIME, 'yyyy-mm-dd_hh24:mi:ss')
                    || '|' || 'CONTROLFILE'
                    || '|'
                    || '|' || round((sysdate - CHECKPOINT_TIME) * 24 * 60)
                    || '|' || '0'
              from (select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name)) name
                          ,max(bcd.CHECKPOINT_TIME) CHECKPOINT_TIME
                    from v\$database d
                    join V\$BACKUP_CONTROLFILE_DETAILS bcd on d.RESETLOGS_CHANGE# = bcd.RESETLOGS_CHANGE#
                    join v\$instance i on 1=1
                    group by upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                   );

              select /*$HINT_RMAN check_mk rman3 */ name
                     || '|COMPLETED'
                     || '|'|| to_char(sysdate, 'YYYY-mm-dd_HH24:MI:SS')
                     || '|'|| to_char(completed, 'YYYY-mm-dd_HH24:MI:SS')
                     || '|ARCHIVELOG||'
                     || round((sysdate - completed)*24*60,0)
                     || '|'
              from (
                    select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name)) name
                         , max(a.completion_time) completed
                         , case when a.backup_count > 0 then 1 else 0 end
                    from v\$archived_log a, v\$database d, v\$instance i
                    where a.backup_count > 0
                          and a.dest_id in
                          (select b.dest_id
                           from v\$archive_dest b
                           where b.target IN (${archive_target})
                             and b.SCHEDULE = 'ACTIVE'
                          )
                    group by d.NAME, i.instance_name
                           , case when a.backup_count > 0 then 1 else 0 end);"

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 102 ]; then
        echo 'PROMPT <<<oracle_rman:sep(124)>>>'
        echo "select /*${HINT_RMAN} check_mk rman1 */ upper(name)
                     || '|'|| 'COMPLETED'
                     || '|'|| to_char(COMPLETION_TIME, 'YYYY-mm-dd_HH24:MI:SS')
                     || '|'|| to_char(COMPLETION_TIME, 'YYYY-mm-dd_HH24:MI:SS')
                     || '|'|| case when INCREMENTAL_LEVEL IS NULL
                              then 'DB_FULL'
                              else 'DB_INCR'
                              end
                     || '|'|| INCREMENTAL_LEVEL
                     || '|'|| round(((sysdate-COMPLETION_TIME) * 24 * 60), 0)
                     || '|'|| INCREMENTAL_CHANGE#
                from (select upper(decode(${IGNORE_DB_NAME:-0}, 0, vd.NAME, i.instance_name)) name
                           , bd2.INCREMENTAL_LEVEL, bd2.INCREMENTAL_CHANGE#, min(bd2.COMPLETION_TIME) COMPLETION_TIME
                      from (select bd.file#, bd.INCREMENTAL_LEVEL, max(bd.COMPLETION_TIME) COMPLETION_TIME
                            from v\$backup_datafile bd
                            join v\$datafile_header dh on dh.file# = bd.file#
                            where dh.status = 'ONLINE'
                            group by bd.file#, bd.INCREMENTAL_LEVEL
                                           ) bd
                     join v\$backup_datafile bd2 on bd2.file# = bd.file#
                                               and bd2.COMPLETION_TIME = bd.COMPLETION_TIME
                     join v\$database vd on vd.RESETLOGS_CHANGE# = bd2.RESETLOGS_CHANGE#
                     join v\$instance i on 1=1
                     group by upper(decode(${IGNORE_DB_NAME:-0}, 0, vd.NAME, i.instance_name))
                            , bd2.INCREMENTAL_LEVEL
                            , bd2.INCREMENTAL_CHANGE#
                     order by name, bd2.INCREMENTAL_LEVEL);

              select /*${HINT_RMAN} check_mk rman2 */ name
                    || '|' || 'COMPLETED'
                    || '|'
                    || '|' || to_char(CHECKPOINT_TIME, 'yyyy-mm-dd_hh24:mi:ss')
                    || '|' || 'CONTROLFILE'
                    || '|'
                    || '|' || round((sysdate - CHECKPOINT_TIME) * 24 * 60)
                    || '|' || '0'
              from (select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name)) name
                          ,max(bcd.CHECKPOINT_TIME) CHECKPOINT_TIME
                    from v\$database d
                    join V\$BACKUP_CONTROLFILE_DETAILS bcd on d.RESETLOGS_CHANGE# = bcd.RESETLOGS_CHANGE#
                    join v\$instance i on 1=1
                    group by upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                   );

              select /*${HINT_RMAN} check_mk rman3 */ name
                     || '|COMPLETED'
                     || '|'|| to_char(sysdate, 'YYYY-mm-dd_HH24:MI:SS')
                     || '|'|| to_char(completed, 'YYYY-mm-dd_HH24:MI:SS')
                     || '|ARCHIVELOG||'
                     || round((sysdate - completed)*24*60,0)
                     || '|'
              from (
                    select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name)) name
                         , max(a.completion_time) completed
                         , case when a.backup_count > 0 then 1 else 0 end
                    from v\$archived_log a, v\$database d, v\$instance i
                    where a.backup_count > 0
                          and a.dest_id in
                          (select b.dest_id
                           from v\$archive_dest b
                           where b.target = 'PRIMARY'
                             and b.SCHEDULE = 'ACTIVE'
                          )
                    group by d.NAME, i.instance_name
                           , case when a.backup_count > 0 then 1 else 0 end);"
    fi
}

sql_recovery_area() {
    if [ "$NUMERIC_ORACLE_VERSION" -ge 102 ]; then
        echo 'PROMPT <<<oracle_recovery_area:sep(124)>>>'
        echo "select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                     ||'|'|| round((SPACE_USED-SPACE_RECLAIMABLE)/
                               (CASE NVL(SPACE_LIMIT,1) WHEN 0 THEN 1 ELSE SPACE_LIMIT END)*100)
                     ||'|'|| round(SPACE_LIMIT/1024/1024)
                     ||'|'|| round(SPACE_USED/1024/1024)
                     ||'|'|| round(SPACE_RECLAIMABLE/1024/1024)
                     ||'|'|| d.FLASHBACK_ON
              from V\$RECOVERY_FILE_DEST, v\$database d, v\$instance i;"
    fi
}

sql_undostat() {
    echo 'PROMPT <<<oracle_undostat:sep(124)>>>'
    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then
        echo "select decode(vp.con_id, null, upper(i.INSTANCE_NAME)
                           ,upper(i.INSTANCE_NAME || '.' || vp.name))
                     ||'|'|| ACTIVEBLKS
                     ||'|'|| MAXCONCURRENCY
                     ||'|'|| TUNED_UNDORETENTION
                     ||'|'|| maxquerylen
                     ||'|'|| NOSPACEERRCNT
              from v\$instance i
              join
                  (select * from v\$undostat
                    where TUNED_UNDORETENTION > 0
                   order by end_time desc
                   fetch next 1 rows only
                  ) u on 1=1
              left outer join v\$pdbs vp on vp.con_id = u.con_id;
             "

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 102 ]; then
        echo "select upper(i.INSTANCE_NAME)
                     ||'|'|| ACTIVEBLKS
                     ||'|'|| MAXCONCURRENCY
                     ||'|'|| TUNED_UNDORETENTION
                     ||'|'|| maxquerylen
                     ||'|'|| NOSPACEERRCNT
              from v\$instance i,
                  (select * from (select *
                                  from v\$undostat order by end_time desc
                                 )
                            where rownum = 1
                              and TUNED_UNDORETENTION > 0
                  );"

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 92 ]; then
        # TUNED_UNDORETENTION and ACTIVEBLKS are not availibe in Oracle <=9.2!
        # we sent a -1 for filtering in check_undostat
        echo "select upper(i.INSTANCE_NAME)
                     ||'|-1'
                     ||'|'|| MAXCONCURRENCY
                     ||'|-1'
                     ||'|'|| maxquerylen
                     ||'|'|| NOSPACEERRCNT
                  from v\$instance i,
                  (select * from (select *
                                  from v\$undostat order by end_time desc
                                 )
                            where rownum = 1
                  );"
    fi
}

sql_resumable() {

    echo 'PROMPT <<<oracle_resumable:sep(124)>>>'
    echo "SET SERVEROUTPUT ON feedback off
              DECLARE
                  type x is table of varchar2(20000) index by pls_integer;
                  xx x;
              begin
                  begin
                      execute immediate 'select upper(i.INSTANCE_NAME)
                         ||''|''|| u.username
                         ||''|''|| a.SESSION_ID
                         ||''|''|| a.status
                         ||''|''|| a.TIMEOUT
                         ||''|''|| round((sysdate-to_date(a.SUSPEND_TIME,''mm/dd/yy hh24:mi:ss''))*24*60*60)
                         ||''|''|| a.ERROR_NUMBER
                         ||''|''|| to_char(to_date(a.SUSPEND_TIME, ''mm/dd/yy hh24:mi:ss''),''mm/dd/yy_hh24:mi:ss'')
                         ||''|''|| a.RESUME_TIME
                         ||''|''|| a.ERROR_MSG
                  from dba_resumable a, v\$instance i, dba_users u
                  where a.INSTANCE_ID = i.INSTANCE_NUMBER
                  and u.user_id = a.user_id
                  and a.SUSPEND_TIME is not null
                  union all
                  select upper(i.INSTANCE_NAME)
                         || ''|||||||||''
                  from v\$instance i'
                      bulk collect into xx;
                      if xx.count >= 1 then
                          for i in 1 .. xx.count loop
                              dbms_output.put_line(xx(i));
                          end loop;
                      end if;
                  exception
                      when others then
                          for cur1 in (select upper(i.instance_name) instance_name from  v\$instance i) loop
                              dbms_output.put_line(cur1.instance_name || '| Debug: '||sqlerrm);
                          end loop;
                  end;
              END;
              /
              set serverout off"
}

sql_jobs() {

    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then

        echo 'PROMPT <<<oracle_jobs:sep(124)>>>'
        echo "SET SERVEROUTPUT ON feedback off
              DECLARE
                  type x is table of varchar2(20000) index by pls_integer;
                  xx x;
              begin
                  begin
                      execute immediate 'SELECT upper(vp.name)
                     ||''|''|| j.OWNER
                     ||''|''|| j.JOB_NAME
                     ||''|''|| j.STATE
                     ||''|''|| ROUND((TRUNC(sysdate) + j.LAST_RUN_DURATION - TRUNC(sysdate)) * 86400)
                     ||''|''|| j.RUN_COUNT
                     ||''|''|| j.ENABLED
                     ||''|''|| NVL(j.NEXT_RUN_DATE, to_date(''1970-01-01'', ''YYYY-mm-dd''))
                     ||''|''|| NVL(j.SCHEDULE_NAME, ''-'')
                     ||''|''|| jd.STATUS
              FROM cdb_scheduler_jobs j
              JOIN ( SELECT vp.con_id
                           ,d.name || ''|'' || vp.name name
                       FROM v\$containers vp
                       JOIN v\$database d on 1=1
                      WHERE d.cdb = ''YES'' and vp.con_id <> 2
                        AND d.database_role = ''PRIMARY''
                        AND d.open_mode = ''READ WRITE''
                    UNION ALL
                     SELECT 0, name
                       FROM v\$database d
                      WHERE d.database_role = ''PRIMARY''
                        AND d.open_mode = ''READ WRITE''
               ) vp on j.con_id = vp.con_id
                           left outer join (SELECT con_id, owner, job_name, max(LOG_ID) log_id
                                  FROM cdb_scheduler_job_run_details dd
                                 group by con_id, owner, job_name
                               ) jm on  jm.JOB_NAME = j.JOB_NAME
                                   and jm.owner=j.OWNER
                                   and jm.con_id = j.con_id
              left outer join cdb_scheduler_job_run_details jd
                              on  jd.con_id = jm.con_id
                              AND jd.owner = jm.OWNER
                              AND jd.JOB_NAME = jm.JOB_NAME
                              AND jd.LOG_ID = jm.LOG_ID
              WHERE not (j.auto_drop = ''TRUE'' and REPEAT_INTERVAL is null)'
                      bulk collect into xx;
                      if xx.count >= 1 then
                          for i in 1 .. xx.count loop
                              dbms_output.put_line(xx(i));
                          end loop;
                      end if;
                  exception
                      when others then
                          for cur1 in (select upper(name) name from  v\$database) loop
                              dbms_output.put_line(cur1.name || '| Debug (121): ' ||sqlerrm);
                          end loop;
                  end;
              END;
              /
              set serverout off"

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 102 ]; then

        echo 'PROMPT <<<oracle_jobs:sep(124)>>>'
        echo "SET SERVEROUTPUT ON feedback off
              DECLARE
                  type x is table of varchar2(20000) index by pls_integer;
                  xx x;
              begin
                  begin
                      execute immediate 'SELECT upper(decode(${IGNORE_DB_NAME:-0}, 0, vd.NAME, i.instance_name))
                     ||''|''|| j.OWNER
                     ||''|''|| j.JOB_NAME
                     ||''|''|| j.STATE
                     ||''|''|| ROUND((TRUNC(sysdate) + j.LAST_RUN_DURATION - TRUNC(sysdate)) * 86400)
                     ||''|''|| j.RUN_COUNT
                     ||''|''|| j.ENABLED
                     ||''|''|| NVL(j.NEXT_RUN_DATE, to_date(''1970-01-01'', ''YYYY-mm-dd''))
                     ||''|''|| NVL(j.SCHEDULE_NAME, ''-'')
                     ||''|''|| jd.STATUS
              FROM dba_scheduler_jobs j
              join v\$database vd on 1 = 1
              join v\$instance i on 1 = 1
              left outer join (SELECT owner, job_name, max(LOG_ID) log_id
                                        FROM dba_scheduler_job_run_details dd
                                        group by owner, job_name
                              ) jm on  jm.JOB_NAME = j.JOB_NAME
                                   and jm.owner=j.OWNER
              left outer join dba_scheduler_job_run_details jd
                              on  jd.owner = jm.OWNER
                              AND jd.JOB_NAME = jm.JOB_NAME
                              AND jd.LOG_ID = jm.LOG_ID
              WHERE vd.database_role = ''PRIMARY''
                AND vd.open_mode = ''READ WRITE''
                AND not (j.auto_drop = ''TRUE'' and REPEAT_INTERVAL is null)'
                      bulk collect into xx;
                      if xx.count >= 1 then
                          for i in 1 .. xx.count loop
                              dbms_output.put_line(xx(i));
                          end loop;
                      end if;
                  exception
                      when others then
                          for cur1 in (select upper(name) name from  v\$database) loop
                              dbms_output.put_line(cur1.name || '| Debug (102): ' ||sqlerrm);
                          end loop;
                  end;
              END;
              /
              set serverout off"

    fi
}

sql_ts_quotas() {
    echo 'PROMPT <<<oracle_ts_quotas:sep(124)>>>'
    echo "select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                 ||'|'|| Q.USERNAME
                 ||'|'|| Q.TABLESPACE_NAME
                 ||'|'|| Q.BYTES
                 ||'|'|| Q.MAX_BYTES
          from dba_ts_quotas Q, v\$database d, v\$instance i
          where max_bytes > 0
          union all
          select upper(decode(${IGNORE_DB_NAME:-0}, 0, d.NAME, i.instance_name))
                 ||'|||'
          from v\$database d, v\$instance i
          order by 1;"
}

sql_version() {
    echo 'PROMPT <<<oracle_version>>>'
    echo "select upper(i.INSTANCE_NAME)
         || ' ' || banner
         from v\$version, v\$instance i
         where banner like 'Oracle%';"
}

sql_systemparameter() {
    # TODO In the future, all data needed for HW/SW inventory, should
    # implement a "persist:$UNTIL" to reduce amount of data transmission
    echo "PROMPT <<<oracle_systemparameter:sep(124)>>>"
    echo "select upper(i.instance_name)
         || '|' || NAME
         || '|' || DISPLAY_VALUE
         || '|' || ISDEFAULT
         from v\$system_parameter, v\$instance i
         where name not like '!_%' ESCAPE '!';"
}

sql_instance() {
    echo 'prompt <<<oracle_instance:sep(124)>>>'

    if [ "$NUMERIC_ORACLE_VERSION" -ge 180 ]; then
        # Oracle 18c introduced another version column with Release Update information
        # version       version_full
        # 18.0.0.0.0    18.5.0.0.0
        # 19.0.0.0.0    19.5.0.0.0
        local version_column="version_full"
    else
        local version_column="version"
    fi

    if [ "${ORACLE_SID:0:1}" = '+' ]; then
        # ASM
        echo "select upper(i.instance_name)
                     || '|' || i.${version_column}
                     || '|' || i.STATUS
                     || '|' || i.LOGINS
                     || '|' || i.ARCHIVER
                     || '|' || round((sysdate - i.startup_time) * 24*60*60)
                     || '|' || '0'
                     || '|' || 'NO'
                     || '|' || 'ASM'
                     || '|' || 'NO'
                     || '|' || i.instance_name
                from v\$instance i;"

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then
        echo "select upper(instance_name)
                         || '|' || version
                         || '|' || status
                         || '|' || logins
                         || '|' || archiver
                         || '|' || round((sysdate - startup_time) * 24*60*60)
                         || '|' || dbid
                         || '|' || log_mode
                         || '|' || database_role
                         || '|' || force_logging
                         || '|' || name
                         || '|' || to_char(created, 'ddmmyyyyhh24mi')
                         || '|' || upper(value)
                         || '|' || con_id
                         || '|' || pname
                         || '|' || pdbid
                         || '|' || popen_mode
                         || '|' || prestricted
                         || '|' || ptotal_time
                         || '|' || precovery_status
                         || '|' || round(nvl(popen_time, -1))
                         || '|' || pblock_size
                  from(
                      select i.instance_name, i.${version_column} version, i.status, i.logins, i.archiver
                            ,i.startup_time, d.dbid, d.log_mode, d.database_role, d.force_logging
                            ,d.name, d.created, p.value, vp.con_id, vp.name pname
                            ,vp.dbid pdbid, vp.open_mode popen_mode, vp.restricted prestricted, vp.total_size ptotal_time
                            ,vp.block_size pblock_size, vp.recovery_status precovery_status
                            ,(cast(systimestamp as date) - cast(open_time as date))  * 24*60*60 popen_time
                        from v\$instance i
                        join v\$database d on 1=1
                        join v\$parameter p on 1=1
                        join v\$pdbs vp on 1=1
                        where p.name = 'enable_pluggable_database'
                      union all
                      select
                             i.instance_name, i.${version_column} version, i.status, i.logins, i.archiver
                            ,i.startup_time, d.dbid, d.log_mode, d.database_role, d.force_logging
                            ,d.name, d.created, p.value, 0 con_id, null pname
                            ,0 pdbis, null popen_mode, null prestricted, null ptotal_time
                            ,0 pblock_size, null precovery_status, null popen_time
                        from v\$instance i
                        join v\$database d on 1=1
                        join v\$parameter p on 1=1
                        where p.name = 'enable_pluggable_database'
                        order by con_id
                      );
             "
    else
        # normal Instance
        echo "select upper(i.instance_name)
                     || '|' || i.VERSION
                     || '|' || i.STATUS
                     || '|' || i.LOGINS
                     || '|' || i.ARCHIVER
                     || '|' || round((sysdate - i.startup_time) * 24*60*60)
                     || '|' || DBID
                     || '|' || LOG_MODE
                     || '|' || DATABASE_ROLE
                     || '|' || FORCE_LOGGING
                     || '|' || d.name
                     || '|' || to_char(d.created, 'ddmmyyyyhh24mi')
                from v\$instance i, v\$database d;"
    fi
}

sql_sessions() {
    echo 'prompt <<<oracle_sessions:sep(124)>>>'

    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then
        echo "SELECT upper(vp.name)
                     || '|' || ltrim(COUNT(1))
                     || decode(vp.con_id
                               , 0, '|'||ltrim(rtrim(LIMIT_VALUE))||'|-1')
              FROM ( SELECT vp.con_id
                         ,i.instance_name || '.' || vp.name name
                     FROM v\$containers vp
                     JOIN v\$instance i ON 1 = 1
                     JOIN v\$database d on 1=1
                     WHERE d.cdb = 'YES' and vp.con_id <> 2
                    UNION ALL
                     SELECT 0, instance_name
                     FROM v\$instance
                   ) vp
              JOIN v\$resource_limit rl on RESOURCE_NAME = 'sessions'
              LEFT OUTER JOIN v\$session vs ON vp.con_id = vs.con_id
              GROUP BY vp.name, vp.con_id, rl.LIMIT_VALUE
              ORDER BY 1;"

    else
        echo "select upper(i.instance_name)
                     || '|' || CURRENT_UTILIZATION
                     || '|' || ltrim(LIMIT_VALUE)
                     || '|' || MAX_UTILIZATION
              from v\$resource_limit, v\$instance i
              where RESOURCE_NAME = 'sessions';"
    fi
}

sql_processes() {
    echo 'prompt <<<oracle_processes:sep(124)>>>'
    echo "select upper(i.instance_name)
                  || '|' || CURRENT_UTILIZATION
                  || '|' || ltrim(rtrim(LIMIT_VALUE))
           from v\$resource_limit, v\$instance i
           where RESOURCE_NAME = 'processes';"
}

sql_logswitches() {
    echo 'prompt <<<oracle_logswitches:sep(124)>>>'
    echo "select upper(i.instance_name)
                  || '|' || logswitches
           from v\$instance i ,
                (select count(1) logswitches
                 from v\$loghist h , v\$instance i
                 where h.first_time > sysdate - 1/24
                 and h.thread# = i.instance_number
                );"
}

sql_locks() {
    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then
        echo 'prompt <<<oracle_locks:sep(124)>>>'
        echo "select upper(vp.name)
                     || '|' || b.sid
                     || '|' || b.serial#
                     || '|' || b.machine
                     || '|' || b.program
                     || '|' || b.process
                     || '|' || b.osuser
                     || '|' || b.username
                     || '|' || b.SECONDS_IN_WAIT
                     || '|' || b.BLOCKING_SESSION_STATUS
                     || '|' || bs.inst_id
                     || '|' || bs.sid
                     || '|' || bs.serial#
                     || '|' || bs.machine
                     || '|' || bs.program
                     || '|' || bs.process
                     || '|' || bs.osuser
                     || '|' || bs.username
              from v\$session b
              join gv\$session bs on bs.inst_id = b.BLOCKING_INSTANCE
                                 and bs.sid = b.BLOCKING_SESSION
                                 and bs.con_id = b.con_id
              join ( SELECT vp.con_id
                           ,i.instance_name || '.' || vp.name name
                 FROM v\$containers vp
                 JOIN v\$instance i ON 1 = 1
                 JOIN v\$database d on 1=1
                 WHERE d.cdb = 'YES' and vp.con_id <> 2
                UNION ALL
                 SELECT 0, instance_name
                 FROM v\$instance
               ) vp on b.con_id = vp.con_id
              where b.BLOCKING_SESSION is not null;

              SELECT upper(i.instance_name || '.' || vp.name)
                     || '|||||||||||||||||'
                FROM v\$containers vp
                JOIN v\$instance i ON 1 = 1
                 JOIN v\$database d on 1=1
                WHERE d.cdb = 'YES' and vp.con_id <> 2
               UNION ALL
                SELECT upper(i.instance_name)
                     || '|||||||||||||||||'
                FROM v\$instance i;
        "

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 102 ]; then
        echo 'prompt <<<oracle_locks:sep(124)>>>'
        echo "select upper(i.instance_name)
                     || '|' || b.sid
                     || '|' || b.serial#
                     || '|' || b.machine
                     || '|' || b.program
                     || '|' || b.process
                     || '|' || b.osuser
                     || '|' || b.username
                     || '|' || b.SECONDS_IN_WAIT
                     || '|' || b.BLOCKING_SESSION_STATUS
                     || '|' || bs.inst_id
                     || '|' || bs.sid
                     || '|' || bs.serial#
                     || '|' || bs.machine
                     || '|' || bs.program
                     || '|' || bs.process
                     || '|' || bs.osuser
                     || '|' || bs.username
              from v\$session b
              join v\$instance i on 1=1
              join gv\$session bs on bs.inst_id = b.BLOCKING_INSTANCE
                                 and bs.sid = b.BLOCKING_SESSION
              where b.BLOCKING_SESSION is not null;
              select upper(i.instance_name)
                     || '|||||||||||||||||'
              from v\$instance i;"
    fi
}

sql_locks_old() {
    if [ "$NUMERIC_ORACLE_VERSION" -ge 101 ]; then
        echo 'prompt <<<oracle_locks:sep(124)>>>'
        echo "SET SERVEROUTPUT ON feedback off
              DECLARE
                  type x is table of varchar2(20000) index by pls_integer;
                  xx x;
              begin
                  begin
                      execute immediate 'select upper(i.instance_name)
                         || ''|'' || a.sid
                         || ''|'' || b.serial#
                         || ''|'' || b.machine
                         || ''|'' || b.program
                         || ''|'' || b.process
                         || ''|'' || b.osuser
                         || ''|'' || a.ctime
                         || ''|'' || decode(c.owner,NULL,''NULL'',c.owner)
                         || ''|'' || decode(c.object_name,NULL,''NULL'',c.object_name)
                          from V\$LOCK a, v\$session b, dba_objects c, v\$instance i
                          where (a.id1, a.id2, a.type)
                                     IN (SELECT id1, id2, type
                                         FROM GV\$LOCK
                                         WHERE request>0
                                        )
                          and request=0
                          and a.sid = b.sid
                          and a.id1 = c.object_id (+)
                          union all
                          select upper(i.instance_name) || ''|||||||||''
                          from  v\$instance i'
                      bulk collect into xx;
                      if xx.count >= 1 then
                          for i in 1 .. xx.count loop
                              dbms_output.put_line(xx(i));
                          end loop;
                      end if;
                  exception
                      when others then
                          for cur1 in (select upper(i.instance_name) instance_name from  v\$instance i) loop
                              dbms_output.put_line(cur1.instance_name || '| Debug (101): '||sqlerrm);
                          end loop;
                  end;
              END;
              /
              set serverout off"
    fi
}

sql_longactivesessions() {
    if [ "$NUMERIC_ORACLE_VERSION" -ge 121 ]; then

        echo 'prompt <<<oracle_longactivesessions:sep(124)>>>'
        echo "select upper(vp.name)
                     || '|' || s.sid
                     || '|' || s.serial#
                     || '|' || s.machine
                     || '|' || s.process
                     || '|' || s.osuser
                     || '|' || s.program
                     || '|' || s.last_call_et
                     || '|' || s.sql_id
              from v\$session s
              join ( SELECT vp.con_id
                           ,i.instance_name || '.' || vp.name name
                 FROM v\$containers vp
                 JOIN v\$instance i ON 1 = 1
                 JOIN v\$database d on 1=1
                 WHERE d.cdb = 'YES' and vp.con_id <> 2
                UNION ALL
                 SELECT 0, instance_name
                 FROM v\$instance
                   ) vp on 1=1
              where s.status = 'ACTIVE'
                and s.type != 'BACKGROUND'
                and s.username is not null
                and s.username not in('PUBLIC')
                and s.last_call_et > 60*60;

              SELECT upper(i.instance_name || '.' || vp.name)
                     || '||||||||'
                FROM v\$containers vp
                JOIN v\$instance i ON 1 = 1
                JOIN v\$database d on 1=1
               WHERE d.cdb = 'YES' and vp.con_id <> 2
               UNION ALL
              SELECT upper(i.instance_name)
                     || '||||||||'
                FROM v\$instance i;
             "

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 101 ]; then
        echo 'prompt <<<oracle_longactivesessions:sep(124)>>>'
        echo "select upper(i.instance_name)
                     || '|' || s.sid
                     || '|' || s.serial#
                     || '|' || s.machine
                     || '|' || s.process
                     || '|' || s.osuser
                     || '|' || s.program
                     || '|' || s.last_call_et
                     || '|' || s.sql_id
              from v\$session s, v\$instance i
              where s.status = 'ACTIVE'
              and type != 'BACKGROUND'
              and s.username is not null
              and s.username not in('PUBLIC')
              and s.last_call_et > 60*60
              union all
              select upper(i.instance_name)
                     || '||||||||'
              from v\$instance i;"
    fi
}

sql_asm_diskgroup() {
    echo 'prompt <<<oracle_asm_diskgroup:sep(124)>>>'
    if [ "$NUMERIC_ORACLE_VERSION" -ge 112 ]; then

        echo "SELECT g.state
           || '|' || g.type
           || '|' || g.name
           || '|' || g.BLOCK_SIZE
           || '|' || g.ALLOCATION_UNIT_SIZE
           || '|' || g.REQUIRED_MIRROR_FREE_MB
           || '|' || sum(d.total_mb)
           || '|' || sum(d.free_mb)
           || '|' || d.failgroup
           || '|' || max(d.VOTING_FILE)
           || '|' || d.FAILGROUP_TYPE
           || '|' || g.offline_disks
           || '|' || min(decode(d.REPAIR_TIMER, 0, 8640000, d.REPAIR_TIMER))
           || '|' || count(*)
      FROM v\$asm_diskgroup g
      LEFT OUTER JOIN v\$asm_disk d on d.group_number = g.group_number
                                   and d.group_number = g.group_number
                                   and d.group_number <> 0
      GROUP BY g.name
             , g.state
             , g.type
             , d.failgroup
             , d.VOTING_FILE
             , g.BLOCK_SIZE
             , g.ALLOCATION_UNIT_SIZE
             , g.REQUIRED_MIRROR_FREE_MB
             , g.offline_disks
             , d.FAILGROUP_TYPE
             , d.REPAIR_TIMER
      ORDER BY g.name, d.failgroup;"

    elif [ "$NUMERIC_ORACLE_VERSION" -ge 102 ]; then
        echo "select STATE
                     || '|' || TYPE
                     || '|' || 'N'
                     || '|' || sector_size
                     || '|' || block_size
                     || '|' || allocation_unit_size
                     || '|' || total_mb
                     || '|' || free_mb
                     || '|' || required_mirror_free_mb
                     || '|' || usable_file_mb
                     || '|' || offline_disks
                     || '|' || 'N'
                     || '|' || name || '/'
                from v\$asm_diskgroup;"
    fi
}

#.
#   .--custom SQL----------------------------------------------------------.
#   |                       _                    ____   ___  _             |
#   |         ___ _   _ ___| |_ ___  _ __ ___   / ___| / _ \| |            |
#   |        / __| | | / __| __/ _ \| '_ ` _ \  \___ \| | | | |            |
#   |       | (__| |_| \__ \ || (_) | | | | | |  ___) | |_| | |___         |
#   |        \___|\__,_|___/\__\___/|_| |_| |_| |____/ \__\_\_____|        |
#   |                                                                      |
#   '----------------------------------------------------------------------'

unset_custom_sqls_vars() {
    unset SQLS_SECTION_NAME SQLS_SECTION_SEP SQLS_SIDS SQLS_DIR SQLS_SQL SQLS_PARAMETERS SQLS_MAX_CACHE_AGE SQLS_ITEM_NAME MK_CUSTOM_SQLS_SECTION MK_CUSTOM_SQLS_SECTION_HEADER MK_CUSTOM_SQLS_ITEM MK_CUSTOM_SQLS_SECTION_QUERY
    unset SQLS_DBUSER SQLS_DBPASSWORD SQLS_DBSYSCONNECT SQLS_TNSALIAS SQLS_ITEM_SID
}

do_custom_sqls() {
    for section in $custom_sqls_sections; do
        if ! type "$section" >/dev/null 2>&1; then
            logging -w "[${MK_SID}] [custom_sql] [${section}]" \
                "Definition of '${section}' not found in configuration"
            continue
        fi

        $section

        local sids=${SQLS_SIDS:-$custom_sqls_sids}
        sids=${sids//,/ }

        # If SID is not part of sids we can skip the rest
        if ! echo "$sids" | "${GREP}" -q "$MK_SID"; then
            logging -w "[${MK_SID}] [custom_sql] [${section}]" \
                "Skipping this section, runs only on SIDs '$sids'"
            unset_custom_sqls_vars
            continue
        fi

        local section_name=${SQLS_SECTION_NAME:-$custom_sqls_section_name}
        local sql_dir=${SQLS_DIR:-$custom_sqls_dir}
        local sql=${SQLS_SQL:-$custom_sqls_sql}

        # If no section name, SQL dir or file is stated or SQL file does not exist we skip the rest
        if [ -z "$section_name" ]; then
            logging -w "[${MK_SID}] [custom_sql] [${section}]" \
                "Empty section name"
            unset_custom_sqls_vars
            continue
        fi

        if [ ! -d "$sql_dir" ] || [ ! -r "$sql_dir" ]; then
            logging -w "[${MK_SID}] [custom_sql] [${section}]" \
                "SQL folder '${sql_dir}' not found or not readable"
            unset_custom_sqls_vars
            continue
        fi

        if [ ! -f "${sql_dir}/$sql" ] || [ ! -r "${sql_dir}/$sql" ]; then
            logging -w "[${MK_SID}] [custom_sql] [${section}]" \
                "SQL file '${sql_dir}/$sql' not found or not readable"
            unset_custom_sqls_vars
            continue
        fi

        if [ -n "$SQLS_SECTION_SEP" ]; then
            local section_sep="$SQLS_SECTION_SEP"
        elif [ -n "$custom_sqls_section_sep" ]; then
            local section_sep="$custom_sqls_section_sep"
        else
            local section_sep=
        fi

        if [ "$section_name" == "oracle_sql" ]; then
            local section_header="${section_name}:sep(58)"
        elif [ -n "${section_sep}" ]; then
            local section_header="${section_name}:sep(${section_sep})"
        else
            local section_header="$section_name"
        fi

        if [ "$section_name" = "oracle_sql" ]; then
            if [[ "$MK_SID" =~ ^REMOTE_INSTANCE_.* ]]; then
                if [ -z "$SQLS_ITEM_SID" ]; then
                    # we can not extract MK_SID from REMOTE_INSTANCE_ variable name
                    # get MK_SID from mk_oracle.cfg when SQLS_ITEM_SID is not defined
                    # => needed when tnsnames.ora is used without SID in CFGLINE...
                    local SQLS_ITEM_SID
                    SQLS_ITEM_SID=$(eval "echo \${$MK_SID}" | cut -d":" -f7)
                fi
            else
                # local connection mode
                local SQLS_ITEM_SID="$MK_SID"
            fi
            logging "[${MK_SID}] [custom_sql] [${section}]" \
                "SQLS_ITEM_SID: $SQLS_ITEM_SID"

            if [ -n "$SQLS_ITEM_NAME" ]; then
                local item="${SQLS_ITEM_SID}|${SQLS_ITEM_NAME}"
            else
                local item="${SQLS_ITEM_SID}|${sql}"
            fi
        else
            local item=
        fi

        local parameters=${SQLS_PARAMETERS:-$custom_sqls_parameters}

        if $MK_DEBUG_MODE; then
            local max_cache_age=
        elif [ -n "$SQLS_MAX_CACHE_AGE" ]; then
            local max_cache_age="$SQLS_MAX_CACHE_AGE"
        else
            local max_cache_age="$custom_sqls_max_cache_age"
        fi

        if [ -n "$SQLS_DBUSER" ]; then
            # set custom credentials from section
            db_connect=$(mk_ora_db_connect "$MK_SID")
            export MK_DB_CONNECT=$db_connect
        fi

        unset_custom_sqls_vars

        MK_CUSTOM_SQLS_SECTION="$section"
        export MK_CUSTOM_SQLS_SECTION_HEADER="$section_header"
        export MK_CUSTOM_SQLS_ITEM="$item"
        MK_CUSTOM_SQLS_SECTION_QUERY=$(custom_sql_section "$sql_dir" "$sql" "$parameters")
        export MK_CUSTOM_SQLS_SECTION_QUERY

        logging "[${MK_SID}] [custom_sql] [${section}]" \
            "Section name   : $MK_CUSTOM_SQLS_SECTION" \
            "Section header : $MK_CUSTOM_SQLS_SECTION_HEADER" \
            "Section item   : $MK_CUSTOM_SQLS_ITEM" \
            "Max cache age  : $max_cache_age" \
            "Custom query   : $MK_CUSTOM_SQLS_SECTION_QUERY"

        if $MK_ORA_DEBUG_CONNECT; then
            do_testmode_custom_sql
        else
            if [ -z "$max_cache_age" ]; then
                local output=
                output=$(echo -e "$MK_CUSTOM_SQLS_SECTION_QUERY" | mk_ora_sqlplus "do_custom_sqls" "yes")
                handle_custom_sql_errors "$output"
            else
                run_cached "$max_cache_age" do_async_custom_sqls "_custom_sql_${MK_CUSTOM_SQLS_SECTION}"
            fi
        fi
    done
}

custom_sql_section() {
    local sql_dir="$1"
    local sql="$2"
    local params="$3"
    local sql_content=

    echo "PROMPT <<<${MK_CUSTOM_SQLS_SECTION_HEADER}>>>"
    if [ -n "$MK_CUSTOM_SQLS_ITEM" ]; then
        echo "PROMPT [[[${MK_CUSTOM_SQLS_ITEM}]]]"
    fi

    echo -e "SET VERIFY OFF;"
    echo -e "SET TERMOUT ON;"
    echo -e "SET serveroutput ON;"

    if [ -n "$params" ]; then
        echo -e "$params"
    fi

    sql_content=$(cat "$sql_dir/$sql")
    echo -e "$sql_content"
}

do_async_custom_sqls() {
    local output=
    output=$(echo -e "$MK_CUSTOM_SQLS_SECTION_QUERY" | mk_ora_sqlplus "do_async_custom_sqls" "yes")
    logging "[${MK_SID}] [${MK_CUSTOM_SQLS_SECTION_QUERY}] [do_async_custom_sql]" "Output: $output"
    handle_custom_sql_errors "$output"
}

handle_custom_sql_errors() {
    local output="$1"
    local errors=
    errors=$(echo -e "$output" | ${GREP} -e "ERROR at line" -e "ORA-" -e "SP2-" | tr '\n' ' ')
    if [ -n "$errors" ]; then
        echo "<<<${MK_CUSTOM_SQLS_SECTION_HEADER}>>>"
        if [ -n "$MK_CUSTOM_SQLS_ITEM" ]; then
            echo "[[[${MK_CUSTOM_SQLS_ITEM}]]]"
        fi
        # connection error already returns '$SID|FAILURE|' in mk_ora_sqplplus
        errors=${errors#*FAILURE|}
        echo "$(echo "$MK_SID" | tr '[:lower:]' '[:upper:]')|FAILURE|$errors"
    else
        echo "$output"
    fi
}

#.
#   .--helper--------------------------------------------------------------.
#   |                    _          _                                      |
#   |                   | |__   ___| |_ __   ___ _ __                      |
#   |                   | '_ \ / _ \ | '_ \ / _ \ '__|                     |
#   |                   | | | |  __/ | |_) |  __/ |                        |
#   |                   |_| |_|\___|_| .__/ \___|_|                        |
#   |                                |_|                                   |
#   '----------------------------------------------------------------------'

print_dummy_sections() {
    for section in $SYNC_SECTIONS $ASYNC_SECTIONS $SYNC_ASM_SECTIONS $ASYNC_ASM_SECTIONS; do
        echo "<<<oracle_${section}>>>"
    done
}

do_dummy_sections() {
    if [ -n "$MK_ORA_SECTIONS" ]; then
        return
    fi

    print_dummy_sections

    for piggyback_host in $PIGGYBACK_HOSTS; do
        echo "<<<<${piggyback_host}>>>>"
        print_dummy_sections
        echo "<<<<>>>>"
    done
}

skip_sid() {
    local sid="$1"
    if [ "$ONLY_SIDS" ]; then
        if echo "$ONLY_SIDS" | "${GREP}" -q "$sid"; then
            echo "no"
            return
        fi
        echo "yes"
        return
    fi

    if [ "$SKIP_SIDS" ]; then
        if echo "$SKIP_SIDS" | "${GREP}" -q "$sid"; then
            echo "yes"
            return
        fi
        echo "no"
        return
    fi

    EXCLUDE=EXCLUDE_$sid
    # Handle explicit exclusion of instances but not for +ASM
    if [[ "$EXCLUDE" =~ ^[a-zA-Z][a-zA-Z0-9_]*$ ]]; then
        EXCLUDE=${!EXCLUDE}
        if [ "$EXCLUDE" = "ALL" ]; then
            echo "yes"
            return
        fi
        echo "no"
        return
    fi
    echo "no"
}

remove_excluded_sections() {
    # We exclude instance section because we have already executed
    # the sql_instance section at the beginning for every SID.
    local sections="$1"
    local excluded="$2"
    for section in $sections; do
        if [[ "$excluded" != *"$section"* ]]; then
            echo "$section"
        fi
    done
}

ora_session_environment() {
    echo 'set pages 0 trimspool on feedback off lines 8000'
    if [ "$NUMERIC_ORACLE_VERSION" -ge 102 ] && [ ! "$DISABLE_ORA_SESSION_SETTINGS" ]; then
        echo 'set echo off'
        echo 'alter session set "_optimizer_mjc_enabled"=false;'

        # cursor_sharing is not valid for ASM instances
        if [ ! "${ORACLE_SID:0:1}" = '+' ]; then
            echo 'alter session set cursor_sharing=exact;'
        fi

        echo 'set echo on'
    fi
    #TODO Do not exit after first error otherwise
    # section specific errors won't be seen any more.
    #echo 'whenever sqlerror exit 1'
    echo ' '
}

#.
#   .--run cached----------------------------------------------------------.
#   |                                           _              _           |
#   |         _ __ _   _ _ __     ___ __ _  ___| |__   ___  __| |          |
#   |        | '__| | | | '_ \   / __/ _` |/ __| '_ \ / _ \/ _` |          |
#   |        | |  | |_| | | | | | (_| (_| | (__| | | |  __/ (_| |          |
#   |        |_|   \__,_|_| |_|  \___\__,_|\___|_| |_|\___|\__,_|          |
#   |                                                                      |
#   '----------------------------------------------------------------------'

run_cached() {
    if $MK_DEBUG_MODE; then
        # Just to be sure
        return
    fi

    local maxage="$1"
    local cmd_name="$2"

    local cache_file="$MK_VARDIR/cache/oracle_${MK_SID}${3}.cache"
    local use_cache_file=
    local now=
    local cf_atime=
    local mtime=

    if [ ! -d "$MK_VARDIR/cache" ]; then
        mkdir -p "$MK_VARDIR/cache"
    fi

    # Check if the creation of the cache takes suspiciously long and return
    # nothing if the age (access time) of $cache_file.new is twice the 'maxage'
    # perl is needed for Solaris => no date +%s availible
    now=$(perl -le "print time()")
    if [ -e "${cache_file}.new" ]; then
        cf_atime=$(mk_ora_atime "${cache_file}.new")
        if [ $((now - cf_atime)) -ge $((maxage * 2)) ]; then
            # Kill the process still accessing that file in case
            # it is still running. This avoids overlapping processes!
            if ! $MK_ORA_LOGGING; then
                fuser -k -9 "${cache_file}.new" >/dev/null 2>&1
                rm -f "${cache_file}.new"
            fi
            return
        fi
    fi

    # Check if cache file exists and is recent enough
    if [ -s "$cache_file" ]; then
        mtime=$(mk_ora_mtime "$cache_file")
        if [ $((now - mtime)) -le "$maxage" ]; then
            use_cache_file=1
        fi
        # Output the file in any case, even if it is
        # outdated. The new file will not yet be available
        sed "s/^<<<\\(.*\\)>>>$/<<<\\1:cached(${mtime},${maxage})>>>/g" "$cache_file"
    fi

    # Cache file outdated and new job not yet running? Start it
    if [ -z "$use_cache_file" ] && [ ! -e "${cache_file}.new" ]; then
        if $MK_ORA_DEBUG; then
            echo "set -o noclobber; exec > \"${cache_file}.new\" || exit 1; ${cmd_name} && mv \"${cache_file}.new\" \"${cache_file}\" || rm -f \"${cache_file}\" \"${cache_file}.new\"" | /bin/bash
        else
            # When the command fails, the output is throws away ignored
            echo "set -o noclobber; exec > \"${cache_file}.new\" || exit 1; ${cmd_name} && mv \"${cache_file}.new\" \"${cache_file}\" || rm -f \"${cache_file}\" \"${cache_file}.new\"" | nohup /bin/bash >/dev/null 2>&1 &
        fi
    fi
}

#.
#   .--DB connect----------------------------------------------------------.
#   |          ____  ____                                    _             |
#   |         |  _ \| __ )    ___ ___  _ __  _ __   ___  ___| |_           |
#   |         | | | |  _ \   / __/ _ \| '_ \| '_ \ / _ \/ __| __|          |
#   |         | |_| | |_) | | (_| (_) | | | | | | |  __/ (__| |_           |
#   |         |____/|____/   \___\___/|_| |_|_| |_|\___|\___|\__|          |
#   |                                                                      |
#   '----------------------------------------------------------------------'

mk_ora_db_connect() {
    local sid="$1"
    local CFGTNSALIAS=""

    ORADBUSER=""
    DBPASSWORD=""
    offset=${offset:-0}

    if [[ "$sid" =~ ^REMOTE_INSTANCE_.* ]]; then
        # working on REMOTE_-Mode!
        ORACFGLINE=$(eval "echo \${$1}")
        ORACLE_SID=$(echo "${ORACFGLINE}" | cut -d":" -f7)
        CFGTNSALIAS=$(echo "${ORACFGLINE}" | cut -d":" -f9)

    else
        # working with locally running instances
        # mk_oracle_dbusers.conf is for compatibility. Do not use it anymore
        ORACLE_USERCONF=${MK_CONFDIR}/mk_oracle_dbuser.conf
        TNSALIAS=${ORACLE_SID}

        # ASM use '+' as 1st character in SID!
        if [ "${ORACLE_SID:0:1}" = '+' ]; then
            ORACFGLINE=${ASMUSER}

        else
            # use an individuel user or the default DBUSER from mk_oracle.cfg
            # It's possible that the config file uses only upper case, but
            # the fetched SID is lower case. And vice versa. To handle this, we
            # need to try both cases.
            # Important: This does not cover config variables that uses both
            # upper and lower case letters. We simply cannot handle that!
            #
            # Disabling shellcheck because false-positive warning regarding
            # single quotes. AWK needs these single quotes to work as inteded.
            # shellcheck disable=SC2016
            dummy_upper="DBUSER_$(echo "$ORACLE_SID" | "$AWK" '{ print toupper($0) }')"
            # shellcheck disable=SC2016
            dummy_lower="DBUSER_$(echo "$ORACLE_SID" | "$AWK" '{ print tolower($0) }')"
            if [ "${!dummy_upper}" = '' ]; then
                if [ "${!dummy_lower}" = '' ]; then
                    ORACFGLINE=${DBUSER}
                else
                    ORACFGLINE=${!dummy_lower}
                fi
            else
                ORACFGLINE=${!dummy_upper}
            fi
        fi

        if [ -f "${ORACLE_USERCONF}" ] && [ "${ORACFGLINE}" = '' ]; then
            # mk_oracle_dbuser.conf
            ORACFGLINE=$("${GREP}" "^${ORACLE_SID}:" <"${ORACLE_USERCONF}")
            # mk_oracle_dbuser has ORACLE_SID as 1. parameter. we need an offset for all values
            offset=1
        fi

        CFGTNSALIAS=$(echo "${ORACFGLINE}" | cut -d":" -f$((6 + offset)))
    fi

    if [ -n "$SQLS_DBUSER" ]; then
        ORADBUSER=${SQLS_DBUSER}
        DBPASSWORD=${SQLS_DBPASSWORD}
        DBSYSCONNECT=${SQLS_DBSYSCONNECT:-}
    else
        ORADBUSER=$(echo "${ORACFGLINE}" | cut -d":" -f$((1 + offset)))
        DBPASSWORD=$(echo "${ORACFGLINE}" | cut -d":" -f$((2 + offset)))
        DBSYSCONNECT=$(echo "${ORACFGLINE}" | cut -d":" -f$((3 + offset)))
    fi
    DBHOST=$(echo "${ORACFGLINE}" | cut -d":" -f$((4 + offset)))
    DBPORT=$(echo "${ORACFGLINE}" | cut -d":" -f$((5 + offset)))

    if [ -f $OLRLOC ] && [ -n "$crs_home" ]; then
        if [ -d "$crs_home" ]; then
            # we found GI/Restart
            # => Use hostname instead of localhost
            DBHOST=${DBHOST:-$(hostname)}
            logging "[${sid}] [mk_ora_db_connect]" "OLR detected. crs_home: $crs_home"
        else
            DBHOST=${DBHOST:-"localhost"}
            logging "[${sid}] [mk_ora_db_connect]" "OLR detected, crs_home missing"
        fi
    else
        DBHOST=${DBHOST:-"localhost"}
        logging "[${sid}] [mk_ora_db_connect]" "Single Instance"
    fi

    if [ -n "$CFGTNSALIAS" ]; then
        logging "[${sid}] [mk_ora_db_connect]" "TNS CFGTNSALIAS: $CFGTNSALIAS"
    fi

    TNSPINGOK=no
    if [ -f "${TNS_ADMIN}/tnsnames.ora" ]; then
        if [ "${ORADBUSER:0:2}" = '/@' ]; then
            P_TNSALIAS_P=$(eval echo "${ORADBUSER:2}")
        else
            # use TNSALIAS from ORACFGLINE or ORACLE_SID when empty
            P_TNSALIAS_P=${CFGTNSALIAS:-${ORACLE_SID}}
        fi

        # PREFIX / POSTFIX makes no sense for ASM
        # => only 1 Instance with known connection possible
        if [ -n "$P_TNSALIAS_P" ] && [ ! "${ORACLE_SID:0:1}" = '+' ]; then
            PREFIX_SID="PREFIX_$sid"
            PREFIX_SID=${!PREFIX_SID}
            if [ -n "$PREFIX_SID" ]; then
                P_TNSALIAS_P="$PREFIX_SID$P_TNSALIAS_P"
            elif [ -n "$PREFIX" ]; then
                P_TNSALIAS_P="$PREFIX$P_TNSALIAS_P"
            else
                P_TNSALIAS_P="$P_TNSALIAS_P"
            fi

            POSTFIX_SID="POSTFIX_$sid"
            POSTFIX_SID=${!POSTFIX_SID}
            if [ -n "$POSTFIX_SID" ]; then
                P_TNSALIAS_P="$P_TNSALIAS_P$POSTFIX_SID"
            elif [ -n "$POSTFIX" ]; then
                P_TNSALIAS_P="$P_TNSALIAS_P$POSTFIX"
            else
                P_TNSALIAS_P="$P_TNSALIAS_P"
            fi
        fi

        TNSALIAS=${SQLS_TNSALIAS:-${P_TNSALIAS_P}}

        logging "[${sid}] [mk_ora_db_connect]" "TNS Alias PING: $TNSALIAS"

        if "${ORACLE_HOME}"/bin/tnsping "$TNSALIAS" >/dev/null 2>&1; then
            TNSPINGOK=yes
        else
            unset TNSALIAS
        fi
    else
        if [ -z "$CFGTNSALIAS" ]; then
            unset TNSALIAS
        else
            TNSALIAS=${SQLS_TNSALIAS:-${CFGTNSALIAS}}
        fi
    fi

    logging "[${sid}] [mk_ora_db_connect]" \
        "ORA DB user    : $ORADBUSER" \
        "DB sys connect : $DBSYSCONNECT" \
        "DB host        : $DBHOST" \
        "DB port        : $DBPORT" \
        "TNS alias      : $TNSALIAS" \
        "TNS PING       : ${TNSPINGOK}"

    if [ ! "${ORACFGLINE}" ]; then
        # no configuration found
        # => use the wallet with tnsnames.ora or EZCONNECT
        TNSALIAS=${TNSALIAS:-"localhost:1521/${ORACLE_SID}"}
    else
        if [ "${DBSYSCONNECT}" ]; then
            assysdbaconnect=" as "${DBSYSCONNECT}
        fi

        TNSALIAS=${TNSALIAS:-"(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=${DBHOST})(PORT=${DBPORT:-1521}))(CONNECT_DATA=(SID=${ORACLE_SID})(SERVER=DEDICATED)(UR=A)))"}

        # ORADBUSER = '/'? => ignore DBPASSWORD and use the wallet
        if [ "${ORADBUSER:0:1}" = '/' ]; then
            # connect with / and wallet
            ORADBUSER=""
            DBPASSWORD=""
            if [ -z "$CFGTNSALIAS" ] && [ "$TNSPINGOK" = 'no' ]; then
                # create an EZCONNECT string when no tnsnames.ora is usable
                # or no alias is configured in CFGTNSALIAS
                # defaults to localhost:1521/<ORACLE_SID>
                TNSALIAS="${DBHOST}:${DBPORT:-1521}/${ORACLE_SID}"
            fi
        fi
    fi

    logging "[${sid}] [mk_ora_db_connect]" "DB connection: ${ORADBUSER}/${DBPASSWORD//?/*}@${TNSALIAS}${assysdbaconnect}"
    echo "${ORADBUSER}/${DBPASSWORD}@${TNSALIAS}${assysdbaconnect}"

}

#.
#   .--mk ora sqlplus------------------------------------------------------.
#   |            _                                  _       _              |
#   |  _ __ ___ | | __   ___  _ __ __ _   ___  __ _| |_ __ | |_   _ ___    |
#   | | '_ ` _ \| |/ /  / _ \| '__/ _` | / __|/ _` | | '_ \| | | | / __|   |
#   | | | | | | |   <  | (_) | | | (_| | \__ \ (_| | | |_) | | |_| \__ \   |
#   | |_| |_| |_|_|\_\  \___/|_|  \__,_| |___/\__, |_| .__/|_|\__,_|___/   |
#   |                                            |_| |_|                   |
#   '----------------------------------------------------------------------'

mk_ora_sqlplus() {
    local from_where="$1"
    local print_elapsed_time="$2"
    local start_time=
    local elapsed_time=
    local loc_stdin=
    local output=

    logging "[${MK_SID}] [${from_where}] [mk_ora_sqlplus]" "Piggyback host: $MK_PIGGYBACK_HOST"

    start_time="$(perl -MTime::HiRes=time -wle 'print time')"
    loc_stdin=$(cat)

    SQLPLUS=${ORACLE_HOME}/bin/sqlplus
    if [ ! -x "${SQLPLUS}" ]; then
        logging -w -e "[${MK_SID}] [${from_where}] [mk_ora_sqlplus]" "SQLplus '${SQLPLUS}' not found or ORACLE_HOME '${ORACLE_HOME}' wrong."
        return 1
    fi

    if [ -n "$MK_PIGGYBACK_HOST" ]; then
        echo "<<<<${MK_PIGGYBACK_HOST}>>>>"
    fi

    if output=$(echo "$(ora_session_environment)${loc_stdin}" | "$SQLPLUS" -L -s "$MK_DB_CONNECT"); then
        echo -e "$output"

        elapsed_time=$(bc <<<"$(perl -MTime::HiRes=time -wle 'print time')-$start_time")

        if [ "$print_elapsed_time" = "yes" ]; then
            echo "elapsed:$elapsed_time"
        fi

        logging "[${MK_SID}] [${from_where}] [mk_ora_sqlplus]" "Elapsed time: $elapsed_time"

    else
        output=$(
            echo -e "$output" | "${GREP}" -v "^ERROR at line" | tr '\n' ' ' |
                sed "s/^/$(echo "$MK_SID" | tr '[:lower:]' '[:upper:]')|FAILURE|/"
            echo
        )

        logging -w "[${MK_SID}] [${from_where}] [mk_ora_sqlplus]" "Found '^ERROR at line'"

        if $MK_ORA_DEBUG_CONNECT; then
            echo "    Logindetails:           ${MK_DB_CONNECT}" >&2
            echo -e "    Error Message:          ${output:0:100}"
        else
            echo '<<<oracle_instance:sep(124)>>>'
            echo -e "$output"
            echo
        fi
    fi

    if [ -n "$MK_PIGGYBACK_HOST" ]; then
        echo "<<<<>>>>"
    fi
}

#.
#   .--do checks-----------------------------------------------------------.
#   |                 _              _               _                     |
#   |              __| | ___     ___| |__   ___  ___| | _____              |
#   |             / _` |/ _ \   / __| '_ \ / _ \/ __| |/ / __|             |
#   |            | (_| | (_) | | (__| | | |  __/ (__|   <\__ \             |
#   |             \__,_|\___/   \___|_| |_|\___|\___|_|\_\___/             |
#   |                                                                      |
#   '----------------------------------------------------------------------'

# Create one SQL statements for several sections and run
# these with sqlplus. The exitcode is preserved.
do_sync_checks() {
    logging "[${MK_SID}] [do_sync_checks]" "Query: $MK_SYNC_SECTIONS_QUERY"
    echo "$MK_SYNC_SECTIONS_QUERY" | mk_ora_sqlplus "do_sync_checks"
}

do_async_checks() {
    logging "[${MK_SID}] [do_async_checks]" "Query: $MK_ASYNC_SECTIONS_QUERY"
    echo "$MK_ASYNC_SECTIONS_QUERY" | mk_ora_sqlplus "do_async_checks"
}

do_testmode() {
    local sections=$1
    local asections=$2

    echo
    echo "---login----------------------------------------------------------------"
    echo "    Operating System:       ${OS_TYPE}"
    echo "    ORACLE_HOME ${ORA_HOME_SOURCE}   ${ORACLE_HOME}"
    echo "    Logincheck to Instance: ${MK_SID}"
    echo "    Version:                ${ORACLE_VERSION}"
    echo "select '    Login ok User:          ' || user || ' on ' || host_name ||' Instance ' || instance_name
          from v\$instance;" | mk_ora_sqlplus "do_testmode"
    echo "    SYNC_SECTIONS:          $sections"
    echo "    ASYNC_SECTIONS:         $asections"
    if [ "$IGNORE_DB_NAME" ]; then
        echo "    IGNORE_DB_NAME found. Ignoring DB_NAME in all SQLs!"
    fi

    if [ "$DISABLE_ORA_SESSION_SETTINGS" ]; then
        echo "    Paramter DISABLE_ORA_SESSION_SETTINGS found!"
    fi

    if [ "$HINT_RMAN" ]; then
        echo "    Using HINT_RMAN for this Instance!"
    fi
    echo "------------------------------------------------------------------------"
    echo
}

do_testmode_custom_sql() {
    echo "---custom SQL ----------------------------------------------------------"
    echo "    section:                ${section}"
    echo "    SQL:                    ${sql}"
    echo "    MAX_CACHE_AGE:          ${max_cache_age}"
    echo "------------------------------------------------------------------------"
}

fetch_custom_section_variable() {
    local section_name=$1
    local section_var=
    local section_dummy=
    local sid_upper=
    local sid_lower=
    # Disabling shellcheck because false-positive warning regarding
    # single quotes. AWK needs these single quotes to work as inteded.
    # shellcheck disable=SC2016
    sid_upper=$(echo "$ORACLE_SID" | "$AWK" '{ print toupper($0) }')
    # shellcheck disable=SC2016
    sid_lower=$(echo "$ORACLE_SID" | "$AWK" '{ print tolower($0) }')

    if declare -p "$1_${sid_upper}" >/dev/null 2>&1; then
        section_dummy="$1_${sid_upper}"
        section_var=${!section_dummy}
    else
        if declare -p "$1_${sid_lower}" >/dev/null 2>&1; then
            section_dummy="$1_${sid_lower}"
            section_var=${!section_dummy}
        else
            section_var="${!section_name}"
        fi
    fi

    echo "$section_var"
}

do_checks() {
    local sections=
    local asections=

    if [ "${ORACLE_SID:0:1}" = '+' ]; then
        # ASM sections
        local sections=${SYNC_ASM_SECTIONS}
        local asections=${ASYNC_ASM_SECTIONS}
    else
        local SYNC_SECTIONS_SID=
        local ASYNC_SECTIONS_SID=
        local do_sync_sections=
        local do_async_sections=

        SYNC_SECTIONS_SID=$(fetch_custom_section_variable "SYNC_SECTIONS")
        ASYNC_SECTIONS_SID=$(fetch_custom_section_variable "ASYNC_SECTIONS")

        if [ "$SYNC_SECTIONS_SID" ] && [ "$MK_ORA_SECTIONS" ]; then
            do_sync_sections=$(for section in $SYNC_SECTIONS_SID; do
                if [[ "$MK_ORA_SECTIONS" == *"$section"* ]]; then
                    echo "$section"
                fi
            done)
        else
            do_sync_sections=${SYNC_SECTIONS_SID:-${SYNC_SECTIONS}}
        fi

        if [ "$ASYNC_SECTIONS_SID" ] && [ "$MK_ORA_SECTIONS" ]; then
            do_async_sections=$(for section in $ASYNC_SECTIONS_SID; do
                if [[ "$MK_ORA_SECTIONS" == *"$section"* ]]; then
                    echo "$section"
                fi
            done)
        else
            do_async_sections=${ASYNC_SECTIONS_SID:-${ASYNC_SECTIONS}}
        fi

        local excluded=
        excluded=$(eval "echo \$EXCLUDE_$ORACLE_SID")
        if [ "$excluded" ]; then
            sections=$(remove_excluded_sections "$do_sync_sections" "$excluded")
            asections=$(remove_excluded_sections "$do_async_sections" "$excluded")
        else
            sections="$do_sync_sections"
            asections="$do_async_sections"
        fi
    fi

    logging "[${ORACLE_SID}] [do_checks]" "Excluded: $excluded" \
        "Sections: $sections" "Async sections: $asections"

    if $MK_ORA_DEBUG_CONNECT; then
        do_testmode "$sections" "$asections"
        return
    fi

    if $MK_DEBUG_MODE; then
        MK_SYNC_SECTIONS_QUERY=$(for section in $sections $asections; do eval "sql_$section"; done)
        MK_ASYNC_SECTIONS_QUERY=
    else
        MK_SYNC_SECTIONS_QUERY=$(for section in $sections; do eval "sql_$section"; done)
        MK_ASYNC_SECTIONS_QUERY=$(for section in $asections; do eval "sql_$section"; done)
    fi

    export MK_ASYNC_SECTIONS_QUERY

    if [ "$MK_SYNC_SECTIONS_QUERY" ]; then
        do_sync_checks
    fi

    if [ "$MK_ASYNC_SECTIONS_QUERY" ]; then
        run_cached "$CACHE_MAXAGE" do_async_checks
    fi
}

#.
#   .--main----------------------------------------------------------------.
#   |                                       _                              |
#   |                       _ __ ___   __ _(_)_ __                         |
#   |                      | '_ ` _ \ / _` | | '_ \                        |
#   |                      | | | | | | (_| | | | | |                       |
#   |                      |_| |_| |_|\__,_|_|_| |_|                       |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |  Iterate over all instances and execute sync and async sections.     |
#   '----------------------------------------------------------------------'

# Make sure that the new shell that is being run by run_cached inherits
# our functions
export -f logging
export -f mk_ora_sqlplus
export -f ora_session_environment
export -f do_async_checks
export -f set_ora_env
export -f unset_custom_sqls_vars
export -f custom_sql_section
export -f do_async_custom_sqls
export -f handle_custom_sql_errors

if $MK_ORA_LOGGING; then
    # cleanup old leftovers
    rm -f "${MK_VARDIR}"/log/mk_oracle_task_*.log
    echo "Logging to file: ${MK_VARDIR}/log/mk_oracle.log" >&2
fi

logging "--------------------------------------------------------------------"

#   ---preliminaries--------------------------------------------------------
set_os_env

# Get list of all running databases. Do not work on ASM in this plugin.
# => Ignore a running ASM-Instance!
# shellcheck disable=SC2016
SIDS=$(UNIX95=true ps -ef | "${AWK}" '{print $NF}' |
    "${GREP}" -E '^asm_pmon_|^ora_pmon_|^xe_pmon_' |
    cut -d"_" -f3- | sort)

# Load config AFTER we got the SIDS since we allow users to use this variable in their config
load_config

# Are there any remote configurations?
for remote_instance in $(compgen -A variable | "${GREP}" -E "^REMOTE_INSTANCE_.*"); do
    REMOTE_INSTANCES="${REMOTE_INSTANCES} ${remote_instance}"
    # shellcheck disable=SC2005
    PIGGYBACK_HOSTS="$(echo "$(eval "echo \${$remote_instance}")" | cut -d":" -f6) ${PIGGYBACK_HOSTS}"
done

PIGGYBACK_HOSTS="$(echo "$PIGGYBACK_HOSTS" | tr ' ' '\n' | sort | uniq)"

logging "[preliminaries]" \
    "SIDs               : ${SIDS//$'\n'/ }" \
    "Remote instances   : ${REMOTE_INSTANCES}" \
    "Piggyback hosts    : ${PIGGYBACK_HOSTS//$'\n'/ }" \
    "OS                 : ${OS_TYPE}" \
    "SYNC_SECTIONS      : ${SYNC_SECTIONS}" \
    "ASYNC_SECTIONS     : ${ASYNC_SECTIONS}" \
    "SYNC_ASM_SECTIONS  : ${SYNC_ASM_SECTIONS}" \
    "ASYNC_ASM_SECTIONS : ${ASYNC_ASM_SECTIONS}" \
    "CACHE_MAXAGE       : ${CACHE_MAXAGE}" \
    "ONLY_SIDS          : ${ONLY_SIDS}" \
    "SKIP_SIDS          : ${SKIP_SIDS}"

if [ "$PIGGYBACK_HOSTS" ]; then
    if [ ! -e "$MK_VARDIR/mk_oracle.found" ]; then
        touch "$MK_VARDIR/mk_oracle.found"
    fi
fi

# If we do not have found any running database instance, then either
# no ORACLE is present on this system or it's just currently not running.
# In the later case we ouput empty agent sections so that Checkmk will be
# happy and execute the actual check functions.
if [ -z "$SIDS" ] && [ ! -e "$MK_VARDIR/mk_oracle.found" ]; then
    logging -c -e "[preliminaries]" "No SIDs and \$MK_VARDIR/mk_oracle.found not found"
    exit 1
fi

# From now on we expect databases on this system (for ever)
touch "$MK_VARDIR/mk_oracle.found"

# Make sure that always all sections are present, even
# in case of an error. Note: the section <<<oracle_instance>>>
# section shows the general state of a database instance. If
# that section fails for an instance then all other sections
# do not contain valid data anyway.
do_dummy_sections

#   ---local----------------------------------------------------------------

execute_queries_for_sid() {
    local sid="$1"
    set_ora_env "$sid"
    if [ $? -eq 2 ]; then
        # we have to skip this SID due to missing/unknown ORACLE_HOME
        return
    fi

    set_ora_version "$("${ORACLE_HOME}"/bin/sqlplus -V | "${GREP}" ^SQL | cut -d" " -f3 | cut -d"." -f-2)"
    logging "[${sid}] [local]" \
        "ORACLE_SID      : ${ORACLE_SID}" \
        "ORACLE_HOME     : ${ORACLE_HOME}" \
        "TNS_ADMIN       : ${TNS_ADMIN}" \
        "LD_LIBRARY_PATH : ${LD_LIBRARY_PATH}" \
        "ORACLE_VERSION  : ${ORACLE_VERSION} (${NUMERIC_ORACLE_VERSION})"

    # MK_SID is feauture replacement for sid
    export MK_SID=$sid
    db_connect=$(mk_ora_db_connect "$MK_SID")
    export MK_DB_CONNECT=$db_connect

    do_checks

    # MK_DB_CONNECT could be changed by do_custom_sqls!
    do_custom_sqls
}

ORA_TMPDIR="${MK_VARDIR}/tmp/mk_oracle"
mkdir -p "${ORA_TMPDIR}"

TASK_NR=0
for sid in $SIDS; do
    skip=$(skip_sid "$sid")
    if [ "$skip" == "yes" ]; then
        logging "[${sid}] [local]" "Skipping this SID"
        continue
    fi
    ((TASK_NR++))
    logging "[${sid}] [local] starting background task '${TASK_NR}'"
    (execute_queries_for_sid "$sid" >"$ORA_TMPDIR/$sid") &
    if [[ $(jobs -r -p | wc -l) -ge ${MAX_TASKS} ]]; then
        logging "[${sid}] [local] max parallel task running, waiting for new slot"
        if ((BASH_VERSINFO[0] > 4 || BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 3)); then
            wait -n
        else
            wait
        fi
    fi
done

wait
cat "$ORA_TMPDIR"/*
rm -f "$ORA_TMPDIR"/*

#   ---remote---------------------------------------------------------------

for remote_instance in $REMOTE_INSTANCES; do
    remote_instance_line=$(eval "echo \${$remote_instance}")

    set_ora_env "$remote_instance"
    set_ora_version "$(echo "$remote_instance_line" | cut -d":" -f8)"
    logging "[${remote_instance}] [remote]" \
        "ORACLE_SID      : ${ORACLE_SID}" \
        "ORACLE_HOME     : ${ORACLE_HOME}" \
        "TNS_ADMIN       : ${TNS_ADMIN}" \
        "LD_LIBRARY_PATH : ${LD_LIBRARY_PATH}" \
        "ORACLE_VERSION  : ${ORACLE_VERSION} (${NUMERIC_ORACLE_VERSION})"

    db_connect=$(mk_ora_db_connect "$remote_instance")
    piggyback_host=$(echo "${remote_instance_line}" | cut -d":" -f6)
    export MK_SID=$remote_instance
    export MK_DB_CONNECT=$db_connect
    export MK_PIGGYBACK_HOST=$piggyback_host

    do_checks
    do_custom_sqls
done

if ${MK_ORA_LOGGING}; then
    cat "${MK_VARDIR}"/log/mk_oracle_task_*.log >>"${MK_VARDIR}"/log/mk_oracle.log
    rm -f "${MK_VARDIR}"/log/mk_oracle_task_*.log
fi
