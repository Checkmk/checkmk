#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# This agent version uses predefined soap inquiries which are sent
# to an esx host system. # Unlike the classic agent the reported data
# isn't processed through the pysphere module.
# Instead a simple string process approach is used which drastically
# reduces the CPU load for this agent
"""Check_MK vSphere Special Agent"""

# pylint: disable=broad-except

import datetime
import errno
import httplib
import os
import re
import argparse
import socket
import sys
import time
from typing import Optional, Text  # pylint: disable=unused-import
from xml.dom import minidom  # type: ignore

from dateutil import tz
from pathlib2 import Path

import cmk.utils.paths
from cmk.utils.exceptions import MKGeneralException


class MKQueryServerException(Exception):
    pass


# Great article how to get additional information
# http://www.veeam.com/kb1007

telegram_list = {
       "systeminfo":
         '<ns1:RetrieveServiceContent xsi:type="ns1:RetrieveServiceContentRequestType">'\
         '<ns1:_this type="ServiceInstance">ServiceInstance</ns1:_this></ns1:RetrieveServiceContent>',

       "login":
         '<ns1:Login xsi:type="ns1:LoginRequestType"><ns1:_this type="SessionManager">%(sessionManager)s</ns1:_this>'\
         '<ns1:userName>%(username)s</ns1:userName><ns1:password>%(password)s</ns1:password></ns1:Login>',

       "systemtime":
         '<ns1:CurrentTime xsi:type="ns1:CurrentTimeRequestType">'\
         '<ns1:_this type="ServiceInstance">ServiceInstance</ns1:_this></ns1:CurrentTime>',

       "hostsystems":
         '<ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">'\
         '<ns1:_this type="PropertyCollector">%(propertyCollector)s</ns1:_this><ns1:specSet>'\
         '<ns1:propSet><ns1:type>HostSystem</ns1:type><ns1:pathSet>name</ns1:pathSet></ns1:propSet>'\
         '<ns1:objectSet><ns1:obj type="Folder">%(rootFolder)s</ns1:obj><ns1:skip>false</ns1:skip>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>visitFolders</ns1:name>'\
           '<ns1:type>Folder</ns1:type><ns1:path>childEntity</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToHf</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToVmf</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>crToH</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>crToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToDs</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>hToVm</ns1:name></ns1:selectSet>'\
         '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToVmf</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>vmFolder</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToDs</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>datastore</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToHf</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>hostFolder</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>crToH</ns1:name><ns1:type>ComputeResource</ns1:type>'\
         '<ns1:path>host</ns1:path><ns1:skip>false</ns1:skip></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>crToRp</ns1:name><ns1:type>ComputeResource</ns1:type>'\
         '<ns1:path>resourcePool</ns1:path><ns1:skip>false</ns1:skip>'\
         '<ns1:selectSet><ns1:name>rpToRp</ns1:name></ns1:selectSet>'\
         '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>rpToRp</ns1:name><ns1:type>ResourcePool</ns1:type>'\
           '<ns1:path>resourcePool</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>rpToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>hToVm</ns1:name><ns1:type>HostSystem</ns1:type>'\
           '<ns1:path>vm</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>rpToVm</ns1:name><ns1:type>ResourcePool</ns1:type>'\
         '<ns1:path>vm</ns1:path><ns1:skip>false</ns1:skip></ns1:selectSet>'\
         '</ns1:objectSet></ns1:specSet><ns1:options></ns1:options></ns1:RetrievePropertiesEx>',

     "datastores":
         '<ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">'\
         '<ns1:_this type="PropertyCollector">%(propertyCollector)s</ns1:_this><ns1:specSet>'\
         '<ns1:propSet><ns1:type>Datastore</ns1:type><ns1:pathSet>name</ns1:pathSet>'\
         '<ns1:pathSet>summary.freeSpace</ns1:pathSet>'\
         '<ns1:pathSet>summary.capacity</ns1:pathSet>'\
         '<ns1:pathSet>summary.uncommitted</ns1:pathSet>'\
         '<ns1:pathSet>summary.url</ns1:pathSet>'\
         '<ns1:pathSet>summary.accessible</ns1:pathSet>'\
         '<ns1:pathSet>summary.type</ns1:pathSet>'\
         '<ns1:pathSet>summary.maintenanceMode</ns1:pathSet></ns1:propSet>'\
         '<ns1:objectSet><ns1:obj type="Folder">%(rootFolder)s</ns1:obj><ns1:skip>false</ns1:skip>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>visitFolders</ns1:name>'\
           '<ns1:type>Folder</ns1:type><ns1:path>childEntity</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToHf</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToVmf</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>crToH</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>crToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToDs</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>hToVm</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToVmf</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>vmFolder</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToDs</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>datastore</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToHf</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>hostFolder</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>crToH</ns1:name><ns1:type>ComputeResource</ns1:type>'\
         '<ns1:path>host</ns1:path><ns1:skip>false</ns1:skip></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>crToRp</ns1:name><ns1:type>ComputeResource</ns1:type>'\
           '<ns1:path>resourcePool</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>rpToRp</ns1:name></ns1:selectSet>'\
         '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>rpToRp</ns1:name><ns1:type>ResourcePool</ns1:type>'\
           '<ns1:path>resourcePool</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>rpToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>hToVm</ns1:name><ns1:type>HostSystem</ns1:type>'\
           '<ns1:path>vm</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>rpToVm</ns1:name><ns1:type>ResourcePool</ns1:type>'\
         '<ns1:path>vm</ns1:path><ns1:skip>false</ns1:skip></ns1:selectSet>'\
         '</ns1:objectSet></ns1:specSet><ns1:options></ns1:options></ns1:RetrievePropertiesEx>',

     "licensesused": """
        <ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">
          <ns1:_this type="PropertyCollector">%(propertyCollector)s</ns1:_this>
          <ns1:specSet>
            <ns1:propSet>
              <ns1:type>LicenseManager</ns1:type>
              <all>0</all>
              <ns1:pathSet>licenses</ns1:pathSet>
            </ns1:propSet>
            <ns1:objectSet>
              <ns1:obj type="LicenseManager">%(licenseManager)s</ns1:obj>
            </ns1:objectSet>
          </ns1:specSet>
          <ns1:options/>
        </ns1:RetrievePropertiesEx>
    """,

     "perfcountersummary":
         '<ns1:QueryPerfProviderSummary xsi:type="ns1:QueryPerfProviderSummaryRequestType">'\
         '<ns1:_this type="PerformanceManager">%(perfManager)</ns1:_this>'\
         '<ns1:entity type="HostSystem">%(esxhost)s</ns1:entity></ns1:QueryPerfProviderSummary>',

     "perfcountersyntax":
         '<ns1:QueryPerfCounter xsi:type="ns1:QueryPerfCounterRequestType">'\
         '<ns1:_this type="PerformanceManager">%(perfManager)s</ns1:_this>%(counters)s</ns1:QueryPerfCounter>',

     "perfcounteravail":
         '<ns1:QueryAvailablePerfMetric xsi:type="ns1:QueryAvailablePerfMetricRequestType">'\
         '<ns1:_this type="PerformanceManager">%(perfManager)s</ns1:_this>'\
         '<ns1:entity type="HostSystem">%(esxhost)s</ns1:entity>'\
         '<ns1:intervalId>20</ns1:intervalId></ns1:QueryAvailablePerfMetric>',

     "perfcounterdata":
         '<ns1:QueryPerf xsi:type="ns1:QueryPerfRequestType"><ns1:_this type="PerformanceManager">%(perfManager)s</ns1:_this>'\
         '<ns1:querySpec><ns1:entity type="HostSystem">%(esxhost)s</ns1:entity><ns1:maxSample>%(samples)s</ns1:maxSample>%(counters)s'\
         '<ns1:intervalId>20</ns1:intervalId></ns1:querySpec></ns1:QueryPerf>',

     "networksystem":
         '<ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">'\
         '<ns1:_this type="PropertyCollector">%(propertyCollector)s</ns1:_this><ns1:specSet>'\
         '<ns1:propSet><ns1:type>HostNetworkSystem</ns1:type><all>0</all>'\
         '<ns1:pathSet>networkInfo</ns1:pathSet></ns1:propSet>'\
         '<ns1:objectSet><ns1:obj type="HostNetworkSystem">networkSystem</ns1:obj>'\
         '</ns1:objectSet></ns1:specSet><ns1:options></ns1:options></ns1:RetrievePropertiesEx>',

     "esxhostdetails":
         '<ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">'
         '<ns1:_this type="PropertyCollector">%(propertyCollector)s</ns1:_this><ns1:specSet><ns1:propSet>'\
         '<ns1:type>HostSystem</ns1:type>'\
         '<ns1:pathSet>summary.quickStats.overallMemoryUsage</ns1:pathSet>'\
         '<ns1:pathSet>hardware.cpuPkg</ns1:pathSet>'\
#         '<ns1:pathSet>hardware.pciDevice</ns1:pathSet>'\
         '<ns1:pathSet>runtime.powerState</ns1:pathSet>'\
         '<ns1:pathSet>summary.quickStats.overallCpuUsage</ns1:pathSet>'\
         '<ns1:pathSet>hardware.biosInfo.biosVersion</ns1:pathSet>'\
         '<ns1:pathSet>hardware.biosInfo.releaseDate</ns1:pathSet>'\
         '<ns1:pathSet>hardware.cpuInfo.hz</ns1:pathSet>'\
         '<ns1:pathSet>hardware.cpuInfo.numCpuThreads</ns1:pathSet>'\
         '<ns1:pathSet>hardware.cpuInfo.numCpuPackages</ns1:pathSet>'\
         '<ns1:pathSet>hardware.cpuInfo.numCpuCores</ns1:pathSet>'\
         '<ns1:pathSet>config.storageDevice.multipathInfo</ns1:pathSet>'\
         '<ns1:pathSet>hardware.systemInfo.model</ns1:pathSet>'\
         '<ns1:pathSet>hardware.systemInfo.uuid</ns1:pathSet>'\
         '<ns1:pathSet>hardware.systemInfo.otherIdentifyingInfo</ns1:pathSet>'\
         '<ns1:pathSet>hardware.systemInfo.vendor</ns1:pathSet>'\
         '<ns1:pathSet>name</ns1:pathSet>'\
         '<ns1:pathSet>overallStatus</ns1:pathSet>'\
         '<ns1:pathSet>runtime.healthSystemRuntime.systemHealthInfo.numericSensorInfo</ns1:pathSet>'\
         '<ns1:pathSet>runtime.healthSystemRuntime.hardwareStatusInfo.storageStatusInfo</ns1:pathSet>'\
         '<ns1:pathSet>runtime.healthSystemRuntime.hardwareStatusInfo.cpuStatusInfo</ns1:pathSet>'\
         '<ns1:pathSet>runtime.healthSystemRuntime.hardwareStatusInfo.memoryStatusInfo</ns1:pathSet>'\
         '<ns1:pathSet>runtime.inMaintenanceMode</ns1:pathSet>'\
         '<ns1:pathSet>hardware.memorySize</ns1:pathSet></ns1:propSet>'\
         '<ns1:objectSet><ns1:obj type="Folder">%(rootFolder)s</ns1:obj><ns1:skip>false</ns1:skip>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>visitFolders</ns1:name>'\
           '<ns1:type>Folder</ns1:type><ns1:path>childEntity</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToHf</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToVmf</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>crToH</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>crToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToDs</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>hToVm</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToVmf</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>vmFolder</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToDs</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>datastore</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToHf</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>hostFolder</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>crToH</ns1:name><ns1:type>ComputeResource</ns1:type>'\
           '<ns1:path>host</ns1:path><ns1:skip>false</ns1:skip></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>crToRp</ns1:name><ns1:type>ComputeResource</ns1:type>'\
           '<ns1:path>resourcePool</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>rpToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>rpToRp</ns1:name><ns1:type>ResourcePool</ns1:type>'\
           '<ns1:path>resourcePool</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>rpToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>hToVm</ns1:name><ns1:type>HostSystem</ns1:type>'\
           '<ns1:path>vm</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>rpToVm</ns1:name><ns1:type>ResourcePool</ns1:type>'\
           '<ns1:path>vm</ns1:path><ns1:skip>false</ns1:skip></ns1:selectSet>'\
         '</ns1:objectSet></ns1:specSet><ns1:options></ns1:options></ns1:RetrievePropertiesEx>',

     "vmdetails":
         '<ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">'\
         '<ns1:_this type="PropertyCollector">%(propertyCollector)s</ns1:_this><ns1:specSet><ns1:propSet>'\
         '<ns1:type>VirtualMachine</ns1:type>'\
           '<ns1:pathSet>summary.quickStats.consumedOverheadMemory</ns1:pathSet>'\
           '<ns1:pathSet>config.hardware.numCPU</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.overallCpuDemand</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.distributedCpuEntitlement</ns1:pathSet>'\
           '<ns1:pathSet>runtime.host</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.distributedMemoryEntitlement</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.uptimeSeconds</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.sharedMemory</ns1:pathSet>'\
           '<ns1:pathSet>config.hardware.memoryMB</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.privateMemory</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.balloonedMemory</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.staticMemoryEntitlement</ns1:pathSet>'\
           '<ns1:pathSet>runtime.powerState</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.overallCpuUsage</ns1:pathSet>'\
           '<ns1:pathSet>config.hardware.numCoresPerSocket</ns1:pathSet>'\
           '<ns1:pathSet>config.hardware.device</ns1:pathSet>'\
           '<ns1:pathSet>config.template</ns1:pathSet>'\
           '<ns1:pathSet>guest.toolsVersion</ns1:pathSet>'\
           '<ns1:pathSet>guestHeartbeatStatus</ns1:pathSet>'\
           '<ns1:pathSet>name</ns1:pathSet>'\
           '<ns1:pathSet>summary.guest.hostName</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.compressedMemory</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.swappedMemory</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.guestMemoryUsage</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.staticCpuEntitlement</ns1:pathSet>'\
           '<ns1:pathSet>summary.quickStats.hostMemoryUsage</ns1:pathSet>'\
           '<ns1:pathSet>snapshot.rootSnapshotList</ns1:pathSet>'\
           '<ns1:pathSet>config.datastoreUrl</ns1:pathSet>'\
           '<ns1:pathSet>guest.toolsVersionStatus</ns1:pathSet></ns1:propSet>'\
         '<ns1:objectSet><ns1:obj type="Folder">%(rootFolder)s</ns1:obj><ns1:skip>false</ns1:skip>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>visitFolders</ns1:name>'\
           '<ns1:type>Folder</ns1:type><ns1:path>childEntity</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToHf</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToVmf</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>crToH</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>crToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>dcToDs</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>hToVm</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToVmf</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>vmFolder</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToDs</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>datastore</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>dcToHf</ns1:name><ns1:type>Datacenter</ns1:type>'\
           '<ns1:path>hostFolder</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>crToH</ns1:name><ns1:type>ComputeResource</ns1:type>'\
         '<ns1:path>host</ns1:path><ns1:skip>false</ns1:skip></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>crToRp</ns1:name><ns1:type>ComputeResource</ns1:type>'\
           '<ns1:path>resourcePool</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>rpToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>rpToRp</ns1:name><ns1:type>ResourcePool</ns1:type>'\
           '<ns1:path>resourcePool</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>rpToRp</ns1:name></ns1:selectSet>'\
           '<ns1:selectSet><ns1:name>rpToVm</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec">'\
           '<ns1:name>hToVm</ns1:name><ns1:type>HostSystem</ns1:type>'\
           '<ns1:path>vm</ns1:path><ns1:skip>false</ns1:skip>'\
           '<ns1:selectSet><ns1:name>visitFolders</ns1:name></ns1:selectSet></ns1:selectSet>'\
         '<ns1:selectSet xsi:type="ns1:TraversalSpec"><ns1:name>rpToVm</ns1:name><ns1:type>ResourcePool</ns1:type>'\
         '<ns1:path>vm</ns1:path><ns1:skip>false</ns1:skip></ns1:selectSet>'\
         '</ns1:objectSet></ns1:specSet><ns1:options></ns1:options></ns1:RetrievePropertiesEx>',

     "continuetoken":
         '<ns1:ContinueRetrievePropertiesEx xsi:type="ns1:ContinueRetrievePropertiesExRequestType">'\
         '<ns1:_this type="PropertyCollector">%(propertyCollector)s</ns1:_this><ns1:token>%(token)s</ns1:token></ns1:ContinueRetrievePropertiesEx>',

     "datacenters": """
  <ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">
    <ns1:_this type="PropertyCollector">%(propertyCollector)s</ns1:_this>
    <ns1:specSet>
      <ns1:propSet>
        <ns1:type>Datacenter</ns1:type>
        <ns1:pathSet>name</ns1:pathSet>
      </ns1:propSet>
      <ns1:objectSet>
        <ns1:obj type="Folder">%(rootFolder)s</ns1:obj>
        <ns1:skip>false</ns1:skip>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>visitFolders</ns1:name>
          <ns1:type>Folder</ns1:type>
          <ns1:path>childEntity</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToHf</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToVmf</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>crToH</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>crToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToDs</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>hToVm</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToVmf</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>vmFolder</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToDs</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>datastore</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToHf</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>hostFolder</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>crToH</ns1:name>
          <ns1:type>ComputeResource</ns1:type>
          <ns1:path>host</ns1:path>
          <ns1:skip>false</ns1:skip>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>crToRp</ns1:name>
          <ns1:type>ComputeResource</ns1:type>
          <ns1:path>resourcePool</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>rpToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>rpToRp</ns1:name>
          <ns1:type>ResourcePool</ns1:type>
          <ns1:path>resourcePool</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>rpToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>hToVm</ns1:name>
          <ns1:type>HostSystem</ns1:type>
          <ns1:path>vm</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>rpToVm</ns1:name>
          <ns1:type>ResourcePool</ns1:type>
          <ns1:path>vm</ns1:path>
          <ns1:skip>false</ns1:skip>
        </ns1:selectSet>
      </ns1:objectSet>
    </ns1:specSet>
    <ns1:options/>
  </ns1:RetrievePropertiesEx>""",

     "clustersofdatacenter": """
  <ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">
    <ns1:_this type="PropertyCollector">propertyCollector</ns1:_this>
    <ns1:specSet>
      <ns1:propSet>
        <ns1:type>ClusterComputeResource</ns1:type>
        <ns1:pathSet>name</ns1:pathSet>
      </ns1:propSet>
      <ns1:objectSet>
        <ns1:obj type="Datacenter">%(datacenter)s</ns1:obj>
        <ns1:skip>false</ns1:skip>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>visitFolders</ns1:name>
          <ns1:type>Folder</ns1:type>
          <ns1:path>childEntity</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToHf</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToVmf</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>crToH</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>crToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToDs</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>hToVm</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToVmf</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>vmFolder</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToDs</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>datastore</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToHf</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>hostFolder</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>crToH</ns1:name>
          <ns1:type>ComputeResource</ns1:type>
          <ns1:path>host</ns1:path>
          <ns1:skip>false</ns1:skip>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>crToRp</ns1:name>
          <ns1:type>ComputeResource</ns1:type>
          <ns1:path>resourcePool</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>rpToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>rpToRp</ns1:name>
          <ns1:type>ResourcePool</ns1:type>
          <ns1:path>resourcePool</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>rpToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>hToVm</ns1:name>
          <ns1:type>HostSystem</ns1:type>
          <ns1:path>vm</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>rpToVm</ns1:name>
          <ns1:type>ResourcePool</ns1:type>
          <ns1:path>vm</ns1:path>
          <ns1:skip>false</ns1:skip>
        </ns1:selectSet>
      </ns1:objectSet>
    </ns1:specSet>
    <ns1:options/>
  </ns1:RetrievePropertiesEx>""",

     "esxhostsofcluster":
  """<ns1:RetrievePropertiesEx xsi:type="ns1:RetrievePropertiesExRequestType">
    <ns1:_this type="PropertyCollector">propertyCollector</ns1:_this>
    <ns1:specSet>
      <ns1:propSet>
        <ns1:type>HostSystem</ns1:type>
        <ns1:pathSet>name</ns1:pathSet>
      </ns1:propSet>
      <ns1:objectSet>
        <ns1:obj type="ClusterComputeResource">%(clustername)s</ns1:obj>
        <ns1:skip>false</ns1:skip>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>visitFolders</ns1:name>
          <ns1:type>Folder</ns1:type>
          <ns1:path>childEntity</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToHf</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToVmf</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>crToH</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>crToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>dcToDs</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>hToVm</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToVmf</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>vmFolder</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToDs</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>datastore</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>dcToHf</ns1:name>
          <ns1:type>Datacenter</ns1:type>
          <ns1:path>hostFolder</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>crToH</ns1:name>
          <ns1:type>ComputeResource</ns1:type>
          <ns1:path>host</ns1:path>
          <ns1:skip>false</ns1:skip>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>crToRp</ns1:name>
          <ns1:type>ComputeResource</ns1:type>
          <ns1:path>resourcePool</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>rpToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>rpToRp</ns1:name>
          <ns1:type>ResourcePool</ns1:type>
          <ns1:path>resourcePool</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>rpToRp</ns1:name>
          </ns1:selectSet>
          <ns1:selectSet>
            <ns1:name>rpToVm</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>hToVm</ns1:name>
          <ns1:type>HostSystem</ns1:type>
          <ns1:path>vm</ns1:path>
          <ns1:skip>false</ns1:skip>
          <ns1:selectSet>
            <ns1:name>visitFolders</ns1:name>
          </ns1:selectSet>
        </ns1:selectSet>
        <ns1:selectSet xsi:type="ns1:TraversalSpec">
          <ns1:name>rpToVm</ns1:name>
          <ns1:type>ResourcePool</ns1:type>
          <ns1:path>vm</ns1:path>
          <ns1:skip>false</ns1:skip>
        </ns1:selectSet>
      </ns1:objectSet>
    </ns1:specSet>
    <ns1:options/>
  </ns1:RetrievePropertiesEx>"""
}

COUNTER_IDS = (
    # mem.*
    # 65635, 65537, 65577, 65625, 65545, 65611, 65573, 65615, 65582,
    # 65549, 65630, 65622, 65618, 65621, 65561, 65623, 65632, 65557,
    # 65628, 65633, 65541, 65643, 65586, 65553, 65569, 65589, 65639,
    # 65620, 65599, 65580, 65619, 65603,
    # disk.read/write/deviceLatency/numberRead/numberWrite
    # 131073, disk.usage'
    131076,  # disk.numberRead
    131077,  # disk.numberWrite
    131078,  # disk.read
    131079,  # disk.write
    # 131083,  # disk.deviceReadLatency
    # 131084,  # disk.kernelReadLatency
    # 131085,  # disk.totalReadLatency
    # 131086,  # disk.queueReadLatency
    # 131087,  # disk.deviceWriteLatency
    # 131088,  # disk.kernelWriteLatency
    # 131089,  # disk.totalWriteLatency
    # 131090,  # disk.queueWriteLatency
    131091,  # disk.deviceLatency
    # 131092,  # disk.kernelLatency
    # 131093,  # disk.totalLatency
    # 131094,  # disk.queueLatency
    # 131095,  # disk.maxTotalLatency
    # 131096,  # disk.maxQueueDepth
    # 131097,  # disk.numberReadAveraged
    # 131098,  # disk.numberWriteAveraged
    196609,  # net.* (ESX > 4.1)
    196612,
    196613,
    196614,
    196615,
    196616,
    196617,
    196618,
    196619,
    196620,
    196621,
    196622,
    196623,
    196624,
    196625,
    196626,
    262144,  # sys.uptime
    # 262151,
    #-262168,  sys.resourceMem*
    262171,  # sys.resourceMemConsumed (seems as this is not available in ESX 5.0
    #                                   but we saw it on 5.1)
    # 655360,  # datastore.numberReadAveraged
    # 655361,  # datastore.numberWriteAveraged
    655362,  # datastore.read
    655363,  # datastore.write
    655364,  # datastore.totalReadLatency
    655365,  # datastore.totalWriteLatency
    655366,  # datastore.sizeNormalizedDatastoreLatency
    # 655367,  # datastore.datastoreIops
    # 655368,  # datastore.datastoreReadBytes
    # 655369,  # datastore.datastoreWriteBytes
    655370,  # datastore.datastoreReadIops
    655371,  # datastore.datastoreWriteIops
    # 655372 , # datastore.datastoreNormalReadLatency
    # 655373 , # datastore.datastoreNormalWriteLatency
    # 655374 , # datastore.datastoreReadOIO
    # 655375 , # datastore.datastoreWriteOIO
    # 655376 , # datastore.datastoreMaxQueueDepth
    # 655377 , # datastore.datastoreReadLoadMetric
    # 655378 , # datastore.datastoreWriteLoadMetric
    # 655379 , # datastore.maxTotalLatency
)


def put_in_envelope(payload):
    return '<SOAP-ENV:Envelope xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" '\
           'xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ZSI="http://www.zolera.com/schemas/ZSI/" '\
           'xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" '\
           'xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">'\
           '<SOAP-ENV:Header></SOAP-ENV:Header><SOAP-ENV:Body xmlns:ns1="urn:vim25">' + payload + '</SOAP-ENV:Body></SOAP-ENV:Envelope>'


def convert_hostname(h, opt):
    if opt.spaces == "cut":
        return h.split()[0]
    return h.replace(" ", "_")


def parse_arguments(argv):
    parser = argparse.ArgumentParser(description=__doc__)

    # flags
    parser.add_argument("--debug",
                        action="store_true",
                        help="""Debug mode: let Python exceptions come through""")
    parser.add_argument("--no-cert-check",
                        action="store_true",
                        help="""Disables the checking of the servers ssl certificate""")
    parser.add_argument(
        "--pysphere",
        action="store_true",
        help="""Fallback to old pysphere based special agent. It supports ESX 4.1 but is
        very slow.""")
    parser.add_argument(
        "-D",
        "--direct",
        action="store_true",
        help="""Assume a directly queried host system (no vCenter). In this we expect data about
        only one HostSystem to be found and do not create piggy host data for that host.""")
    parser.add_argument(
        "-a",
        "--agent",
        action="store_true",
        help="""Also retrieve data from the normal Check_MK Agent. This makes sense if you query
        a vCenter that is installed on a Windows host that you also want to monitor with
        Check_MK.""")
    parser.add_argument(
        "-P",
        "--skip-placeholder-vm",
        action="store_true",
        help="""Skip placeholder virtualmachines. These backup vms are created by the Site
        Recovery Manager (SRM) and are identified by not having any assigned virtual disks.""")

    # optional arguments
    parser.add_argument("--tracefile",
                        default=None,
                        help="""Log all outgoing and incoming data into the given tracefile""")
    parser.add_argument(
        "-t",
        "--timeout",
        type=int,
        default=60,
        help="""Set the network timeout to vSphere to SECS seconds. This is also used when
        connecting the agent (option -a). Default is 60 seconds.
        Note: the timeout is not only applied to the connection, but also to each individual
        subquery.""")
    parser.add_argument(
        "-p",
        "--port",
        type=int,
        default=443,
        help="""Alternative port number (default is 443 for the https connection).""")
    parser.add_argument(
        "-S",
        "--spaces",
        choices=('cut', 'underscore'),
        default="underscore",
        help="""How to handle spaces in hostnames. "cut": cut everyting after the first space,
        "underscore": replace with underscores. Default is "underscore".""")
    parser.add_argument(
        "-i",
        "--modules",
        type=lambda s: s.split(','),
        default=['hostsystem', 'virtualmachine', 'datastore', 'counters', 'licenses'],
        help="""Modules to query. This is a comma separated list of hostsystem, virtualmachine,
        datastore, counters and licenses. Default is to query all modules.""")
    parser.add_argument(
        "--vm_piggyname",
        choices=("hostname", "alias"),
        default="alias",
        help="""Here you can specify whether the virtual machines HOSTNAME or the ESX system
        ALIAS name for this machine should be used on creating piggyback data""")
    parser.add_argument(
        "--vm_pwr_display",
        choices=('vm', 'esxhost'),
        default=None,
        help="""Specifies where the virtual machines power state should be shown. Default (no
        option) is on the queried vCenter or ESX-Host. Possible WHERE options: esxhost - show
        on ESX host, vm - show on virtual machine""")
    parser.add_argument(
        "--host_pwr_display",
        choices=('vm', 'esxhost'),
        default=None,
        help="""Specifies where the ESX hosts power state should be shown. Default (no option)
        is on the queried vCenter or ESX-Host. Possible WHERE options: esxhost - show on ESX host,
        vm - show on virtual machine.""")
    parser.add_argument(
        "--snapshot_display",
        choices=('vCenter', 'esxhost'),
        default=None,
        help="""Specifies where the virtual machines snapshots should be shown. Default (no
        option) is on the VM. Possible WHERE options: esxhost - show on ESX host, vCenter -
        show on vCenter.""")
    parser.add_argument(
        "-H",
        "--hostname",
        default=None,
        help="""Specify a hostname. This is neccessary if this is different from HOST.
        It is being used when outputting the hosts power state.""")

    # optional arguments (from a coding point of view - should some of them be mandatory?)
    parser.add_argument("-u", "--user", default=None, help="""Username for vSphere login""")
    parser.add_argument("-s",
                        "--secret",
                        default=None,
                        help="""Secret/Password for vSphere login""")

    # positional arguments
    parser.add_argument("host_address",
                        metavar="HOST",
                        help="""Host name or IP address of VMWare HostSystem""")

    return parser.parse_args(argv[1:])


def write_output(lines, opt):
    if opt.agent:
        for chunk in get_agent_info_tcp(opt.host_address, opt.timeout, opt.debug):
            sys.stdout.write(chunk)

    for line in lines:
        sys.stdout.write((line.encode("utf-8") if isinstance(line, unicode) else line) + "\n")
    sys.stdout.flush()


def get_agent_info_tcp(address, timeout, debug):
    try:
        # TODO: gethostbyname() automatically detects IP addresses and does
        # *not* contact any nameserver in that case. So the following two
        # lines of code should not be neccessary:
        if address[0] in "123456789":
            ipaddress = address
        else:
            ipaddress = socket.gethostbyname(address)
        soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            soc.settimeout(timeout)
        except AttributeError:
            pass  # some old Python versions lack settimeout(). Better ignore than fail
        soc.connect((ipaddress, 6556))
        try:
            soc.setblocking(1)
        except AttributeError:
            pass
        while True:
            received = soc.recv(4096, socket.MSG_WAITALL)
            if not received:
                break
            yield received
        soc.close()
    except Exception:
        if debug:
            raise


# Create a search pattern for the get_pattern function
# create_search_pattern(["label", "summary", "startConnected", "allowGuestControl", "connected", "status"])
def create_search_pattern(tokens):
    pattern_elements = []
    for token in tokens:
        pattern_elements.append("<%(token)s>(.*?)</%(token)s>" % {"token": token})
    return ".*?".join(pattern_elements)


def get_pattern(pattern, line):
    return re.findall(pattern, line, re.DOTALL) if line else []


# TODO: Refactor to requests
class ESXConnection(object):
    """Encapsulates the API calls to the ESX system"""
    @staticmethod
    def _connect_to_server(address, no_cert_check, debug):
        """Initialize server connection"""
        try:
            netloc = ":".join(map(str, address))

            if no_cert_check:
                try:
                    import ssl
                    server_handle = httplib.HTTPSConnection(
                        netloc, context=ssl._create_unverified_context())
                except Exception:
                    server_handle = httplib.HTTPSConnection(netloc)
            else:
                server_handle = httplib.HTTPSConnection(netloc)

            if debug:
                sys.stderr.write("Connecting to %s..." % netloc)
                sys.stderr.flush()

            server_handle.connect()
            return server_handle
        except Exception as exc:
            if debug:
                raise
            raise MKGeneralException("Cannot connect to vSphere Server. Please check the IP and"
                                     " SSL certificate (if applicable) and try again. This error"
                                     " is not related to the login credentials."
                                     " Error message: %r" % exc)

    @staticmethod
    def _check_not_authenticated(text):
        if "NotAuthenticatedFault" in text:
            raise MKQueryServerException("No longer authenticated")

    def __init__(self, address, user, secret, opt):
        super(ESXConnection, self).__init__()
        self._user = user
        self._secret = secret
        self.tracefile = opt.tracefile
        self._server_handle = self._connect_to_server(address, opt.no_cert_check, opt.debug)

        self._host_cookie_path = Path("%s/agents/agent_vsphere/cookie.%s" %
                                      (cmk.utils.paths.tmp_dir, address[0]))

        self.last_cookie_access_time = None
        self.system_info = None
        self._server_cookie = None

        self.system_info = self._fetch_systeminfo()

    def _fetch_systeminfo(self):
        """Retrieve basic data, which requires no login"""
        system_info = {}

        # Globals of ESX System. These settings are available after the first "systeminfo" query
        systemfields = [
            "apiVersion",
            "name",
            "rootFolder",
            "perfManager",
            "sessionManager",
            "licenseManager",
            "propertyCollector",
            "version",
            "build",
            "vendor",
            "osType",
        ]

        reply_data = self.query_server(telegram_list["systeminfo"])
        for entry in systemfields:
            element = get_pattern("<%(entry)s.*>(.*)</%(entry)s>" % {"entry": entry}, reply_data)
            if element:
                system_info[entry] = element[0]

        if not system_info:
            raise MKGeneralException("Unable to get data from Web API" + "\n")

        return system_info

    def prepare_soapdata(self, payload, payload_params):
        if payload_params is None:
            payload_params = {}

        # Finalize payload
        if self.system_info:
            payload_params.update(self.system_info)
        soapdata = put_in_envelope(payload)
        return soapdata % payload_params, payload_params

    def send_soapdata(self, soapdata, payload_params):
        self._init_headers(soapdata)
        response_data = []

        if self.tracefile:
            self.tracefile.write("####   Sent  ####\n%s" % soapdata)
            time_sent = time.time()
        self._server_handle.send(soapdata)

        response = self._server_handle.getresponse()
        response_data.append(response.read())

        self._check_not_authenticated(response_data[0][:512])

        while True:
            # Look for a <token>0</token> field.
            # If it exists not all data was transmitted and we need to start a
            # ContinueRetrievePropertiesExResponse query...
            token = re.findall("<token>(.*)</token>", response_data[-1][:512])
            if token:
                payload_params.update({"token": token[0]})
                soapdata = put_in_envelope(telegram_list["continuetoken"]) % payload_params
                self._init_headers(soapdata)
                self._server_handle.send(soapdata)
                response = self._server_handle.getresponse()
                response_data.append(response.read())
                self._check_not_authenticated(response_data[-1][:512])
            else:
                break

        respose_text = "".join(response_data)
        if self.tracefile:
            timing_info = "Response took: %f" % (time.time() - time_sent)
            self.tracefile.write("\n#### Received #### %s\n%s\n" % (timing_info, respose_text))

        return response, respose_text

    def query_server(self, payload, payload_params=None):
        soapdata, payload_params = self.prepare_soapdata(payload, payload_params)
        _respose_object, response_text = self.send_soapdata(soapdata, payload_params)
        return response_text

    def _init_headers(self, soapdata):
        self._server_handle.putrequest("POST", "/sdk")
        self._server_handle.putheader("Content-Length", "%d" % len(soapdata))
        self._server_handle.putheader("Content-Type", 'text/xml; charset="utf-8"')
        self._server_handle.putheader("SOAPAction", "urn:vim25/5.0")
        self._server_handle.putheader("User-Agent",
                                      "VMware VI Client/5.0.0")  # TODO: set client version?
        if self._server_cookie:
            self._server_handle.putheader("Cookie", self._server_cookie)
        self._server_handle.endheaders()

    def login(self):
        if self._host_cookie_path.exists():
            # The cookie access time is required to determine the agents check interval
            # This is required later on by the performancecounters. Depending on the
            # interval we need more or less real-time samples
            # TODO: Decouple login secret and perfcounter timer
            self.last_cookie_access_time = self._host_cookie_path.stat().st_mtime
            os.utime(str(self._host_cookie_path),
                     None)  # Touch the cookie file, whenever it is accessed

            self._server_cookie = self._host_cookie_path.open(encoding="utf-8").read()
            return

        payload = telegram_list["login"]
        payload_params = {"username": encode_url(self._user), "password": encode_url(self._secret)}
        response, reply_data = self.send_soapdata(*self.prepare_soapdata(payload, payload_params))

        if "InvalidLogin" in reply_data:
            raise MKGeneralException("Cannot login to vSphere Server. Login response is not 'OK'."
                                     " Please check the credentials.")

        server_cookie = response.msg.get("Set-Cookie", "").decode("utf-8")

        if server_cookie:
            self._host_cookie_path.parent.mkdir(parents=True, exist_ok=True)  # pylint: disable=no-member
            with self._host_cookie_path.open("w", encoding="utf-8") as f_handle:
                f_handle.write(server_cookie)

        self._server_cookie = server_cookie
        return

    def delete_server_cookie(self):
        try:
            self._host_cookie_path.unlink()
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise


def encode_url(text):
    for char, replacement in [("&", "&amp;"), (">", "&gt;"), ("<", "&lt;"), ("'", "&apos;"),
                              ("\"", "&quot;")]:
        text = text.replace(char, replacement)
    return text


def get_sections_aggregated_snapshots(vms, hostsystems):

    aggregated = {}
    for data in vms.itervalues():
        if hostsystems is not None:
            running_on = hostsystems.get(data.get("runtime.host"), data.get("runtime.host"))
        else:
            running_on = ''
        snapshots = data.get("snapshot.rootSnapshotList")
        if snapshots is not None:
            aggregated.setdefault(running_on, []).append(snapshots)

    section_lines = []
    for piggytarget, sn_list in aggregated.iteritems():
        section_lines += [
            '<<<<%s>>>>' % piggytarget, '<<<esx_vsphere_vm>>>',
            'snapshot.rootSnapshotList %s' % '|'.join(sn_list), '<<<<>>>>'
        ]
    return section_lines


def get_section_systemtime(connection, opt):
    try:
        response = connection.query_server(telegram_list["systemtime"])
        elements = get_pattern('<returnval>(.*)</returnval>', response)
        if elements:
            naive = datetime.datetime.strptime(elements[0], "%Y-%m-%dT%H:%M:%S.%fZ")
            utc = naive.replace(tzinfo=tz.tzutc())
            localtime = utc.astimezone(tz.tzlocal())
            return ["<<<systemtime>>>", localtime.strftime("%s")]
    except Exception:
        if opt.debug:
            raise
    return []


def find_host(search_hostname, hostsystems_properties):
    for vm_host_name, attributes in hostsystems_properties.items():
        if attributes.get("name")[0] == search_hostname:
            return vm_host_name
    return None


def is_placeholder_vm(devices):
    elements = get_pattern("<VirtualDevice xsi:type=\"([^\"]+)", devices)
    if "VirtualDisk" not in elements:
        return True
    return False


def eval_virtual_device(info, _datastores):
    response = []
    virtual_devices = get_pattern("<VirtualDevice (.*?)</VirtualDevice>", info)
    show_fields = ["label", "summary", "startConnected", "allowGuestControl", "connected", "status"]
    search_pattern = create_search_pattern(show_fields)
    for virtual_device in virtual_devices:
        type_info = get_pattern("type=\"(.*?)\"", virtual_device)
        device_info = get_pattern(search_pattern, virtual_device)
        if device_info:
            response.append(
                "virtualDeviceType %s|%s" %
                (type_info[0], "|".join("%s %s" % x for x in zip(show_fields, device_info[0]))))

    return "@@".join(response)


def eval_snapshot_list(info, _datastores):
    response = []
    snapshot_info = get_pattern(
        "<name>(.*?)</name>.*?<id>(.*?)</id><createTime>(.*?)</createTime><state>(.*?)</state>",
        info)
    for entry in snapshot_info:
        try:
            # 2013-11-06T15:39:39.347543Z
            creation_time = int(time.mktime(time.strptime(entry[2][:19], "%Y-%m-%dT%H:%M:%S")))
        except ValueError:
            creation_time = 0
        response.append("%s %s %s %s" %
                        (entry[1], creation_time, entry[3], entry[0].replace("|", " ")))
    return "|".join(response)


def eval_datastores(info, datastores):
    datastore_urls = get_pattern("<name>(.*?)</name><url>(.*?)</url>", info)
    response = []
    for name, _url in datastore_urls:
        for datastore in datastores.values():
            if name == datastore["name"]:
                vm_datastore = []
                for key, value in datastore.items():
                    if key != "name":
                        key = key.split(".")[1]
                    vm_datastore.append("%s %s" % (key, value))
                response.append("|".join(vm_datastore))
                break
        else:
            # No matching datastore was found. At least add the name
            response.append("name %s" % name)
    return "@@".join(response)


def fetch_host_systems(connection):
    hostsystems_response = connection.query_server(telegram_list["hostsystems"])
    elements = get_pattern(
        '<obj type="HostSystem">(.*?)</obj>.*?<val xsi:type="xsd:string">(.*?)</val>',
        hostsystems_response)

    # On some ESX systems the cookie login does not work as expected, when the agent_vsphere
    # is called only once or twice a day. The cookie is somehow outdated, but there is no
    # authentification failed message. Instead, the query simply returns an empty data set..
    # We try to detect this here (there is always a hostsystem) and raise a MKQueryServerException
    # which forces a new login
    if not elements:
        raise MKQueryServerException("Login cookie is no longer valid")

    return dict(elements)


def fetch_datastores(connection):
    datastores_response = connection.query_server(telegram_list["datastores"])
    elements = get_pattern('<objects><obj type="Datastore">(.*?)</obj>(.*?)</objects>',
                           datastores_response)
    datastores = {}
    for datastore, content in elements:
        entries = get_pattern('<name>(.*?)</name><val xsi:type.*?>(.*?)</val>', content)
        datastores[datastore] = {}
        for name, value in entries:
            datastores[datastore][name] = value
    return datastores


def fetch_counters_syntax(connection):
    counter_syntax_payload = telegram_list["perfcountersyntax"]
    counter_data = []
    for entry in COUNTER_IDS:
        counter_data.append("<ns1:counterId>%s</ns1:counterId>" % entry)

    counters_syntax_response = connection.query_server(
        counter_syntax_payload, payload_params={"counters": "".join(counter_data)})

    counters_syntax = {}
    elements = get_pattern('<returnval><key>(.*?)</key>.*?<key>(.*?)</key>.*?'\
                           '<key>(.*?)</key>.*?<key>(.*?)</key>.*?', counters_syntax_response)

    for key, name_info, group_info, unit_info in elements:
        counters_syntax[key] = {"name": name_info, "group": group_info, "unit": unit_info}
    return counters_syntax


def fetch_extra_interface_counters(connection, opt):
    # Get additional interface counter info, this only works when querying ESX hosts
    # TODO: get this info from the vcenter
    if not opt.direct:
        return []

    net_extra_info = []
    networksystem_response = connection.query_server(telegram_list["networksystem"])
    nic_objects = get_pattern('<pnic><key>(.*?)</pnic>', networksystem_response)
    for nic in nic_objects:
        nic_if = get_pattern('(.*?)</key><device>(.*?)</device>(.*)<mac>(.*?)</mac>', nic)
        try:
            bandwidth_block = nic_if[0][2]
            bandwidth = get_pattern('</driver><linkSpeed><speedMb>(.*?)</speedMb>', bandwidth_block)
            net_extra_info.append("net.macaddress|%s|%s|mac" % (nic_if[0][1], nic_if[0][3]))
            if bandwidth:
                net_extra_info.append("net.bandwidth|%s|%s|bytes" %
                                      (nic_if[0][1], int(bandwidth[0]) * 1000000))
                net_extra_info.append("net.state|%s|1|state" % nic_if[0][1])
            else:
                net_extra_info.append("net.state|%s|2|state" % nic_if[0][1])
        except Exception:
            # TODO: This is way too generic. What should be catched here?
            return []

    return net_extra_info


def get_max_samples(connection):
    # Determine the needed number of real-time samples
    # One real-time sample is 20 seconds
    # -> With a check interval of 1 minute we need the last 3 samples
    # Longer check intervals require even more samples... n-minutes * 3
    # We set the max_samples hard cap to 180 (1 hour)
    # An ESX system does not offer more than one hour of real time samples, anyway.
    max_samples = 3
    if connection.last_cookie_access_time:
        timedelta = time.time() - connection.last_cookie_access_time
        max_samples = min(180, max(1, int(timedelta) / 20))
    return max_samples


def eval_sensor_info(_hostname, _current_propname, sensor_propset):
    sensor_pattern = ""
    for key in [
            "name", "label", "summary", "key", "currentReading", "unitModifier", "baseUnits",
            "sensorType"
    ]:
        sensor_pattern += "<%(name)s>(.*?)</%(name)s>.*?" % {"name": key}

    sensor_data = get_pattern(sensor_pattern, sensor_propset)
    properties, sensors = {}, {}
    fields = ("name", "label", "summary", "key", "currentReading", "unitModifier", "baseUnits",
              "sensorType")
    sensors = {row[0]: dict(zip(fields, row)) for row in sensor_data}

    return properties, sensors


def eval_hardwarestatus_info(_hostname, _current_propname, sensor_propset):
    sensor_pattern = ""
    for key in ["name", "label", "summary", "key"]:
        sensor_pattern += "<%(name)s>(.*?)</%(name)s>.*?" % {"name": key}

    sensor_data = get_pattern(sensor_pattern, sensor_propset)
    properties, sensors = {}, {}
    for name, label, summary, key in sensor_data:
        sensors[name] = {"name": name, "label": label, "summary": summary, "key": key}
    return properties, sensors


def eval_multipath_info(_hostname, current_propname, multipath_propset):
    multipath_infos = get_pattern("<id>(.*?)</id>.*?((?:<path>.*?</path>)+)", multipath_propset)
    properties, sensors = {}, {}
    for vml_id, xml_paths in multipath_infos:
        # The Lun ID is part of the VML ID: https://kb.vmware.com/s/article/2078730
        lun_id = vml_id[10:-12]
        for path_name, path_state in get_pattern("<name>(.*?)</name>.*?<state>(.*?)</state>",
                                                 xml_paths):
            properties.setdefault(current_propname,
                                  []).append("%s %s %s" % (lun_id, path_name, path_state))
    return properties, sensors


def eval_propset_block(_hostname, current_propname, elements, id_key, propset):
    pattern = ""
    for key in elements:
        pattern += "<%(name)s>(.*?)</%(name)s>.*?" % {"name": key}

    data = get_pattern(pattern, propset)
    properties, sensors = {}, {}
    for match_groups in data:
        entries = dict(zip(elements, match_groups))
        for key, value in entries.items():
            properties.setdefault("%s.%s.%s" % (current_propname, key, entries[id_key]),
                                  []).append(value)
    return properties, sensors


def eval_cpu_pkg(hostname, current_propname, cpu_pkg_propset):
    return eval_propset_block(hostname, current_propname,
                              ["index", "vendor", "hz", "busHz", "description"], "index",
                              cpu_pkg_propset)


def eval_pci_device(hostname, current_propname, pci_propset):
    return eval_propset_block(hostname, current_propname, ["id", "vendorName", "deviceName"], "id",
                              pci_propset)


def eval_systeminfo_other(_hostname, _current_propname, otherinfo_propset):
    data = get_pattern("<identifierValue>(.*?)</identifierValue>.*?<key>(.*?)</key>",
                       otherinfo_propset)
    keys_index = {}

    properties, sensors = {}, {}
    for value, key in data:
        idx = 0
        if key in keys_index:
            keys_index[key] = keys_index[key] + 1
            idx = keys_index[key]
        properties["hardware.systemInfo.otherIdentifyingInfo.%s.%d" % (key, idx)] = [value]
        keys_index[key] = idx
    return properties, sensors


def get_section_datastores(datastores):
    section_lines = ["<<<esx_vsphere_datastores:sep(9)>>>"]
    for key in sorted(datastores.keys()):
        data = datastores[key]
        section_lines.append("[%s]" % data.get("name"))
        for ds_key in sorted(data.keys()):
            if ds_key == "name":
                continue
            section_lines.append("%s\t%s" % (ds_key.split(".")[1], data[ds_key]))
    return section_lines


def fetch_hostsystem_data(connection):
    esxhostdetails_response = connection.query_server(telegram_list["esxhostdetails"])
    hostsystems_objects = get_pattern('<objects>(.*?)</objects>', esxhostdetails_response)

    eval_functions = {
        "config.storageDevice.multipathInfo": eval_multipath_info,
        "runtime.healthSystemRuntime.systemHealthInfo.numericSensorInfo": eval_sensor_info,
        "runtime.healthSystemRuntime.hardwareStatusInfo.storageStatusInfo": eval_hardwarestatus_info,
        "runtime.healthSystemRuntime.hardwareStatusInfo.cpuStatusInfo": eval_hardwarestatus_info,
        "runtime.healthSystemRuntime.hardwareStatusInfo.memoryStatusInfo": eval_hardwarestatus_info,
        "hardware.cpuPkg": eval_cpu_pkg,
        "hardware.pciDevice": eval_pci_device,
        "hardware.systemInfo.otherIdentifyingInfo": eval_systeminfo_other,
    }

    hostsystems_properties, hostsystems_sensors = {}, {}
    for entry in hostsystems_objects:
        hostname = get_pattern('<obj type="HostSystem">(.*)</obj>', entry[:512])[0]
        hostsystems_properties[hostname] = {}
        hostsystems_sensors[hostname] = {}

        elements = get_pattern('<propSet><name>(.*?)</name><val.*?>(.*?)</val></propSet>', entry)
        for current_propname, value in elements:
            if eval_functions.get(current_propname):
                properties, sensors = eval_functions[current_propname](hostname, current_propname,
                                                                       value)
                hostsystems_properties[hostname].update(properties)
                hostsystems_sensors[hostname].update(sensors)
            else:
                hostsystems_properties[hostname].setdefault(current_propname, []).append(value)

    return hostsystems_properties, hostsystems_sensors


def get_sections_hostsystem_sensors(hostsystems_properties, hostsystems_sensors, opt):
    # TODO: improve error handling: check if multiple results
    section_lines = []
    for hostname, properties in hostsystems_properties.items():
        if not opt.direct:
            section_lines.append("<<<<%s>>>>" % convert_hostname(properties["name"][0], opt))

        section_lines.append("<<<esx_vsphere_hostsystem>>>")
        for key in sorted(properties.keys()):
            section_lines.append("%s %s" % (key, " ".join(properties[key])))

        section_lines.append("<<<esx_vsphere_sensors:sep(59)>>>")
        for key in sorted(hostsystems_sensors[hostname].keys()):
            data = hostsystems_sensors[hostname][key]
            if data["key"].lower() in ["green", "unknown"]:
                continue
            section_lines.append('%s;%s;%s;%s;%s;%s;%s;%s;%s' %
                                 (data["name"].replace(";", "_"), data.get("baseUnits", ""),
                                  data.get("currentReading", ""), data.get("sensorType", ""),
                                  data.get("unitModifier", ""), data.get("rateUnits", ""),
                                  data["key"], data["label"], data["summary"].replace(";", "_")))

    if not opt.direct:
        section_lines.append("<<<<>>>>")

    return section_lines


def get_section_licenses(connection):
    section_lines = ["<<<esx_vsphere_licenses:sep(9)>>>"]
    licenses_response = connection.query_server(telegram_list["licensesused"])
    root_node = minidom.parseString(licenses_response)
    licenses_node = root_node.getElementsByTagName("LicenseManagerLicenseInfo")
    for license_node in licenses_node:
        total = license_node.getElementsByTagName("total")[0].firstChild.data
        if total == "0":
            continue
        name = license_node.getElementsByTagName("name")[0].firstChild.data
        used = license_node.getElementsByTagName("used")[0].firstChild.data
        section_lines.append("%s\t%s %s" % (name, used, total))
    return section_lines


def get_section_counters(connection, hostsystems, datastores, opt):
    section_lines = []

    net_extra_info = fetch_extra_interface_counters(connection, opt)
    counters_syntax = fetch_counters_syntax(connection)
    max_samples = get_max_samples(connection)

    counter_data_payload = telegram_list["perfcounterdata"]
    for host in hostsystems.keys():
        ### TODO: check if this host supports perfdata
        ### TODO: try to get esx hosts perfdata from vCenter
        counter_avail = telegram_list["perfcounteravail"]
        counter_avail_response = connection.query_server(counter_avail,
                                                         payload_params={"esxhost": host})

        counters_avail = {}
        elements = get_pattern("<counterId>([0-9]*)</counterId><instance>([^<]*)",
                               counter_avail_response)
        for counter, instance in elements:
            counters_avail.setdefault(counter, []).append(instance)

        counter_data = []
        for entry in COUNTER_IDS:
            for instance in counters_avail.get(entry, []):
                counter_data.append(
                    "<ns1:metricId><ns1:counterId>%d</ns1:counterId><ns1:instance>%s</ns1:instance></ns1:metricId>"
                    % (entry, instance))
        counters_value = {}
        counter_data_response = connection.query_server(counter_data_payload,
                                                        payload_params={
                                                            "esxhost": host,
                                                            "counters": "".join(counter_data),
                                                            "samples": max_samples
                                                        })
        # Python regex only supports up to 100 match groups in a regex..
        # We are only extracting the whole value line and split it later on
        # This is a perfect candidate for "Catastrophic Backtracking" :)
        # Someday we should replace all of these get_pattern calls with
        # one of these new and fancy xml parsers I've heard from
        elements = get_pattern(
            "<id><counterId>(.*?)</counterId><instance>(.*?)</instance></id>(%s)" %
            ("<value>.*?</value>" * max_samples), counter_data_response)
        for entry in elements:
            counter, instance, valuestring = entry
            values = get_pattern("<value>(.*?)</value>", valuestring)
            if counter in counters_syntax:
                counters_value["%s.%s" % (counter, instance)] = {
                    "id": counter,
                    "instance": instance,
                    "value": "#".join(values)
                }

        counters_output = {}
        for key in sorted(counters_value.keys()):
            value = counters_value[key]
            desc = counters_syntax[value["id"]]
            counters_output[(desc["group"], desc["name"], value["instance"])] = (value["value"],
                                                                                 desc["unit"])

        # Add datastore name to counters
        for key, values in datastores.items():
            counters_output[("datastore", "name", key)] = (values.get("name"), "string")

        if not opt.direct:
            section_lines.append("<<<<%s>>>>" % convert_hostname(hostsystems[host], opt))
        section_lines.append("<<<esx_vsphere_counters:sep(124)>>>")
        section_lines += [
            "%s.%s|%s|%s|%s" % (key + value) for key, value in sorted(counters_output.items())
        ]

        section_lines += net_extra_info  # TODO: explain why this is sent to every host

    if not opt.direct:
        section_lines.append('<<<<>>>>')

    return section_lines


def fetch_virtual_machines(connection, hostsystems, datastores, opt):
    vms, vm_esx_host = {}, {}

    # <objects><propSet><name>...</name><val ..>...</val></propSet></objects>
    vmdetails_response = connection.query_server(telegram_list["vmdetails"])

    elements = get_pattern("<objects>(.*?)</objects>", vmdetails_response)
    for entry in elements:
        vm_data = dict(get_pattern("<name>(.*?)</name><val.*?>(.*?)</val>", entry))
        if opt.skip_placeholder_vm and is_placeholder_vm(vm_data.get("config.hardware.device")):
            continue

        if "runtime.host" in vm_data:
            vm_data["runtime.host"] = hostsystems.get(vm_data["runtime.host"],
                                                      vm_data["runtime.host"])

        vm_esx_host.setdefault(vm_data["runtime.host"], []).append(vm_data["name"])

        transform_functions = {
            "snapshot.rootSnapshotList": eval_snapshot_list,
            "config.datastoreUrl": eval_datastores,
            "config.hardware.device": eval_virtual_device,
        }
        for key, transform in transform_functions.items():
            if key in vm_data:
                vm_data[key] = transform(vm_data[key], datastores)

        if opt.vm_piggyname == "hostname" and vm_data.get("summary.guest.hostName"):
            vms[vm_data.get("summary.guest.hostName")] = vm_data
        else:
            vms[vm_data.get("name")] = vm_data

    return vms, vm_esx_host


def get_section_vm(vms, opt):
    section_lines = []
    for key in sorted(vms.keys()):
        data = vms[key]
        if data.get("name"):
            section_lines += ["<<<<%s>>>>" % convert_hostname(key, opt), "<<<esx_vsphere_vm>>>"]
            for entry in sorted(data.items()):
                section_lines.append("%s %s" % entry)
    return section_lines


def get_sections_clusters(connection, vm_esx_host):
    section_lines = []
    response = connection.query_server(telegram_list["datacenters"])
    datacenters = get_pattern('<objects><obj type="Datacenter">(.*?)</obj>', response)
    for datacenter in datacenters:
        response = connection.query_server(telegram_list["clustersofdatacenter"],
                                           payload_params={"datacenter": datacenter})
        clusters = get_pattern(
            '<objects><obj type="ClusterComputeResource">(.*?)</obj>.*?string">(.*?)</val></propSet></objects>',
            response)

        section_lines.append("<<<esx_vsphere_clusters:sep(9)>>>")
        for cluster in clusters:
            response = connection.query_server(telegram_list["esxhostsofcluster"],
                                               payload_params={"clustername": cluster[0]})
            cluster_vms = []
            hosts = get_pattern(
                '<objects><obj type="HostSystem">.*?string">(.*?)</val></propSet></objects>',
                response)
            for host in hosts:
                cluster_vms.extend(vm_esx_host.get(host, []))
            section_lines += [
                "%s\thostsystems\t%s\t%s" % (datacenter, cluster[1], "\t".join(hosts)),
                "%s\tvms\t%s\t%s" %
                (datacenter, cluster[1], "\t".join(map(convert_hostname, cluster_vms))),
            ]

    return section_lines


def fetch_data(connection, opt):
    output = []

    output.append("<<<esx_systeminfo>>>")
    output += ["%s %s" % entry for entry in connection.system_info.items()]

    #############################
    # Determine available host systems
    #############################
    hostsystems = fetch_host_systems(connection)

    ###########################
    # Licenses
    ###########################
    if "licenses" in opt.modules:
        output += get_section_licenses(connection)

    ###########################
    # Datastores
    ###########################
    # We need the datastore info later on in the virtualmachines and counter sections
    datastores = fetch_datastores(connection)
    if "datastore" in opt.modules:
        output += get_section_datastores(datastores)

    ###########################
    # Counters
    ###########################
    if "counters" in opt.modules:
        output += get_section_counters(connection, hostsystems, datastores, opt)

    ###########################
    # Hostsystem
    ###########################
    if "hostsystem" in opt.modules:
        hostsystems_properties, hostsystems_sensors = fetch_hostsystem_data(connection)
        output += get_sections_hostsystem_sensors(hostsystems_properties, hostsystems_sensors, opt)

    ###########################
    # Virtual machines
    ###########################
    vm_esx_host = {}
    if "virtualmachine" in opt.modules:
        vms, vm_esx_host = fetch_virtual_machines(connection, hostsystems, datastores, opt)
        output += get_section_vm(vms, opt)

        used_hostsystems = hostsystems if opt.snapshot_display == 'esxhost' else None
        output += get_sections_aggregated_snapshots(vms, used_hostsystems)

    if not opt.direct:
        output += get_sections_clusters(connection, vm_esx_host)

    output.append("<<<esx_vsphere_objects:sep(9)>>>")

    # the piggybacked data is printed later on, because it looks quite messy...
    vm_piggy_data = {}
    host_piggy_data = {}

    if "hostsystem" in opt.modules:
        if opt.host_pwr_display != "vm":  # handled later on..
            if opt.direct and opt.hostname:
                for hostname, data in hostsystems_properties.items():
                    output.append(
                        "hostsystem\t%s\t\t%s" %
                        (opt.hostname, hostsystems_properties[hostname]["runtime.powerState"][0]))
            else:
                for hostname, data in hostsystems_properties.items():
                    converted_hostname = convert_hostname(
                        hostsystems_properties[hostname]["name"][0], opt)
                    host_info = "hostsystem\t%s\t\t%s" % (
                        converted_hostname,
                        hostsystems_properties[hostname]["runtime.powerState"][0])
                    if opt.host_pwr_display == "esxhost" and not opt.direct:
                        host_piggy_data.setdefault(converted_hostname, []).append(host_info)
                    output.append(host_info)

    if "virtualmachine" in opt.modules:
        for key in vms:
            data = vms[key]
            running_on = hostsystems.get(data.get("runtime.host"), data.get("runtime.host"))
            vm_info = "virtualmachine\t%s\t%s\t%s" % (convert_hostname(
                key, opt), running_on, data.get("runtime.powerState"))

            if opt.vm_pwr_display == "vm":
                vm_name = convert_hostname(key, opt)
                vm_piggy_data.setdefault(vm_name, []).append(vm_info)
            elif opt.vm_pwr_display == "esxhost" and not opt.direct:
                host_piggy_data.setdefault(running_on, []).append(vm_info)
            output.append(vm_info)

    if ("virtualmachine" in opt.modules and "hostsystem" in opt.modules and
            opt.host_pwr_display == "vm"):

        for key in vms:
            data = vms[key]
            running_on = hostsystems.get(data.get("runtime.host"), data.get("runtime.host"))
            vm_host = find_host(running_on, hostsystems_properties)
            if not vm_host:
                continue

            vm_info = "hostsystem\t%s\t\t%s" % (
                running_on, hostsystems_properties[vm_host]["runtime.powerState"][0])
            vm_name = convert_hostname(key, opt)
            vm_piggy_data.setdefault(vm_name, []).append(vm_info)

    for entries in [host_piggy_data, vm_piggy_data]:
        for key, values in entries.items():
            output += ["<<<<%s>>>>" % key, "<<<esx_vsphere_objects:sep(9)>>>", "\n".join(values)]
    output.append("<<<<>>>>")

    output += get_section_systemtime(connection, opt)

    return output


def call_legacy_pysphere():
    # TODO: Remove this, drop agent_vsphere.pysphere
    import subprocess

    path_vsphere_pysphere = os.path.dirname(os.path.abspath(__file__))
    cmd = ["%s/agent_vsphere.pysphere" % path_vsphere_pysphere] + sys.argv[1:]
    return subprocess.call(cmd)


#   .--Main----------------------------------------------------------------.
#   |                        __  __       _                                |
#   |                       |  \/  | __ _(_)_ __                           |
#   |                       | |\/| |/ _` | | '_ \                          |
#   |                       | |  | | (_| | | | | |                         |
#   |                       |_|  |_|\__,_|_|_| |_|                         |
#   |                                                                      |
#   +----------------------------------------------------------------------+


def main(argv=None):
    if argv is None:
        argv = sys.argv

    opt = parse_arguments(argv)

    # If the --pysphere option is set we use the legacy pysphere agent, though 50 times slower...
    if opt.pysphere:
        sys.exit(call_legacy_pysphere())

    socket.setdefaulttimeout(opt.timeout)

    if opt.tracefile:
        tracefile_dir = os.path.dirname(opt.tracefile) or "."
        if os.path.exists(tracefile_dir):
            opt.tracefile = file(opt.tracefile, "w")
        elif opt.debug:
            sys.stderr.write("Path for tracefile %s does not exist" % opt.tracefile)
            sys.stderr.flush()

    if opt.tracefile:
        opt.tracefile.write("Tracefile %s Host address: %s\n" %
                            (datetime.datetime.now().strftime("%Y-%m-%d %H:%M"), opt.host_address))

    try:
        esx_connection = ESXConnection((opt.host_address, opt.port), opt.user, opt.secret, opt)

        # If the data aquisition fails, e.g. invalid cookie we try another run
        for _run_count in [0, 1]:
            # Note: If the cookie fails inbetween these calls, we also start a second run
            try:
                esx_connection.login()
                vsphere_output = fetch_data(esx_connection, opt)
            except MKQueryServerException:
                # There was a problem during the query.
                # It is possible that the server cookie got invalid.
                # We delete the cookie and start a second run
                esx_connection.delete_server_cookie()
            except Exception:
                if opt.debug:
                    raise
                raise MKGeneralException("Error while processing received data")

    except MKGeneralException as exc:
        sys.stderr.write("%s\n" % exc)
        sys.exit(0 if opt.agent else 1)

    write_output(vsphere_output, opt)


if __name__ == "__main__":
    main()
