#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# This agent version uses predefined soap inquiries which are sent
# to an esx host system. # Unlike the classic agent the reported data
# isn't processed through the pysphere module.
# Instead a simple string process approach is used which drastically
# reduces the CPU load for this agent
"""Check_MK vSphere Special Agent"""

# pylint: disable=broad-except

import datetime
import errno
import os
import re
import argparse
import socket
import sys
import time
from typing import Optional, Text  # pylint: disable=unused-import
from xml.dom import minidom  # type: ignore
# futurize requires this import:
import functools

from dateutil import tz
from pathlib2 import Path

import cmk.utils.paths
from cmk.special_agents.agent_vsphere import ESXSession, SoapTemplates

AGENT_TMP_PATH = Path(cmk.utils.paths.tmp_dir, "agents/agent_vsphere")


class MKQueryServerException(Exception):
    pass


# Great article how to get additional information
# http://www.veeam.com/kb1007

REQUESTED_COUNTERS_KEYS = (
    'disk.numberRead',
    'disk.numberWrite',
    'disk.read',
    'disk.write',
    'disk.deviceLatency',
    'net.usage',
    'net.packetsRx',
    'net.packetsTx',
    'net.received',
    'net.transmitted',
    'net.droppedRx',
    'net.droppedTx',
    'net.bytesRx',
    'net.bytesTx',
    'net.broadcastRx',
    'net.broadcastTx',
    'net.multicastRx',
    'net.multicastTx',
    'net.errorsRx',
    'net.errorsTx',
    'net.unknownProtos',
    'sys.uptime',
    'sys.resourceMemConsumed',
    'datastore.read',
    'datastore.write',
    'datastore.totalReadLatency',
    'datastore.totalWriteLatency',
    'datastore.sizeNormalizedDatastoreLatency',
    'datastore.datastoreReadIops',
    'datastore.datastoreWriteIops',
)


def parse_arguments(argv):
    parser = argparse.ArgumentParser(description=__doc__)

    # flags
    parser.add_argument("--debug",
                        action="store_true",
                        help="""Debug mode: let Python exceptions come through""")
    parser.add_argument("--no-cert-check",
                        action="store_true",
                        help="""Disables the checking of the servers ssl certificate""")
    parser.add_argument(
        "--pysphere",
        action="store_true",
        help="""Fallback to old pysphere based special agent. It supports ESX 4.1 but is
        very slow.""")
    parser.add_argument(
        "-D",
        "--direct",
        action="store_true",
        help="""Assume a directly queried host system (no vCenter). In this we expect data about
        only one HostSystem to be found and do not create piggy host data for that host.""")
    parser.add_argument(
        "-a",
        "--agent",
        action="store_true",
        help="""Also retrieve data from the normal Check_MK Agent. This makes sense if you query
        a vCenter that is installed on a Windows host that you also want to monitor with
        Check_MK.""")
    parser.add_argument(
        "-P",
        "--skip-placeholder-vm",
        action="store_true",
        help="""Skip placeholder virtualmachines. These backup vms are created by the Site
        Recovery Manager (SRM) and are identified by not having any assigned virtual disks.""")

    # optional arguments
    parser.add_argument("--tracefile",
                        default=None,
                        help="""Log all outgoing and incoming data into the given tracefile""")
    parser.add_argument(
        "-t",
        "--timeout",
        type=int,
        default=60,
        help="""Set the network timeout to vSphere to SECS seconds. This is also used when
        connecting the agent (option -a). Default is 60 seconds.
        Note: the timeout is not only applied to the connection, but also to each individual
        subquery.""")
    parser.add_argument(
        "-p",
        "--port",
        type=int,
        default=443,
        help="""Alternative port number (default is 443 for the https connection).""")
    parser.add_argument(
        "-S",
        "--spaces",
        choices=('cut', 'underscore'),
        default="underscore",
        help="""How to handle spaces in hostnames. "cut": cut everyting after the first space,
        "underscore": replace with underscores. Default is "underscore".""")
    parser.add_argument(
        "-i",
        "--modules",
        type=lambda s: s.split(','),
        default=['hostsystem', 'virtualmachine', 'datastore', 'counters', 'licenses'],
        help="""Modules to query. This is a comma separated list of hostsystem, virtualmachine,
        datastore, counters and licenses. Default is to query all modules.""")
    parser.add_argument(
        "--vm_piggyname",
        choices=("hostname", "alias"),
        default="alias",
        help="""Here you can specify whether the virtual machines HOSTNAME or the ESX system
        ALIAS name for this machine should be used on creating piggyback data""")
    parser.add_argument(
        "--vm_pwr_display",
        choices=('vm', 'esxhost'),
        default=None,
        help="""Specifies where the virtual machines power state should be shown. Default (no
        option) is on the queried vCenter or ESX-Host. Possible WHERE options: esxhost - show
        on ESX host, vm - show on virtual machine""")
    parser.add_argument(
        "--host_pwr_display",
        choices=('vm', 'esxhost'),
        default=None,
        help="""Specifies where the ESX hosts power state should be shown. Default (no option)
        is on the queried vCenter or ESX-Host. Possible WHERE options: esxhost - show on ESX host,
        vm - show on virtual machine.""")
    parser.add_argument(
        "--snapshot_display",
        choices=('vCenter', 'esxhost'),
        default=None,
        help="""Specifies where the virtual machines snapshots should be shown. Default (no
        option) is on the VM. Possible WHERE options: esxhost - show on ESX host, vCenter -
        show on vCenter.""")
    parser.add_argument(
        "-H",
        "--hostname",
        default=None,
        help="""Specify a hostname. This is neccessary if this is different from HOST.
        It is being used when outputting the hosts power state.""")

    # optional arguments (from a coding point of view - should some of them be mandatory?)
    parser.add_argument("-u", "--user", default=None, help="""Username for vSphere login""")
    parser.add_argument("-s",
                        "--secret",
                        default=None,
                        help="""Secret/Password for vSphere login""")

    # positional arguments
    parser.add_argument("host_address",
                        metavar="HOST",
                        help="""Host name or IP address of VMWare HostSystem""")

    return parser.parse_args(argv[1:])


#   .--Connection----------------------------------------------------------+
#   |             ____                       _   _                         |
#   |            / ___|___  _ __  _ __   ___| |_(_) ___  _ __              |
#   |           | |   / _ \| '_ \| '_ \ / _ \ __| |/ _ \| '_ \             |
#   |           | |__| (_) | | | | | | |  __/ |_| | (_) | | | |            |
#   |            \____\___/|_| |_|_| |_|\___|\__|_|\___/|_| |_|            |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'
#.


class ESXConnection(object):
    """Encapsulates the API calls to the ESX system"""
    ESCAPED_CHARS = {"&": "&amp;", ">": "&gt;", "<": "&lt;", "'": "&apos;", '"': "&quot;"}

    @staticmethod
    def _escape_xml(text):
        return ''.join(ESXConnection.ESCAPED_CHARS.get(c, c) for c in text)

    @staticmethod
    def _check_not_authenticated(text):
        if "NotAuthenticatedFault" in text:
            raise MKQueryServerException("No longer authenticated")

    def __init__(self, address, port, opt):
        super(ESXConnection, self).__init__()
        self.tracefile = opt.tracefile

        AGENT_TMP_PATH.mkdir(parents=True, exist_ok=True)

        self._server_cookie_path = AGENT_TMP_PATH / ("%s.cookie" % address)
        self._perf_samples_path = AGENT_TMP_PATH / ("%s.timer" % address)
        self._perf_samples = None

        self._session = ESXSession(address, port, opt.no_cert_check)
        self.system_info = self._fetch_systeminfo()
        self._soap_templates = SoapTemplates(self.system_info)

    def _fetch_systeminfo(self):
        """Retrieve basic data, which requires no login"""
        system_info = {}

        # Globals of ESX System. These settings are available after the first "systeminfo" query
        systemfields = [
            "apiVersion",
            "name",
            "rootFolder",
            "perfManager",
            "sessionManager",
            "licenseManager",
            "propertyCollector",
            "version",
            "build",
            "vendor",
            "osType",
        ]

        response = self._session.postsoap(SoapTemplates.SYSTEMINFO)
        for entry in systemfields:
            element = get_pattern("<%(entry)s.*>(.*)</%(entry)s>" % {"entry": entry}, response.text)
            if element:
                system_info[entry] = element[0]

        if not system_info:
            raise SystemExit("Cannot get system info from vSphere server. Please check the IP and"
                             "SSL certificate (if applicable) and try again. This error is not"
                             " related to the login credentials. Response: [%s] %s" %
                             (response.status_code, response.reason))

        return system_info

    def query_server(self, method, **kwargs):
        payload = getattr(self._soap_templates, method) % kwargs

        if self.tracefile:
            self.tracefile.write("####   Sent  ####\n%s" % payload)
            time_sent = time.time()

        response_data = []
        while True:
            response = self._session.postsoap(payload)
            response_data.append(response.text)
            self._check_not_authenticated(response_data[-1][:512])
            # Look for a <token>0</token> field.
            # If it exists not all data was transmitted and we need to start a
            # ContinueRetrievePropertiesExResponse query...
            token = re.findall("<token>(.*)</token>", response_data[-1][:512])
            if not token:
                break
            payload = self._soap_templates.continuetoken % {"token": token[0]}

        respose_text = "".join(response_data)
        if self.tracefile:
            timing_info = "Response took: %f" % (time.time() - time_sent)
            self.tracefile.write("\n#### Received #### %s\n%s\n" % (timing_info, respose_text))

        return respose_text

    @property
    def perf_samples(self):
        '''Return and cache the needed number of real-time samples

        One real-time sample is 20 seconds. We set the time delta hard cap to 1 hour,
        an ESX system does not offer more than one hour of real time samples, anyway.
        '''
        if self._perf_samples is not None:
            return self._perf_samples

        try:
            delta = min(3600., time.time() - self._perf_samples_path.stat().st_mtime)
        except OSError:
            delta = 60.
        finally:
            self._perf_samples_path.touch()

        self._perf_samples = max(1, int(delta / 20.))
        return self._perf_samples

    def login(self, user, password):
        if self._server_cookie_path.exists():
            self._session.headers["Cookie"] = self._server_cookie_path.open(encoding="utf-8").read()
            return

        auth = {"username": self._escape_xml(user), "password": self._escape_xml(password)}
        response = self._session.postsoap(self._soap_templates.login % auth)

        server_cookie = response.headers.get("set-cookie", "").decode("utf-8")

        if response.status_code != 200 or not server_cookie:
            raise SystemExit("Cannot login to vSphere Server (reason: [%s] %s). Please check the "
                             "credentials." % (response.status_code, response.reason))

        with self._server_cookie_path.open("w", encoding="utf-8") as f_handle:
            f_handle.write(server_cookie)

        self._session.headers["Cookie"] = server_cookie
        return

    def delete_server_cookie(self):
        try:
            self._server_cookie_path.unlink()
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise


#   .--Counters------------------------------------------------------------+
#   |           ____                  _                                    |
#   |          / ___|___  _   _ _ __ | |_ ___ _ __ ___                     |
#   |         | |   / _ \| | | | '_ \| __/ _ \ '__/ __|                    |
#   |         | |__| (_) | |_| | | | | ||  __/ |  \__ \                    |
#   |          \____\___/ \__,_|_| |_|\__\___|_|  |___/                    |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'
#.


def fetch_available_counters(connection, hostsystems):
    counters_available_by_host = {}
    for host in hostsystems:
        counter_avail_response = connection.query_server('perfcounteravail', esxhost=host)
        elements = get_pattern("<counterId>([0-9]*)</counterId><instance>([^<]*)",
                               counter_avail_response)

        data = counters_available_by_host.setdefault(host, {})
        for counter, instance in elements:
            data.setdefault(counter, []).append(instance)

    return counters_available_by_host


def fetch_counters_syntax(connection, counter_ids):

    counters_list = ["<ns1:counterId>%s</ns1:counterId>" % id_ for id_ in counter_ids]

    response_text = connection.query_server('perfcountersyntax', counters="".join(counters_list))

    elements = get_pattern('<returnval><key>(.*?)</key>.*?<key>(.*?)</key>.*?'\
                           '<key>(.*?)</key>.*?<key>(.*?)</key>.*?', response_text)

    return {
        id_: {
            "key": ".".join((group, name)),
            "name": name,
            "group": group,
            "unit": unit
        } for id_, name, group, unit in elements
    }


def fetch_extra_interface_counters(connection, opt):
    # Get additional interface counter info, this only works when querying ESX hosts
    # TODO: get this info from the vcenter
    if not opt.direct:
        return []

    net_extra_info = []
    networksystem_response = connection.query_server('networksystem')
    nic_objects = get_pattern('<pnic><key>(.*?)</pnic>', networksystem_response)
    for nic in nic_objects:
        nic_if = get_pattern('(.*?)</key><device>(.*?)</device>(.*)<mac>(.*?)</mac>', nic)
        if not nic_if:
            continue
        _unused, device, bandwidth_block, mac = nic_if[0]
        net_extra_info.append("net.macaddress|%s|%s|mac" % (device, mac))
        bandwidth = get_pattern('</driver><linkSpeed><speedMb>(.*?)</speedMb>', bandwidth_block)
        try:
            net_extra_info.append("net.bandwidth|%s|%s|bytes" %
                                  (device, int(bandwidth[0]) * 1000000))
        except (ValueError, IndexError):
            net_extra_info.append("net.state|%s|2|state" % device)
        else:
            net_extra_info.append("net.state|%s|1|state" % device)

    return net_extra_info


def fetch_counters(connection, host, counters_selected):
    counter_data = []
    for entry, instances in counters_selected:
        counter_data.extend(
            "<ns1:metricId><ns1:counterId>%s</ns1:counterId><ns1:instance>%s</ns1:instance>"
            "</ns1:metricId>" % (entry, instance) for instance in instances)

    response_text = connection.query_server('perfcounterdata',
                                            esxhost=host,
                                            counters="".join(counter_data),
                                            samples=connection.perf_samples)

    # Python regex only supports up to 100 match groups in a regex..
    # We are only extracting the whole value line and split it later on
    # This is a perfect candidate for "Catastrophic Backtracking" :)
    # Someday we should replace all of these get_pattern calls with
    # one of these new and fancy xml parsers I've heard from
    elements = get_pattern(
        "<id><counterId>(.*?)</counterId><instance>(.*?)</instance></id>(%s)" %
        ("<value>.*?</value>" * connection.perf_samples), response_text)
    counters_value = []
    for entry in elements:
        id_, instance, valuestring = entry
        values = get_pattern("<value>(.*?)</value>", valuestring)
        counters_value.append((id_, instance, values))

    return counters_value


def get_section_counters(connection, hostsystems, datastores, opt):
    section_lines = []
    counters_available_by_host = fetch_available_counters(connection, hostsystems)
    counters_available_all = functools.reduce(lambda x, y: x.union(y),
                                              counters_available_by_host.itervalues(), set())
    net_extra_info = fetch_extra_interface_counters(connection, opt)
    counters_description = fetch_counters_syntax(connection, counters_available_all)

    for host in hostsystems:
        counters_avail = counters_available_by_host[host]

        counters_selected = [
            (id_, instances)
            for id_, instances in counters_avail.iteritems()
            if counters_description.get(id_, {}).get("key") in REQUESTED_COUNTERS_KEYS
        ]

        counters_value = fetch_counters(connection, host, counters_selected)

        counters_output = {}
        for id_, instance, values in counters_value:
            desc = counters_description.get(id_)
            if not desc:
                continue
            counters_output[(desc["group"], desc["name"], instance)] = ('#'.join(values),
                                                                        desc["unit"])

        # Add datastore name to counters
        for key, values in datastores.items():
            counters_output[("datastore", "name", key)] = (values.get("name"), "string")

        if not opt.direct:
            section_lines.append("<<<<%s>>>>" % convert_hostname(hostsystems[host], opt))
        section_lines.append("<<<esx_vsphere_counters:sep(124)>>>")
        section_lines += [
            "%s.%s|%s|%s|%s" % (key + value) for key, value in sorted(counters_output.items())
        ]

        section_lines += net_extra_info  # TODO: explain why this is sent to every host

    if not opt.direct:
        section_lines.append('<<<<>>>>')

    return section_lines


#   .--Hostsystem----------------------------------------------------------.
#   |         _   _           _                 _                          |
#   |        | | | | ___  ___| |_ ___ _   _ ___| |_ ___ _ __ ___           |
#   |        | |_| |/ _ \/ __| __/ __| | | / __| __/ _ \ '_ ` _ \          |
#   |        |  _  | (_) \__ \ |_\__ \ |_| \__ \ ||  __/ | | | | |         |
#   |        |_| |_|\___/|___/\__|___/\__, |___/\__\___|_| |_| |_|         |
#   |                                 |___/                                |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'
#.


def eval_sensor_info(_hostname, _current_propname, sensor_propset):
    sensor_pattern = ""
    for key in [
            "name", "label", "summary", "key", "currentReading", "unitModifier", "baseUnits",
            "sensorType"
    ]:
        sensor_pattern += "<%(name)s>(.*?)</%(name)s>.*?" % {"name": key}

    sensor_data = get_pattern(sensor_pattern, sensor_propset)
    properties, sensors = {}, {}
    fields = ("name", "label", "summary", "key", "currentReading", "unitModifier", "baseUnits",
              "sensorType")
    sensors = {row[0]: dict(zip(fields, row)) for row in sensor_data}

    return properties, sensors


def eval_hardwarestatus_info(_hostname, _current_propname, sensor_propset):
    sensor_pattern = ""
    for key in ["name", "label", "summary", "key"]:
        sensor_pattern += "<%(name)s>(.*?)</%(name)s>.*?" % {"name": key}

    sensor_data = get_pattern(sensor_pattern, sensor_propset)
    properties, sensors = {}, {}
    for name, label, summary, key in sensor_data:
        sensors[name] = {"name": name, "label": label, "summary": summary, "key": key}
    return properties, sensors


def eval_multipath_info(_hostname, current_propname, multipath_propset):
    multipath_infos = get_pattern("<id>(.*?)</id>.*?((?:<path>.*?</path>)+)", multipath_propset)
    properties, sensors = {}, {}
    for vml_id, xml_paths in multipath_infos:
        # The Lun ID is part of the VML ID: https://kb.vmware.com/s/article/2078730
        lun_id = vml_id[10:-12]
        for path_name, path_state in get_pattern("<name>(.*?)</name>.*?<state>(.*?)</state>",
                                                 xml_paths):
            properties.setdefault(current_propname,
                                  []).append("%s %s %s" % (lun_id, path_name, path_state))
    return properties, sensors


def eval_propset_block(_hostname, current_propname, elements, id_key, propset):
    pattern = ""
    for key in elements:
        pattern += "<%(name)s>(.*?)</%(name)s>.*?" % {"name": key}

    data = get_pattern(pattern, propset)
    properties, sensors = {}, {}
    for match_groups in data:
        entries = dict(zip(elements, match_groups))
        for key, value in entries.items():
            properties.setdefault("%s.%s.%s" % (current_propname, key, entries[id_key]),
                                  []).append(value)
    return properties, sensors


def eval_cpu_pkg(hostname, current_propname, cpu_pkg_propset):
    return eval_propset_block(hostname, current_propname,
                              ["index", "vendor", "hz", "busHz", "description"], "index",
                              cpu_pkg_propset)


def eval_pci_device(hostname, current_propname, pci_propset):
    return eval_propset_block(hostname, current_propname, ["id", "vendorName", "deviceName"], "id",
                              pci_propset)


def eval_systeminfo_other(_hostname, _current_propname, otherinfo_propset):
    data = get_pattern("<identifierValue>(.*?)</identifierValue>.*?<key>(.*?)</key>",
                       otherinfo_propset)
    keys_index = {}

    properties, sensors = {}, {}
    for value, key in data:
        idx = 0
        if key in keys_index:
            keys_index[key] = keys_index[key] + 1
            idx = keys_index[key]
        properties["hardware.systemInfo.otherIdentifyingInfo.%s.%d" % (key, idx)] = [value]
        keys_index[key] = idx
    return properties, sensors


def fetch_hostsystem_data(connection):
    esxhostdetails_response = connection.query_server('esxhostdetails')
    hostsystems_objects = get_pattern('<objects>(.*?)</objects>', esxhostdetails_response)

    eval_functions = {
        "config.storageDevice.multipathInfo": eval_multipath_info,
        "runtime.healthSystemRuntime.systemHealthInfo.numericSensorInfo": eval_sensor_info,
        "runtime.healthSystemRuntime.hardwareStatusInfo.storageStatusInfo": eval_hardwarestatus_info,
        "runtime.healthSystemRuntime.hardwareStatusInfo.cpuStatusInfo": eval_hardwarestatus_info,
        "runtime.healthSystemRuntime.hardwareStatusInfo.memoryStatusInfo": eval_hardwarestatus_info,
        "hardware.cpuPkg": eval_cpu_pkg,
        "hardware.pciDevice": eval_pci_device,
        "hardware.systemInfo.otherIdentifyingInfo": eval_systeminfo_other,
    }

    hostsystems_properties, hostsystems_sensors = {}, {}
    for entry in hostsystems_objects:
        hostname = get_pattern('<obj type="HostSystem">(.*)</obj>', entry[:512])[0]
        hostsystems_properties[hostname] = {}
        hostsystems_sensors[hostname] = {}

        elements = get_pattern('<propSet><name>(.*?)</name><val.*?>(.*?)</val></propSet>', entry)
        for current_propname, value in elements:
            if eval_functions.get(current_propname):
                properties, sensors = eval_functions[current_propname](hostname, current_propname,
                                                                       value)
                hostsystems_properties[hostname].update(properties)
                hostsystems_sensors[hostname].update(sensors)
            else:
                hostsystems_properties[hostname].setdefault(current_propname, []).append(value)

    return hostsystems_properties, hostsystems_sensors


def get_sections_hostsystem_sensors(hostsystems_properties, hostsystems_sensors, opt):
    # TODO: improve error handling: check if multiple results
    section_lines = []
    for hostname, properties in hostsystems_properties.items():
        if not opt.direct:
            section_lines.append("<<<<%s>>>>" % convert_hostname(properties["name"][0], opt))

        section_lines.append("<<<esx_vsphere_hostsystem>>>")
        for key in sorted(properties.keys()):
            section_lines.append("%s %s" % (key, " ".join(properties[key])))

        section_lines.append("<<<esx_vsphere_sensors:sep(59)>>>")
        for key in sorted(hostsystems_sensors[hostname].keys()):
            data = hostsystems_sensors[hostname][key]
            if data["key"].lower() in ["green", "unknown"]:
                continue
            section_lines.append('%s;%s;%s;%s;%s;%s;%s;%s;%s' %
                                 (data["name"].replace(";", "_"), data.get("baseUnits", ""),
                                  data.get("currentReading", ""), data.get("sensorType", ""),
                                  data.get("unitModifier", ""), data.get("rateUnits", ""),
                                  data["key"], data["label"], data["summary"].replace(";", "_")))

    if not opt.direct:
        section_lines.append("<<<<>>>>")

    return section_lines


#   .--unsorted------------------------------------------------------------+
#   |                                       _           _                  |
#   |            _   _ _ __  ___  ___  _ __| |_ ___  __| |                 |
#   |           | | | | '_ \/ __|/ _ \| '__| __/ _ \/ _` |                 |
#   |           | |_| | | | \__ \ (_) | |  | ||  __/ (_| |                 |
#   |            \__,_|_| |_|___/\___/|_|   \__\___|\__,_|                 |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'
#.


def convert_hostname(hostname, opt):
    if opt.spaces == "cut":
        return hostname.split()[0]
    return hostname.replace(" ", "_")


def write_output(lines, opt):
    if opt.agent:
        for chunk in get_agent_info_tcp(opt.host_address, opt.timeout, opt.debug):
            sys.stdout.write(chunk)

    for line in lines:
        sys.stdout.write((line.encode("utf-8") if isinstance(line, unicode) else line) + "\n")
    sys.stdout.flush()


def get_agent_info_tcp(address, timeout, debug):
    try:
        # TODO: gethostbyname() automatically detects IP addresses and does
        # *not* contact any nameserver in that case. So the following two
        # lines of code should not be neccessary:
        if address[0] in "123456789":
            ipaddress = address
        else:
            ipaddress = socket.gethostbyname(address)
        soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            soc.settimeout(timeout)
        except AttributeError:
            pass  # some old Python versions lack settimeout(). Better ignore than fail
        soc.connect((ipaddress, 6556))
        try:
            soc.setblocking(1)
        except AttributeError:
            pass
        while True:
            received = soc.recv(4096, socket.MSG_WAITALL)
            if not received:
                break
            yield received
        soc.close()
    except Exception:
        if debug:
            raise


def get_pattern(pattern, line):
    return re.findall(pattern, line, re.DOTALL) if line else []


def get_sections_aggregated_snapshots(vms, hostsystems):

    aggregated = {}
    for data in vms.itervalues():
        if hostsystems is not None:
            running_on = hostsystems.get(data.get("runtime.host"), data.get("runtime.host"))
        else:
            running_on = ''
        snapshots = data.get("snapshot.rootSnapshotList")
        if snapshots is not None:
            aggregated.setdefault(running_on, []).append(snapshots)

    section_lines = []
    for piggytarget, sn_list in aggregated.iteritems():
        section_lines += [
            '<<<<%s>>>>' % piggytarget, '<<<esx_vsphere_vm>>>',
            'snapshot.rootSnapshotList %s' % '|'.join(sn_list), '<<<<>>>>'
        ]
    return section_lines


def get_section_systemtime(connection, opt):
    try:
        response = connection.query_server('systemtime')
        elements = get_pattern('<returnval>(.*)</returnval>', response)
        if elements:
            naive = datetime.datetime.strptime(elements[0], "%Y-%m-%dT%H:%M:%S.%fZ")
            utc = naive.replace(tzinfo=tz.tzutc())
            localtime = utc.astimezone(tz.tzlocal())
            return ["<<<systemtime>>>", localtime.strftime("%s")]
    except Exception:
        if opt.debug:
            raise
    return []


def find_host(search_hostname, hostsystems_properties):
    for vm_host_name, attributes in hostsystems_properties.items():
        if attributes.get("name")[0] == search_hostname:
            return vm_host_name
    return None


def is_placeholder_vm(devices):
    elements = get_pattern("<VirtualDevice xsi:type=\"([^\"]+)", devices)
    if "VirtualDisk" not in elements:
        return True
    return False


def eval_virtual_device(info, _datastores):
    response = []
    virtual_devices = get_pattern("<VirtualDevice (.*?)</VirtualDevice>", info)
    search_pattern = ('<(label)>(.*?)</label>.*?'
                      '<(summary)>(.*?)</summary>.*?'
                      '<(startConnected)>(.*?)</startConnected>.*?'
                      '<(allowGuestControl)>(.*?)</allowGuestControl>.*?'
                      '<(connected)>(.*?)</connected>.*?'
                      '<(status)>(.*?)</status>')
    for virtual_device in virtual_devices:
        try:
            type_info = get_pattern("type=\"(.*?)\"", virtual_device)[0]
            device_info = get_pattern(search_pattern, virtual_device)[0]
        except IndexError:
            continue
        device_pairs = zip(device_info[0::2], device_info[1::2])
        device_txt = "|".join("%s %s" % p for p in device_pairs)
        response.append("virtualDeviceType %s|%s" % (type_info, device_txt))

    return "@@".join(response)


def eval_snapshot_list(info, _datastores):
    response = []
    snapshot_info = get_pattern(
        "<name>(.*?)</name>.*?<id>(.*?)</id><createTime>(.*?)</createTime><state>(.*?)</state>",
        info)
    for entry in snapshot_info:
        try:
            # 2013-11-06T15:39:39.347543Z
            creation_time = int(time.mktime(time.strptime(entry[2][:19], "%Y-%m-%dT%H:%M:%S")))
        except ValueError:
            creation_time = 0
        response.append("%s %s %s %s" %
                        (entry[1], creation_time, entry[3], entry[0].replace("|", " ")))
    return "|".join(response)


def eval_datastores(info, datastores):
    datastore_urls = get_pattern("<name>(.*?)</name><url>(.*?)</url>", info)
    response = []
    for name, _url in datastore_urls:
        for datastore in datastores.values():
            if name == datastore["name"]:
                vm_datastore = []
                for key, value in datastore.items():
                    if key != "name":
                        key = key.split(".")[1]
                    vm_datastore.append("%s %s" % (key, value))
                response.append("|".join(vm_datastore))
                break
        else:
            # No matching datastore was found. At least add the name
            response.append("name %s" % name)
    return "@@".join(response)


def fetch_host_systems(connection):
    hostsystems_response = connection.query_server('hostsystems')
    elements = get_pattern(
        '<obj type="HostSystem">(.*?)</obj>.*?<val xsi:type="xsd:string">(.*?)</val>',
        hostsystems_response)

    # On some ESX systems the cookie login does not work as expected, when the agent_vsphere
    # is called only once or twice a day. The cookie is somehow outdated, but there is no
    # authentification failed message. Instead, the query simply returns an empty data set..
    # We try to detect this here (there is always a hostsystem) and raise a MKQueryServerException
    # which forces a new login
    if not elements:
        raise MKQueryServerException("Login cookie is no longer valid")

    return dict(elements)


def fetch_datastores(connection):
    datastores_response = connection.query_server('datastores')
    elements = get_pattern('<objects><obj type="Datastore">(.*?)</obj>(.*?)</objects>',
                           datastores_response)
    datastores = {}
    for datastore, content in elements:
        entries = get_pattern('<name>(.*?)</name><val xsi:type.*?>(.*?)</val>', content)
        datastores[datastore] = {}
        for name, value in entries:
            datastores[datastore][name] = value
    return datastores


def get_section_datastores(datastores):
    section_lines = ["<<<esx_vsphere_datastores:sep(9)>>>"]
    for key in sorted(datastores.keys()):
        data = datastores[key]
        section_lines.append("[%s]" % data.get("name"))
        for ds_key in sorted(data.keys()):
            if ds_key == "name":
                continue
            section_lines.append("%s\t%s" % (ds_key.split(".")[1], data[ds_key]))
    return section_lines


def get_section_licenses(connection):
    section_lines = ["<<<esx_vsphere_licenses:sep(9)>>>"]
    licenses_response = connection.query_server('licensesused')
    root_node = minidom.parseString(licenses_response)
    licenses_node = root_node.getElementsByTagName("LicenseManagerLicenseInfo")
    for license_node in licenses_node:
        total = license_node.getElementsByTagName("total")[0].firstChild.data
        if total == "0":
            continue
        name = license_node.getElementsByTagName("name")[0].firstChild.data
        used = license_node.getElementsByTagName("used")[0].firstChild.data
        section_lines.append("%s\t%s %s" % (name, used, total))
    return section_lines


def fetch_virtual_machines(connection, hostsystems, datastores, opt):
    vms, vm_esx_host = {}, {}

    # <objects><propSet><name>...</name><val ..>...</val></propSet></objects>
    vmdetails_response = connection.query_server('vmdetails')

    elements = get_pattern("<objects>(.*?)</objects>", vmdetails_response)
    for entry in elements:
        vm_data = dict(get_pattern("<name>(.*?)</name><val.*?>(.*?)</val>", entry))
        if opt.skip_placeholder_vm and is_placeholder_vm(vm_data.get("config.hardware.device")):
            continue

        if "runtime.host" in vm_data:
            vm_data["runtime.host"] = hostsystems.get(vm_data["runtime.host"],
                                                      vm_data["runtime.host"])

        vm_esx_host.setdefault(vm_data["runtime.host"], []).append(vm_data["name"])

        transform_functions = {
            "snapshot.rootSnapshotList": eval_snapshot_list,
            "config.datastoreUrl": eval_datastores,
            "config.hardware.device": eval_virtual_device,
        }
        for key, transform in transform_functions.items():
            if key in vm_data:
                vm_data[key] = transform(vm_data[key], datastores)

        if opt.vm_piggyname == "hostname" and vm_data.get("summary.guest.hostName"):
            vms[vm_data.get("summary.guest.hostName")] = vm_data
        else:
            vms[vm_data.get("name")] = vm_data

    return vms, vm_esx_host


def get_section_vm(vms, opt):
    section_lines = []
    for key in sorted(vms.keys()):
        data = vms[key]
        if data.get("name"):
            section_lines += ["<<<<%s>>>>" % convert_hostname(key, opt), "<<<esx_vsphere_vm>>>"]
            for entry in sorted(data.items()):
                section_lines.append("%s %s" % entry)
    return section_lines


def get_sections_clusters(connection, vm_esx_host):
    section_lines = []
    response = connection.query_server('datacenters')
    datacenters = get_pattern('<objects><obj type="Datacenter">(.*?)</obj>', response)
    for datacenter in datacenters:
        response = connection.query_server('clustersofdatacenter', datacenter=datacenter)
        clusters = get_pattern(
            '<objects><obj type="ClusterComputeResource">(.*?)</obj>.*?string">(.*?)</val>'
            '</propSet></objects>', response)

        section_lines.append("<<<esx_vsphere_clusters:sep(9)>>>")
        for cluster in clusters:
            response = connection.query_server('esxhostsofcluster', clustername=cluster[0])
            cluster_vms = []
            hosts = get_pattern(
                '<objects><obj type="HostSystem">.*?string">(.*?)</val></propSet></objects>',
                response)
            for host in hosts:
                cluster_vms.extend(vm_esx_host.get(host, []))
            section_lines += [
                "%s\thostsystems\t%s\t%s" % (datacenter, cluster[1], "\t".join(hosts)),
                "%s\tvms\t%s\t%s" %
                (datacenter, cluster[1], "\t".join(map(convert_hostname, cluster_vms))),
            ]

    return section_lines


def fetch_data(connection, opt):
    output = []

    output.append("<<<esx_systeminfo>>>")
    output += ["%s %s" % entry for entry in connection.system_info.items()]

    #############################
    # Determine available host systems
    #############################
    hostsystems = fetch_host_systems(connection)

    ###########################
    # Licenses
    ###########################
    if "licenses" in opt.modules:
        output += get_section_licenses(connection)

    ###########################
    # Datastores
    ###########################
    # We need the datastore info later on in the virtualmachines and counter sections
    datastores = fetch_datastores(connection)
    if "datastore" in opt.modules:
        output += get_section_datastores(datastores)

    ###########################
    # Counters
    ###########################
    if "counters" in opt.modules:
        output += get_section_counters(connection, hostsystems, datastores, opt)

    ###########################
    # Hostsystem
    ###########################
    if "hostsystem" in opt.modules:
        hostsystems_properties, hostsystems_sensors = fetch_hostsystem_data(connection)
        output += get_sections_hostsystem_sensors(hostsystems_properties, hostsystems_sensors, opt)

    ###########################
    # Virtual machines
    ###########################
    vm_esx_host = {}
    if "virtualmachine" in opt.modules:
        vms, vm_esx_host = fetch_virtual_machines(connection, hostsystems, datastores, opt)
        output += get_section_vm(vms, opt)

        used_hostsystems = hostsystems if opt.snapshot_display == 'esxhost' else None
        output += get_sections_aggregated_snapshots(vms, used_hostsystems)

    if not opt.direct:
        output += get_sections_clusters(connection, vm_esx_host)

    output.append("<<<esx_vsphere_objects:sep(9)>>>")

    # the piggybacked data is printed later on, because it looks quite messy...
    vm_piggy_data = {}
    host_piggy_data = {}

    if "hostsystem" in opt.modules:
        if opt.host_pwr_display != "vm":  # handled later on..
            if opt.direct and opt.hostname:
                for hostname, data in hostsystems_properties.items():
                    output.append(
                        "hostsystem\t%s\t\t%s" %
                        (opt.hostname, hostsystems_properties[hostname]["runtime.powerState"][0]))
            else:
                for hostname, data in hostsystems_properties.items():
                    converted_hostname = convert_hostname(
                        hostsystems_properties[hostname]["name"][0], opt)
                    host_info = "hostsystem\t%s\t\t%s" % (
                        converted_hostname,
                        hostsystems_properties[hostname]["runtime.powerState"][0])
                    if opt.host_pwr_display == "esxhost" and not opt.direct:
                        host_piggy_data.setdefault(converted_hostname, []).append(host_info)
                    output.append(host_info)

    if "virtualmachine" in opt.modules:
        for key in vms:
            data = vms[key]
            running_on = hostsystems.get(data.get("runtime.host"), data.get("runtime.host"))
            vm_info = "virtualmachine\t%s\t%s\t%s" % (convert_hostname(
                key, opt), running_on, data.get("runtime.powerState"))

            if opt.vm_pwr_display == "vm":
                vm_name = convert_hostname(key, opt)
                vm_piggy_data.setdefault(vm_name, []).append(vm_info)
            elif opt.vm_pwr_display == "esxhost" and not opt.direct:
                host_piggy_data.setdefault(running_on, []).append(vm_info)
            output.append(vm_info)

    if ("virtualmachine" in opt.modules and "hostsystem" in opt.modules and
            opt.host_pwr_display == "vm"):

        for key in vms:
            data = vms[key]
            running_on = hostsystems.get(data.get("runtime.host"), data.get("runtime.host"))
            vm_host = find_host(running_on, hostsystems_properties)
            if not vm_host:
                continue

            vm_info = "hostsystem\t%s\t\t%s" % (
                running_on, hostsystems_properties[vm_host]["runtime.powerState"][0])
            vm_name = convert_hostname(key, opt)
            vm_piggy_data.setdefault(vm_name, []).append(vm_info)

    for entries in [host_piggy_data, vm_piggy_data]:
        for key, values in entries.items():
            output += ["<<<<%s>>>>" % key, "<<<esx_vsphere_objects:sep(9)>>>", "\n".join(values)]
    output.append("<<<<>>>>")

    output += get_section_systemtime(connection, opt)

    return output


def call_legacy_pysphere():
    # TODO: Remove this, drop agent_vsphere.pysphere
    import subprocess

    path_vsphere_pysphere = os.path.dirname(os.path.abspath(__file__))
    cmd = ["%s/agent_vsphere.pysphere" % path_vsphere_pysphere] + sys.argv[1:]
    return subprocess.call(cmd)


#   .--Main----------------------------------------------------------------.
#   |                        __  __       _                                |
#   |                       |  \/  | __ _(_)_ __                           |
#   |                       | |\/| |/ _` | | '_ \                          |
#   |                       | |  | | (_| | | | | |                         |
#   |                       |_|  |_|\__,_|_|_| |_|                         |
#   |                                                                      |
#   +----------------------------------------------------------------------+


def main(argv=None):
    if argv is None:
        argv = sys.argv

    opt = parse_arguments(argv)

    # If the --pysphere option is set we use the legacy pysphere agent, though 50 times slower...
    if opt.pysphere:
        sys.exit(call_legacy_pysphere())

    socket.setdefaulttimeout(opt.timeout)

    if opt.tracefile:
        tracefile_dir = os.path.dirname(opt.tracefile) or "."
        if os.path.exists(tracefile_dir):
            opt.tracefile = file(opt.tracefile, "w")
        elif opt.debug:
            sys.stderr.write("Path for tracefile %s does not exist" % opt.tracefile)
            sys.stderr.flush()

    if opt.tracefile:
        opt.tracefile.write("Tracefile %s Host address: %s\n" %
                            (datetime.datetime.now().strftime("%Y-%m-%d %H:%M"), opt.host_address))

    try:
        esx_connection = ESXConnection(opt.host_address, opt.port, opt)

        # If the data aquisition fails, e.g. invalid cookie we try another run
        for _run_count in [0, 1]:
            esx_connection.login(opt.user, opt.secret)
            # Note: If the cookie fails inbetween these calls, we also start a second run
            try:
                vsphere_output = fetch_data(esx_connection, opt)
            except MKQueryServerException:
                # There was a problem during the query.
                # It is possible that the server cookie got invalid.
                # We delete the cookie and start a second run
                esx_connection.delete_server_cookie()
            else:
                break

    except Exception as exc:
        sys.stderr.write("%s\n" % exc)
        return 0 if opt.agent else 1

    write_output(vsphere_output, opt)

    return 0


if __name__ == "__main__":
    sys.exit(main())
