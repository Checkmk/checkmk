#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# .1.3.6.1.4.1.2620.1.16.22.1.1.1.1.0 0
# .1.3.6.1.4.1.2620.1.16.22.1.1.2.1.0 0
# .1.3.6.1.4.1.2620.1.16.22.1.1.3.1.0 "my_vsid"
# .1.3.6.1.4.1.2620.1.16.22.1.1.4.1.0 "VSX Gateway"
# .1.3.6.1.4.1.2620.1.16.22.1.1.5.1.0 "192.168.1.11"
# .1.3.6.1.4.1.2620.1.16.22.1.1.6.1.0 "Standard"
# .1.3.6.1.4.1.2620.1.16.22.1.1.7.1.0 "Active"
# .1.3.6.1.4.1.2620.1.16.22.1.1.8.1.0 "Trust established"
# .1.3.6.1.4.1.2620.1.16.22.1.1.9.1.0 "Standby"
# .1.3.6.1.4.1.2620.1.16.22.1.1.10.1.0 0
# .1.3.6.1.4.1.2620.1.16.23.1.1.1.1.0 0
# .1.3.6.1.4.1.2620.1.16.23.1.1.2.1.0 104470
# .1.3.6.1.4.1.2620.1.16.23.1.1.3.1.0 120147
# .1.3.6.1.4.1.2620.1.16.23.1.1.4.1.0 499900
# .1.3.6.1.4.1.2620.1.16.23.1.1.5.1.0 150512
# .1.3.6.1.4.1.2620.1.16.23.1.1.6.1.0 369
# .1.3.6.1.4.1.2620.1.16.23.1.1.7.1.0 150143
# .1.3.6.1.4.1.2620.1.16.23.1.1.8.1.0 0
# .1.3.6.1.4.1.2620.1.16.23.1.1.9.1.0 46451524
# .1.3.6.1.4.1.2620.1.16.23.1.1.10.1.0 44344
# .1.3.6.1.4.1.2620.1.16.23.1.1.11.1.0 0
# .1.3.6.1.4.1.2620.1.16.23.1.1.12.1.0 2386
# .1.3.6.1.4.1.2620.1.16.23.1.1.13.1.0 1

#   .--info----------------------------------------------------------------.
#   |                          _        __                                 |
#   |                         (_)_ __  / _| ___                            |
#   |                         | | '_ \| |_ / _ \                           |
#   |                         | | | | |  _| (_) |                          |
#   |                         |_|_| |_|_|  \___/                           |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'


@get_parsed_item_data
def check_checkpoint_vsx(item, _no_params, parsed):
    if not parsed:
        return

    for key, infotext in [
        ("vs_type", "Type"),
        ("vs_ip", "Main IP"),
    ]:

        value = parsed.get(key)
        if value is None:
            continue

        yield 0, "%s: %s" % (infotext, value)


check_info["checkpoint_vsx"] = {
    'inventory_function': discover(lambda k, values: "vs_name" in values),
    'check_function': check_checkpoint_vsx,
    'service_description': 'VS %s Info',
    'snmp_info': lambda oid: False, # migrated to cmk/base/plugins/agent_based/checkpoint_vsx.py
    'snmp_scan_function': lambda oid: False,  # already migrated!
}
#.
#   .--connections---------------------------------------------------------.
#   |                                        _   _                         |
#   |         ___ ___  _ __  _ __   ___  ___| |_(_) ___  _ __  ___         |
#   |        / __/ _ \| '_ \| '_ \ / _ \/ __| __| |/ _ \| '_ \/ __|        |
#   |       | (_| (_) | | | | | | |  __/ (__| |_| | (_) | | | \__ \        |
#   |        \___\___/|_| |_|_| |_|\___|\___|\__|_|\___/|_| |_|___/        |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'
factory_settings['checkpoint_vsx_default_levels'] = {
    'levels_perc': (90.0, 95.0),
}


@get_parsed_item_data
def check_checkpoint_vsx_connections(item, params, parsed):
    if not parsed:
        return

    conn_total = parsed.get("conn_num")
    if conn_total is None:
        return

    yield check_levels(conn_total,
                       "connections",
                       params.get("levels_abs"),
                       human_readable_func=int,
                       infoname="Used connections")

    conn_limit = parsed.get("conn_table_size")
    if conn_limit is None:
        return

    if conn_limit > 0:
        yield check_levels(100.0 * conn_total / conn_limit,
                           None,
                           params.get("levels_perc"),
                           human_readable_func=get_percent_human_readable,
                           infoname="Used percentage")


check_info["checkpoint_vsx.connections"] = {
    'inventory_function': discover(lambda k, values: "conn_num" in values),
    'check_function': check_checkpoint_vsx_connections,
    'service_description': 'VS %s Connections',
    'default_levels_variable': 'checkpoint_vsx_default_levels',
    'group': 'checkpoint_vsx_connections',
    'has_perfdata': True,
}
#.
#   .--packets-------------------------------------------------------------.
#   |                                   _        _                         |
#   |                  _ __   __ _  ___| | _____| |_ ___                   |
#   |                 | '_ \ / _` |/ __| |/ / _ \ __/ __|                  |
#   |                 | |_) | (_| | (__|   <  __/ |_\__ \                  |
#   |                 | .__/ \__,_|\___|_|\_\___|\__|___/                  |
#   |                 |_|                                                  |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'


@get_parsed_item_data
def check_checkpoint_vsx_packets(item, params, parsed):
    if not parsed:
        return

    for key, infotext in [
        ("packets", "Total number of packets processed"),
        ("packets_accepted", "Total number of accepted packets"),
        ("packets_dropped", "Total number of dropped packets"),
        ("packets_rejected", "Total number of rejected packets"),
        ("logged", "Total number of logs sent"),
    ]:

        value = parsed.get(key)
        if value is None:
            continue

        this_time = int(time.time())
        value_per_sec = get_rate("%s_rate" % key, this_time, value)

        yield check_levels(value_per_sec,
                           key,
                           params.get(key),
                           human_readable_func=int,
                           infoname=infotext,
                           unit="1/s")


check_info["checkpoint_vsx.packets"] = {
    'inventory_function': discover(lambda k, values: "packets" in values),
    'check_function': check_checkpoint_vsx_packets,
    'service_description': 'VS %s Packets',
    'group': 'checkpoint_vsx_packets',
    'has_perfdata': True,
}
#.
#   .--traffic-------------------------------------------------------------.
#   |                    _              __  __ _                           |
#   |                   | |_ _ __ __ _ / _|/ _(_) ___                      |
#   |                   | __| '__/ _` | |_| |_| |/ __|                     |
#   |                   | |_| | | (_| |  _|  _| | (__                      |
#   |                    \__|_|  \__,_|_| |_| |_|\___|                     |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'


@get_parsed_item_data
def check_checkpoint_vsx_traffic(item, params, parsed):
    if not parsed:
        return

    for key in [
        ("bytes_accepted"),
        ("bytes_dropped"),
        ("bytes_rejected"),
    ]:

        value = parsed.get(key)
        if value is None:
            continue

        this_time = int(time.time())
        value_per_sec = get_rate("%s_rate" % key, this_time, value)

        yield check_levels(
            value_per_sec,
            key,
            params.get(key),
            human_readable_func=get_bytes_human_readable,
            infoname="Total number of %s" % key.replace("_", " "),
            unit="1/s",
        )


check_info["checkpoint_vsx.traffic"] = {
    'inventory_function': discover(lambda k, values: "bytes_accepted" in values),
    'check_function': check_checkpoint_vsx_traffic,
    'service_description': 'VS %s Traffic',
    'group': 'checkpoint_vsx_traffic',
    'has_perfdata': True,
}
#.
#   .--status--------------------------------------------------------------.
#   |                         _        _                                   |
#   |                     ___| |_ __ _| |_ _   _ ___                       |
#   |                    / __| __/ _` | __| | | / __|                      |
#   |                    \__ \ || (_| | |_| |_| \__ \                      |
#   |                    |___/\__\__,_|\__|\__,_|___/                      |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'


@get_parsed_item_data
def check_checkpoint_vsx_status(item, _no_params, parsed):
    if not parsed:
        return

    ha_state = parsed.get("vs_ha_status")
    if ha_state is not None:
        state = 0
        if not ha_state.lower() in ['active', 'standby']:
            state = 2

        yield state, "HA Status: %s" % ha_state

    sic_state = parsed.get("vs_sic_status")
    if sic_state is not None:
        state = 0
        if sic_state.lower() != "trust established":
            state = 2

        yield state, "SIC Status: %s" % sic_state

    policy_name = parsed.get("vs_policy")
    if policy_name is not None:
        yield 0, "Policy name: %s" % policy_name

    policy_type = parsed.get("vs_policy_type")
    if policy_type is not None:
        state = 0
        infotext = "Policy type: %s" % policy_type
        if policy_type.lower() not in ["active", "initial policy"]:
            state = 2
            infotext += " (no policy installed)"
        yield state, infotext


check_info["checkpoint_vsx.status"] = {
    'inventory_function': discover(lambda k, values: "vs_ha_status" in values),
    'check_function': check_checkpoint_vsx_status,
    'service_description': 'VS %s Status',
    'group': 'checkpoint_vsx_traffic_status',
}
#.
