#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 Checkmk GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.22 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.23 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.470 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.471 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.472 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.473 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.113000022 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.113000470 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.113000471 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.116000022 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.116000470 2
# .1.3.6.1.4.1.9.9.117.1.1.2.1.2.116000471 2

# .1.3.6.1.2.1.47.1.1.1.1.7.10 Fabric [VPC domain:12]
# .1.3.6.1.2.1.47.1.1.1.1.7.22 Nexus 56128P Supervisor in Fixed Module-1
# .1.3.6.1.2.1.47.1.1.1.1.7.23 24 ports 10GE SFP+ and 2xQSFP ports Ethernet Module
# .1.3.6.1.2.1.47.1.1.1.1.7.149 Nexus 56128P Chassis
# .1.3.6.1.2.1.47.1.1.1.1.7.214 Fixed Slot-1
# .1.3.6.1.2.1.47.1.1.1.1.7.215 Module Slot-2
# .1.3.6.1.2.1.47.1.1.1.1.7.216 Module Slot-3
# .1.3.6.1.2.1.47.1.1.1.1.7.278 PowerSupplyBay-1
# .1.3.6.1.2.1.47.1.1.1.1.7.279 PowerSupplyBay-2
# .1.3.6.1.2.1.47.1.1.1.1.7.280 PowerSupplyBay-3
# .1.3.6.1.2.1.47.1.1.1.1.7.281 PowerSupplyBay-4
# .1.3.6.1.2.1.47.1.1.1.1.7.342 FanBay-1
# .1.3.6.1.2.1.47.1.1.1.1.7.343 FanBay-2
# .1.3.6.1.2.1.47.1.1.1.1.7.344 FanBay-3
# .1.3.6.1.2.1.47.1.1.1.1.7.345 FanBay-4
# .1.3.6.1.2.1.47.1.1.1.1.7.470 PowerSupply-1
# .1.3.6.1.2.1.47.1.1.1.1.7.471 PowerSupply-2
# .1.3.6.1.2.1.47.1.1.1.1.7.472 PowerSupply-3
# .1.3.6.1.2.1.47.1.1.1.1.7.473 PowerSupply-4
# .1.3.6.1.2.1.47.1.1.1.1.7.534 FanModule-1
# .1.3.6.1.2.1.47.1.1.1.1.7.535 FanModule-2
# .1.3.6.1.2.1.47.1.1.1.1.7.536 FanModule-3
# .1.3.6.1.2.1.47.1.1.1.1.7.537 FanModule-4
# .1.3.6.1.2.1.47.1.1.1.1.7.538 PowerSupply-1 Fan-1
# .1.3.6.1.2.1.47.1.1.1.1.7.539 PowerSupply-1 Fan-2
# .1.3.6.1.2.1.47.1.1.1.1.7.540 PowerSupply-2 Fan-1
# .1.3.6.1.2.1.47.1.1.1.1.7.541 PowerSupply-2 Fan-2
# ...

from collections.abc import Container, Iterable, Mapping
from dataclasses import dataclass
from itertools import groupby
from typing import Final, List, Optional

from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import StringTable

DiscoveryResult = Iterable[tuple[str, dict]]
CheckResult = Iterable[tuple[int, str]]


@dataclass(frozen=True)
class FRU:
    state: int
    current: int


Section = Mapping[str, FRU]

_STATE_MAP: Final = {
    1: (1, "off env other"),
    2: (0, "on"),
    3: (1, "off admin"),
    4: (2, "off denied"),
    5: (2, "off env power"),
    6: (2, "off env temp"),
    7: (2, "off env fan"),
    8: (2, "failed"),
    9: (1, "on but fan fail"),
    10: (1, "off cooling"),
    11: (1, "off connector rating"),
    12: (2, "on but inline power fail"),
}


def parse_cisco_fru_power(string_table: List[StringTable]) -> Section:
    states_and_currents, names = string_table

    raw_states = {oid_end: oper_state for oid_end, oper_state, _current in states_and_currents}
    raw_currents = {oid_end: current for oid_end, _oper_state, current in states_and_currents}

    name_map = _oid_name_map(names, raw_states)

    frus = [
        (name, _make_fru(raw_states[oid_end], raw_currents[oid_end]))
        for name, oid_end in name_map.items()
    ]
    return {name: fru for name, fru in frus if fru and _is_real_psu(fru)}


def _make_fru(raw_state: str, raw_current: str) -> Optional[FRU]:
    try:
        return FRU(state=int(raw_state), current=int(raw_current))
    except ValueError:
        return None


def _is_real_psu(fru: FRU) -> bool:
    # We discover only "real" power supplies which have current value >= 0
    # Others such as modules do not have such values
    return fru.state != 0 and fru.current >= 0


def _oid_name_map(names: StringTable, filter_oids: Container[str]) -> Mapping[str, str]:
    end_by_name = {}
    for name, oid_ends_names in groupby(sorted(names, key=lambda x: x[1]), key=lambda x: x[1]):
        oid_ends = [oe for oe, _name in oid_ends_names if oe in filter_oids]
        for num, oid_end in enumerate(oid_ends, start=1):
            end_by_name[name if len(oid_ends) == 1 else f"{name}-{num}"] = oid_end
    return end_by_name


def discover_cisco_fru_power(section: Section) -> DiscoveryResult:
    yield from ((item, {}) for item, fru in section.items() if fru.state not in (1, 3))


def check_cisco_fru_power(item: str, _no_params: object, section: Section) -> CheckResult:
    if (fru := section.get(item)) is None:
        return

    state, state_readable = _STATE_MAP.get(fru.state, (3, f"unexpected ({fru.state})"))
    yield state, "Status: %s" % state_readable


check_info["cisco_fru_power"] = {
    "parse_function": parse_cisco_fru_power,
    "inventory_function": discover_cisco_fru_power,
    "check_function": check_cisco_fru_power,
    "service_description": "FRU Power %s",
    "snmp_info": [
        (
            ".1.3.6.1.4.1.9.9.117.1.1.2.1",
            [
                OID_END,
                "2",  # CISCO-ENTITY-FRU-CONTROL-MIB::cefcFRUPowerOperStatus
                "3",  # CISCO-ENTITY-FRU-CONTROL-MIB::cefcFRUCurrent
            ],
        ),
        (
            ".1.3.6.1.2.1.47.1.1.1.1",
            [
                OID_END,
                CACHED_OID(7),  # ENTITY-MIB::entPhysicalName
            ],
        ),
    ],
    # Exclude cisco_power check
    "snmp_scan_function": lambda oid: "cisco" in oid(".1.3.6.1.2.1.1.1.0").lower()
    and not oid(".1.3.6.1.4.1.9.9.13.1.5.1.*"),
}
