#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# Functions and definitions used by if and if64
if_inventory_porttypes = [
    '6', '32', '62', '117', '127', '128', '129', '180', '181', '182', '205', '229'
]
if_inventory_portstates = ['1']
if_inventory_uses_description = False
if_inventory_uses_alias = False
if_inventory_pad_portnumbers = True
if_inventory_monitor_speed = True
if_inventory_monitor_state = True
inventory_if_rules = []
factory_settings["if_default_levels"] = {
    "errors": (0.01, 0.1),
}

# Grouping of if ports
#if_groups = [
#   ( [{"name" : "VLAN", "iftype" : 53, "single" : True}], [ ], ALL_HOSTS ),
#   ( [{"name" : "Group WLAN", "iftype" : 6, "single" : True}], [ "lan" ], ALL_HOSTS )
#   ]

#
if_groups = []
# Obsolete variable, but needed as contained in autochecks of
# older checks. We need to keep this up for a few years...
if_default_error_levels = factory_settings["if_default_levels"]["errors"]
if_default_traffic_levels = None, None
if_default_average = None
if_disable_if64_hosts = []  # Binary host list for disabling if64 on some broken devices

Interface = collections.namedtuple("Interface", [
    "ifIndex",
    "ifGroup",
    "ifDescr",
    "ifType",
    "ifSpeed",
    "ifOperStatus",
    "ifOperStatusName",
    "ifInOctets",
    "inucast",
    "inmcast",
    "inbcast",
    "ifInDiscards",
    "ifInErrors",
    "ifOutOctets",
    "outucast",
    "outmcast",
    "outbcast",
    "ifOutDiscards",
    "ifOutErrors",
    "ifOutQLen",
    "ifAlias",
    "ifPhysAddress",
])


def interface_from(line):
    (ifIndex, ifDescr, ifType, ifSpeed, ifOperStatus, ifInOctets, inucast, inmcast, inbcast,
     ifInDiscards, ifInErrors, ifOutOctets, outucast, outmcast, outbcast, ifOutDiscards,
     ifOutErrors, ifOutQLen, ifAlias, ifPhysAddress) = line

    # Windows NICs sends pairs of ifOperStatus and its Windows-Name instead
    # of just the ifOperStatus
    if isinstance(ifOperStatus, tuple):
        ifOperStatus, ifOperStatusName = ifOperStatus
    else:
        ifOperStatusName = if_statename(ifOperStatus)

    ifGroup = None
    if isinstance(ifIndex, tuple):
        ifGroup, ifIndex = ifIndex

    # Fix bug in TP Link switches
    ifSpeed = saveint(ifSpeed)
    if ifSpeed > 9 * 1000 * 1000 * 1000 * 1000:
        ifSpeed /= 1000000

    ifDescr = cleanup_if_strings(ifDescr)
    ifAlias = cleanup_if_strings(ifAlias)
    return Interface(ifIndex, ifGroup, ifDescr, ifType, ifSpeed, ifOperStatus, ifOperStatusName,
                     ifInOctets, inucast, inmcast, inbcast, ifInDiscards, ifInErrors, ifOutOctets,
                     outucast, outmcast, outbcast, ifOutDiscards, ifOutErrors, ifOutQLen, ifAlias,
                     ifPhysAddress)


#
#    +-----------------------------------------------------------------------------+
#    |                            __                  _   _                        |
#    |     ___  ___ __ _ _ __    / _|_   _ _ __   ___| |_(_) ___  _ __  ___        |
#    |    / __|/ __/ _` | '_ \  | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|       |
#    |    \__ \ (_| (_| | | | | |  _| |_| | | | | (__| |_| | (_) | | | \__ \       |
#    |    |___/\___\__,_|_| |_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/       |
#    |                                                                             |
#    |                                                                             |
#    +-----------------------------------------------------------------------------+
#
def has_ifHCInOctets(oid):
    return bool(oid(".1.3.6.1.2.1.31.1.1.1.6.*"))


def if64_disabled(hostname):
    return in_binary_hostlist(hostname, if_disable_if64_hosts)


def need_if64adm():
    settings = host_extra_conf_merged(host_name(), inventory_if_rules)
    return "portstates" in settings and '9' in settings["portstates"]


# END OF SCAN FUNCTION STUFF


def fix_if_64_highspeed(info):
    for line in info:
        # TODO: Use six.string_types when this is a module.
        if isinstance(line[3], six.string_types):  # not yet converted
            line[3] = saveint(line[3]) * 1000000


# Remove 0 bytes from strings. They lead to problems e.g. here:
# On windows hosts the labels of network interfaces in oid
# iso.3.6.1.2.1.2.2.1.2.1 are given as hex strings with tailing
# 0 byte. When this string is part of the data which is sent to
# the nagios pipe all chars after the 0 byte are stripped of.
# Stupid fix: Remove all 0 bytes. Hope this causes no problems.
def cleanup_if_strings(s):
    if s and s != '':
        return "".join([c for c in s if c not in nagios_illegal_chars + chr(0)]).strip()
    return s


# This variant of int() lets the string if its not
# convertable. Useful for parsing dict-like things, where
# some of the values are int.
def tryint(x):
    try:
        return int(x)
    except (TypeError, ValueError):
        return x


# make sure, that configuration variable is present in precompiled host checks
check_config_variables.append("nagios_illegal_chars")


# Name of state (lookup SNMP enum)
def if_statename(st):
    names = {
        '1': 'up',
        '2': 'down',
        '3': 'testing',
        '4': 'unknown',
        '5': 'dormant',
        '6': 'not present',
        '7': 'lower layer down',
        '8': 'degraded',
        '9': 'admin down',
    }
    return names.get(st, st)


def if_extract_node(line, has_nodeinfo):
    if has_nodeinfo:
        return line[0], line[1:]
    return None, line


def if_render_mac_address(ifPhysAddress):
    if not isinstance(ifPhysAddress, list):
        mac_bytes = map(ord, ifPhysAddress)
    else:
        mac_bytes = ifPhysAddress
    return (":".join(["%02s" % hex(m)[2:] for m in mac_bytes]).replace(' ', '0')).upper()


def if_item_matches(item, ifIndex, ifAlias, ifDescr):
    return item.lstrip("0") == ifIndex \
            or (item == "0" * len(item) and saveint(ifIndex) == 0) \
            or item == ifAlias \
            or item == ifDescr \
            or item == "%s %s" % (ifAlias, ifIndex) \
            or item == "%s %s" % (ifDescr, ifIndex)


# Pads port numbers with zeroes, so that items
# nicely sort alphabetically
def if_pad_with_zeroes(info, ifIndex, has_nodeinfo, pad_portnumbers):
    if has_nodeinfo:
        index = 1
    else:
        index = 0
    if pad_portnumbers:

        def get_index(line):
            if isinstance(line[index], tuple):
                return line[index][1]
            return line[index]

        max_index = max([int(get_index(line)) for line in info])
        digits = len(str(max_index))
        return ("%0" + str(digits) + "d") % int(ifIndex)
    return ifIndex


def if_get_traffic_levels(params):
    # Transform old style traffic parameters to new CascadingDropdown based data format
    new_traffic = []
    if 'traffic' in params and not isinstance(params['traffic'], list):
        warn, crit = params['traffic']
        if warn is None:
            new_traffic.append(('both', ('upper', (None, (None, None)))))
        elif isinstance(warn, int):
            new_traffic.append(('both', ('upper', ('abs', (warn, crit)))))
        elif isinstance(warn, float):
            new_traffic.append(('both', ('upper', ('perc', (warn, crit)))))

    if 'traffic_minimum' in params:
        warn, crit = params['traffic_minimum']
        if isinstance(warn, int):
            new_traffic.append(('both', ('lower', ('abs', (warn, crit)))))
        elif isinstance(warn, float):
            new_traffic.append(('both', ('lower', ('perc', (warn, crit)))))
        del params['traffic_minimum']

    if new_traffic:
        traffic_levels = new_traffic
    else:
        traffic_levels = params.get('traffic', [])

    # Now bring the levels in a structure which is easily usable for the check
    # and also convert direction="both" to single in/out entries
    levels = {
        ('in', 'upper'): (None, (None, None)),
        ('out', 'upper'): (None, (None, None)),
        ('in', 'lower'): (None, (None, None)),
        ('out', 'lower'): (None, (None, None)),
    }
    for level in traffic_levels:
        traffic_dir = level[0]
        up_or_low = level[1][0]
        level_type = level[1][1][0]
        level_value = level[1][1][1]

        if traffic_dir == 'both':
            levels[('in', up_or_low)] = (level_type, level_value)
            levels[('out', up_or_low)] = (level_type, level_value)
        else:
            levels[(traffic_dir, up_or_low)] = (level_type, level_value)

    return levels


def get_specific_traffic_levels(general_traffic_levels, unit, ref_speed, assumed_speed_in,
                                assumed_speed_out):
    traffic_levels = {}
    for (traffic_dir, up_or_low), (level_type, levels) in general_traffic_levels.items():
        if not isinstance(levels, tuple):
            traffic_levels[(traffic_dir, 'predictive')] = levels
            traffic_levels[(traffic_dir, up_or_low, 'warn')] = None
            traffic_levels[(traffic_dir, up_or_low, 'crit')] = None
            continue  # don't convert predictive levels config
        else:
            warn, crit = levels

        for what, level_value in [('warn', warn), ('crit', crit)]:
            # If the measurement unit is set to bit and the bw levels
            # are of type absolute, convert these 'bit' entries to byte
            # still reported as bytes to stay compatible with older rrd data
            if unit == 'Bit' and level_type == 'abs':
                level_value = level_value // 8
            elif level_type == 'perc':
                # convert percentages to absolute values. Use either the assumed speed
                # or the reference speed. When none of both are available, ignore
                # the percentual levels
                if traffic_dir == 'in' and assumed_speed_in:
                    level_value = level_value / 100.0 * assumed_speed_in / 8
                elif traffic_dir == 'out' and assumed_speed_out:
                    level_value = level_value / 100.0 * assumed_speed_out / 8
                elif ref_speed:
                    level_value = level_value / 100.0 * ref_speed
                else:
                    level_value = None

            traffic_levels[(traffic_dir, up_or_low, what)] = level_value  # bytes
    return traffic_levels


def _prepare_if_group_patterns_from_conf():
    group_patterns = {}
    for line in host_extra_conf(host_name(), if_groups):
        for entry in line:
            if entry.get("name"):
                group_name = entry["name"]
            elif entry.get("group_name"):
                group_name = entry["group_name"]

            if entry.get("single") is not None:
                if entry["single"]:
                    group_presence = "instead"
                else:
                    group_presence = "separate"
            else:
                group_presence = entry["group_presence"]

            group_patterns.setdefault(group_name, {
                "group_presence": group_presence,
                "group_patterns": {},
            })

            this_group = group_patterns[group_name]

            if "node_patterns" in entry:
                this_group.setdefault("group_type", "cluster")
                for cl_pattern in entry.get("node_patterns", []):
                    this_pattern = cl_pattern.copy()
                    del this_pattern["node_name"]
                    this_group["group_patterns"].setdefault(cl_pattern["node_name"], this_pattern)

            else:
                this_group.setdefault("group_type", "single_host")
                this_group["group_patterns"].setdefault(host_name(), {})
                if entry.get("include_items"):
                    this_group["group_patterns"][host_name()].setdefault(
                        "items", entry["include_items"])
                elif entry.get("items"):
                    this_group["group_patterns"][host_name()].setdefault("items", entry["items"])
                if entry.get("iftype"):
                    this_group["group_patterns"][host_name()].setdefault("iftype", entry["iftype"])

    return group_patterns


def _uses_description_and_alias(settings):
    uses_description = settings.get('use_desc', if_inventory_uses_description)
    if uses_description:
        return True, False

    uses_alias = settings.get('use_alias', if_inventory_uses_alias)
    if uses_alias:
        return False, True

    item_appearance = settings.get('item_appearance', if_inventory_uses_description)
    if item_appearance == 'descr':
        return True, False
    if item_appearance == 'alias':
        return False, True
    return False, False


def _group_pattern_matches(host_name, item, if_type, group_attributes):
    if host_name not in group_attributes["group_patterns"]:
        return False

    group_iftype = group_attributes["group_patterns"][host_name].get("iftype")
    if group_iftype is not None and saveint(group_iftype) != saveint(if_type):
        return False

    group_items = group_attributes["group_patterns"][host_name].get("items")
    if group_items is not None and tryint(item) not in map(tryint, group_items):
        return False

    return True


def inventory_if_common(info, has_nodeinfo=False):
    if has_nodeinfo:
        length = 21
    else:
        length = 20
    if len(info) == 0 or len(info[0]) != length:
        return []

    settings_sets = host_extra_conf(host_name(), inventory_if_rules)
    seen_indicies = set()
    pre_inventory = []
    duplicates = set()

    if not settings_sets:
        # if there are no settings, use defaults
        settings_sets.append({})

    def port_match(name, what):
        if what is None:
            return True
        for r in what:
            if regex(r).match(name):
                return True
        return False

    current_host_name = host_name()
    group_patterns = _prepare_if_group_patterns_from_conf()
    for settings in settings_sets:
        global_seen_items = set()
        uses_description, uses_alias = _uses_description_and_alias(settings)
        # Need to copy porttypes as the discovery function appends to the list below.
        # The check must not modify the global if_inventory_porttypes configuration variable.
        porttypes = settings.get('porttypes', if_inventory_porttypes)[:]
        portstates = settings.get('portstates', if_inventory_portstates)
        match_alias = settings.get('match_alias')
        match_desc = settings.get('match_desc')
        pad_portnumbers = settings.get('pad_portnumbers', if_inventory_pad_portnumbers)

        # Allow main check to set no port type (e.g. hitachi_hnas_fc_if)
        porttypes.append("")
        have_groups = {}

        # Determine whether single, grouped or both
        for line in info:
            _node, line = if_extract_node(line, has_nodeinfo)
            interface = interface_from(line)

            # Fix bug in brocade switches
            if interface.ifIndex == '':
                continue

            # compute item now - also for unmonitored ports - in order to see if it is unique.
            if uses_description and interface.ifDescr:
                item = interface.ifDescr
            elif uses_alias and interface.ifAlias:
                item = interface.ifAlias
            else:
                item = if_pad_with_zeroes(info, interface.ifIndex, has_nodeinfo, pad_portnumbers)

            if item not in global_seen_items:
                global_seen_items.add(item)
            else:
                duplicates.add(item)

            # Prepare grouped interfaces
            discover_single_interface = True
            for group_name, attrs in group_patterns.items():
                if not _group_pattern_matches(current_host_name, item, interface.ifType, attrs):
                    continue

                if attrs["group_presence"] == "instead":
                    discover_single_interface = False

                have_groups.setdefault(group_name, {
                    "group_type": attrs["group_type"],
                    "group_patterns": attrs["group_patterns"],
                })

                # If we're on a cluster, we have no chance calculating expected speed
                if attrs["group_type"] == "single_host":
                    have_groups[group_name].setdefault("interfaces", [])
                    have_groups[group_name]["interfaces"].append(
                        (saveint(interface.ifSpeed), interface.ifOperStatus, interface.ifType))

            # The agent output already set this interface to grouped
            if interface.ifGroup:
                have_groups.setdefault(
                    interface.ifGroup, {
                        "interfaces": [],
                        "group_type": "single_host",
                        "group_patterns": {
                            current_host_name: {
                                "items": [],
                                "iftype": interface.ifType
                            }
                        },
                    })
                have_groups[interface.ifGroup]["interfaces"].append(
                    (saveint(interface.ifSpeed), interface.ifOperStatus, interface.ifType))

            # Prepare single interfaces
            if discover_single_interface and interface.ifIndex not in seen_indicies and \
               interface.ifType in porttypes and interface.ifOperStatus in portstates and \
               port_match(interface.ifAlias, match_alias) and port_match(interface.ifDescr, match_desc):
                params = {}
                if if_inventory_monitor_state:
                    params["state"] = [interface.ifOperStatus]

                if interface.ifSpeed != "" and if_inventory_monitor_speed:
                    params["speed"] = int(interface.ifSpeed)
                seen_indicies.add(interface.ifIndex)

                try:
                    index_as_item = int(item) == int(interface.ifIndex)
                except (TypeError, ValueError):
                    index_as_item = False
                pre_inventory.append((item, "%r" % params, int(interface.ifIndex), index_as_item))

        # Create pseudo interfaces out of groups
        # On cluster groups we have no 'interfaces' key
        for group_name, attrs in have_groups.items():
            group_type = attrs["group_type"]

            if group_type == "cluster":
                append_to_pre_inventory = True

            else:
                # total maximum speed of all interfaces in this group
                total_speed = sum([pair[0] for pair in attrs["interfaces"]])
                # operation status, default is down(2)
                # if at least one is up(1) then up is considered as valid
                one_up = "1" in [pair[1] for pair in attrs["interfaces"]]
                group_operStatus = "1" if one_up else "2"
                append_to_pre_inventory = group_operStatus in portstates

            if append_to_pre_inventory:
                params = {"aggregate": {}}
                if attrs.get("group_patterns"):
                    params["aggregate"]["group_patterns"] = attrs["group_patterns"]

                if uses_description:
                    params["aggregate"]["item_type"] = "description"
                elif uses_alias:
                    params["aggregate"]["item_type"] = "alias"
                else:
                    params["aggregate"]["item_type"] = "index"

                if group_type == "single_host" and if_inventory_monitor_state:
                    params["state"] = [group_operStatus]

                if group_type == "single_host" and if_inventory_monitor_speed:
                    params["speed"] = total_speed

                # Note: the group interface index is always set to 1
                pre_inventory.append((group_name, "%r" % params, 1, False))

    inventory = []
    # Check for duplicate items (e.g. when using Alias as item and the alias is not unique)
    for item, params, index, index_as_item in pre_inventory:
        if not index_as_item and item in duplicates:
            new_item = "%s %d" % (item, index)
        else:
            new_item = item
        inventory.append((new_item, params))

    return inventory


def _convert_old_if_group_params(params):
    if params["aggregate"] is True:
        del params["aggregate"]
        params.setdefault("aggregate", {})
        params["aggregate"].setdefault("group_patterns", {})
        params["aggregate"]["group_patterns"].setdefault(host_name(), {})

        for old_key, new_key in [
            ("include_items", "items"),
            ("iftype", "iftype"),
        ]:
            if params.get(old_key) is not None:
                params["aggregate"]["group_patterns"][host_name()].setdefault(
                    new_key, params[old_key])
                del params[old_key]

        if params.get("aggr_member_item") is not None:
            params["aggregate"].setdefault("item_type", params["aggr_member_item"])
            del params["aggr_member_item"]

    return params


def check_if_common(item, params, info, has_nodeinfo=False, group_name="Group", timestamp=None):
    if timestamp is None:
        this_time = time.time()
    else:
        this_time = timestamp

    if not params.get("aggregate"):
        return check_if_common_single(item,
                                      params,
                                      info,
                                      has_nodeinfo=has_nodeinfo,
                                      timestamp=this_time)

    # If this item is in an ifgroup create a pseudo interface and
    # pass its data to the common instance.
    # This is done by simply adding the additional group_info data
    # to the already existing info table.
    params = _convert_old_if_group_params(params)
    group_members = {}
    matching_interfaces = []

    for element in info:
        node, line = if_extract_node(element, has_nodeinfo)
        interface = interface_from(line)

        service_name_type = params["aggregate"].get("item_type")
        if service_name_type == "description":
            if_member_item = interface.ifDescr
        elif service_name_type == "alias":
            if_member_item = interface.ifAlias
        else:  # index
            pad_portnumbers = item[0] == '0'
            if_member_item = if_pad_with_zeroes(info, interface.ifIndex, has_nodeinfo,
                                                pad_portnumbers)

        if interface.ifGroup and interface.ifGroup == item:
            matching_interfaces.append((if_member_item, element))

        else:
            if node is None:
                node = host_name()

            if node not in params["aggregate"]["group_patterns"]:
                continue

            attrs = params["aggregate"]["group_patterns"][node]
            node_items = attrs.get("items")
            iftype = attrs.get("iftype")

            # The iftype and node_items parameters are further restrictions
            # If none of them are set, the interface is added to the group
            # tryint -> force "01" and "1" to be identical.
            add_interface = True  # This approach is easier to comprehend..

            if node_items is not None and \
                tryint(if_member_item) not in map(tryint, node_items):
                add_interface = False

            if iftype is not None and \
                not saveint(interface.ifType) == saveint(iftype):
                add_interface = False

            this_element = (if_member_item, element)
            if add_interface and this_element not in matching_interfaces:
                matching_interfaces.append(this_element)

    # TODO Now we're done and have all matching interfaces
    # Accumulate info over matching_interfaces
    wrapped = False

    group_info = {
        "ifSpeed": 0,
        "ifInOctets": 0,
        "inucast": 0,
        "inmcast": 0,
        "inbcast": 0,
        "ifInDiscards": 0,
        "ifInErrors": 0,
        "ifOutOctets": 0,
        "outucast": 0,
        "outmcast": 0,
        "outbcast": 0,
        "ifOutDiscards": 0,
        "ifOutErrors": 0,
        "ifOutQLen": 0,
    }

    num_up = 0
    for (if_member_item, element) in matching_interfaces:
        node, line = if_extract_node(element, has_nodeinfo)
        interface = interface_from(line)

        # Append an additional entry to the info table containing the calculated group_info
        if interface.ifOperStatus == '1':
            num_up += 1

        group_members.setdefault(node, [])
        group_members[node].append({
            "name": if_member_item,
            "state": interface.ifOperStatus,
            "state_name": interface.ifOperStatusName,
        })

        # Only these values are packed into counters
        # We might need to enlarge this table
        # However, more values leads to more MKCounterWrapped...
        for name, counter in [
            ("in", interface.ifInOctets),
            ("inucast", interface.inucast),
            ("inmcast", interface.inmcast),
            ("inbcast", interface.inbcast),
            ("indisc", interface.ifInDiscards),
            ("inerr", interface.ifInErrors),
            ("out", interface.ifOutOctets),
            ("outucast", interface.outucast),
            ("outmcast", interface.outmcast),
            ("outbcast", interface.outbcast),
            ("outdisc", interface.ifOutDiscards),
            ("outerr", interface.ifOutErrors),
        ]:
            try:
                get_rate("if.%s.%s.%s" % (name, item, if_member_item),
                         this_time,
                         saveint(counter),
                         onwrap=RAISE)
            except MKCounterWrapped:
                wrapped = True
                # continue, other counters might wrap as well

        # Add interface info to group info
        group_info["ifSpeed"] += interface.ifOperStatus == "1" and interface.ifSpeed or 0
        group_info["ifInOctets"] += saveint(interface.ifInOctets)
        group_info["inucast"] += saveint(interface.inucast)
        group_info["inmcast"] += saveint(interface.inmcast)
        group_info["inbcast"] += saveint(interface.inbcast)
        group_info["ifInDiscards"] += saveint(interface.ifInDiscards)
        group_info["ifInErrors"] += saveint(interface.ifInErrors)
        group_info["ifOutOctets"] += saveint(interface.ifOutOctets)
        group_info["outucast"] += saveint(interface.outucast)
        group_info["outmcast"] += saveint(interface.outmcast)
        group_info["outbcast"] += saveint(interface.outbcast)
        group_info["ifOutDiscards"] += saveint(interface.ifOutDiscards)
        group_info["ifOutErrors"] += saveint(interface.ifOutErrors)
        group_info["ifOutQLen"] += saveint(interface.ifOutQLen)
        # This is the fallback ifType if None is set in the parameters
        group_info["ifType"] = interface.ifType

    if num_up == len(matching_interfaces):
        group_operStatus = "1"  # up
    elif num_up > 0:
        group_operStatus = "8"  # degraded
    else:
        group_operStatus = "2"  # down

    alias_info = []
    add_node_info = len(params["aggregate"].get("group_patterns", {})) >= 2

    for node_name, attrs in params["aggregate"].get("group_patterns", {}).items():
        if attrs.get("iftype"):
            alias_info.append("%sif type %s" % \
                                (add_node_info and "Node %s: " % node_name or "",
                                attrs["iftype"]))
            group_info["ifType"] = attrs["iftype"]

        if attrs.get("items"):
            alias_info.append("%d grouped interfaces" % len(matching_interfaces))

    if has_nodeinfo:
        group_entry = [None]
    else:
        group_entry = []

    group_entry += [
        "ifgroup%s" % item,  # ifIndex
        item,  # ifDescr
        group_info["ifType"],  # ifType
        group_info["ifSpeed"],  # ifSpeed
        group_operStatus,  # ifOperStatus
        group_info["ifInOctets"],  # ifInOctets
        group_info["inucast"],  # inucast
        group_info["inmcast"],  # inmcast
        group_info["inbcast"],  # inbcast
        group_info["ifInDiscards"],  # ifInDiscards
        group_info["ifInErrors"],  # ifInErrors
        group_info["ifOutOctets"],  # ifOutOctets
        group_info["outucast"],  # outucast
        group_info["outmcast"],  # outmcast
        group_info["outbcast"],  # outbcast
        group_info["ifOutDiscards"],  # ifOutDiscards
        group_info["ifOutErrors"],  # ifOutErrors
        group_info["ifOutQLen"],  # ifOutQLen
        ", ".join(alias_info),
        "",  # ifPhysAddress
    ]

    # If applicable, signal the check_if_common_single if the counter of the
    # given interface has wrapped. Actually a wrap of the if group itself is unlikely,
    # however any counter wrap of one of its members causes the accumulation being invalid
    return check_if_common_single(item,
                                  params, [group_entry],
                                  wrapped,
                                  has_nodeinfo=has_nodeinfo,
                                  group_members=group_members,
                                  group_name=group_name,
                                  timestamp=this_time)


# TODO: Check what the relationship between Errors, Discards, and ucast/mcast actually is.
# One case of winperf_if appeared to indicate that in that case Errors = Discards.
def check_if_common_single(item,
                           params,
                           info,
                           force_counter_wrap=False,
                           has_nodeinfo=False,
                           group_members=None,
                           group_name="Group",
                           timestamp=None):

    if timestamp is None:
        this_time = time.time()
    else:
        this_time = timestamp

    # Params now must be a dict. Some keys might
    # be set to None
    targetspeed = params.get("speed")
    assumed_speed_in = params.get("assumed_speed_in")
    assumed_speed_out = params.get("assumed_speed_out")
    targetstates = params.get("state")
    map_operstates = dict(params.get("map_operstates", []))
    average = params.get("average")
    unit = "Bit" if params.get("unit") in ["Bit", "bit"] else "B"
    cluster_items = {}

    # error checking might be turned off
    err_warn, err_crit = params.get("errors", (None, None))
    err_in_warn, err_in_crit = params.get("errors_in", (err_warn, err_crit))
    err_out_warn, err_out_crit = params.get("errors_out", (err_warn, err_crit))

    # broadcast storm detection is turned off by default
    if "nucasts" in params:
        nucast_warn, nucast_crit = params["nucasts"]
    else:
        nucast_warn, nucast_crit = None, None

    if "discards" in params:
        disc_warn, disc_crit = params["discards"]
    else:
        disc_warn, disc_crit = None, None

    # Convert the traffic related levels to a common format
    general_traffic_levels = if_get_traffic_levels(params)

    for line in info:
        node, line = if_extract_node(line, has_nodeinfo)
        interface = interface_from(line)

        if not if_item_matches(item, interface.ifIndex, interface.ifAlias, interface.ifDescr):
            continue

        if group_members:
            # The detailed group info is added later on
            infotext = group_name + " Status "
        else:
            if "infotext_format" in params:
                bracket_info = ""
                if params["infotext_format"] == "alias":
                    bracket_info = interface.ifAlias
                elif params["infotext_format"] == "description":
                    bracket_info = interface.ifDescr
                elif params["infotext_format"] == "alias_and_description":
                    bracket_info = ", ".join(
                        [i for i in [interface.ifAlias, interface.ifDescr] if i])
                elif params["infotext_format"] == "alias_or_description":
                    bracket_info = interface.ifAlias if interface.ifAlias else interface.ifDescr
                elif params["infotext_format"] == "desription_or_alias":
                    bracket_info = interface.ifDescr if interface.ifDescr else interface.ifAlias

                if bracket_info:
                    infotext = "[%s]" % bracket_info
                else:
                    infotext = ""
            else:
                # Display port number or alias in infotext if that is not part
                # of the service description anyway
                if item.lstrip("0") == interface.ifIndex \
                    and (item == interface.ifAlias or interface.ifAlias == '') \
                    and (item == interface.ifDescr or interface.ifDescr == ''): # description trivial
                    infotext = ""
                elif item == "%s %s" % (interface.ifAlias, interface.ifIndex
                                       ) and interface.ifDescr != '':  # non-unique Alias
                    infotext = "[%s/%s]" % (interface.ifAlias, interface.ifDescr)
                elif item != interface.ifAlias and interface.ifAlias != '':  # alias useful
                    infotext = "[%s] " % interface.ifAlias
                elif item != interface.ifDescr and interface.ifDescr != '':  # description useful
                    infotext = "[%s] " % interface.ifDescr
                else:
                    infotext = "[%s] " % interface.ifIndex

            if node is not None:
                infotext = "%son %s: " % (infotext, node)

        state = 0
        infotext += "(%s)" % interface.ifOperStatusName
        if targetstates and (
                interface.ifOperStatus != targetstates and
                not (isinstance(targetstates,
                                (list, tuple)) and interface.ifOperStatus in targetstates)):
            state = 2

        if map_operstates and interface.ifOperStatus in map_operstates:
            state = map_operstates[interface.ifOperStatus]

        if state == 1:
            infotext += "(!) "
        elif state == 2:
            infotext += "(!!) "
        elif state == 3:
            infotext += "(?) "
        else:
            infotext += " "

        if group_members:
            infotext = infotext[:-1]  # remove last space
            infotext += ", Members: "
            for group_node, members in group_members.items():
                member_info = []
                for member in members:
                    member_info.append("%s (%s)" % (member["name"], member["state_name"]))

                nodeinfo = ""
                if group_node is not None and len(group_members) > 1:
                    nodeinfo = " on node %s" % group_node
                infotext += "[%s%s] " % (", ".join(member_info), nodeinfo)

        if interface.ifPhysAddress:
            infotext += 'MAC: %s, ' % if_render_mac_address(interface.ifPhysAddress)

        # prepare reference speed for computing relative bandwidth usage
        speed = interface.ifSpeed
        if speed:
            ref_speed = speed / 8.0
        elif targetspeed:
            ref_speed = targetspeed / 8.0
        else:
            ref_speed = None

        # Check speed settings of interface, but only if speed information
        # is available. This is not always the case.
        if speed:
            infotext += get_nic_speed_human_readable(speed)
            if not targetspeed is None and speed != targetspeed:
                infotext += " (wrong speed, expected: %s)(!)" % get_nic_speed_human_readable(
                    targetspeed)
                state = max(state, 1)
        elif targetspeed:
            infotext += "assuming %s" % get_nic_speed_human_readable(targetspeed)
        else:
            infotext += "speed unknown"

        # Convert the traffic levels to interface specific levels, for example where the percentage
        # levels are converted to absolute levels or assumed speeds of an interface are treated correctly
        traffic_levels = get_specific_traffic_levels(general_traffic_levels, unit, ref_speed,
                                                     assumed_speed_in, assumed_speed_out)

        # Speed in bytes
        speed_b_in = (assumed_speed_in // 8) if assumed_speed_in else ref_speed
        speed_b_out = (assumed_speed_out // 8) if assumed_speed_out else ref_speed

        #
        # All internal values within this check after this point are bytes, not bits!
        #

        # When the interface is reported as down, there is no need to try to handle,
        # the performance counters. Most devices do reset the counter values to zero,
        # but we spotted devices, which do report error packes even for down interfaces.
        # To deal with it, we simply skip over all performance counter checks for down
        # interfaces.
        if str(interface.ifOperStatus) == "2":
            return state, infotext

        # Performance counters
        rates = []
        wrapped = False
        perfdata = []
        for name, counter, warn, crit, mmin, mmax in [
            ("in", interface.ifInOctets, traffic_levels[('in', 'upper', 'warn')],
             traffic_levels[('in', 'upper', 'crit')], 0, speed_b_in),
            ("inucast", interface.inucast, None, None, None, None),
            ("innucast", saveint(interface.inmcast) + saveint(interface.inbcast), nucast_warn,
             nucast_crit, None, None),
            ("indisc", interface.ifInDiscards, disc_warn, disc_crit, None, None),
            ("inerr", interface.ifInErrors, err_in_warn, err_in_crit, None, None),
            ("out", interface.ifOutOctets, traffic_levels[('out', 'upper', 'warn')],
             traffic_levels[('out', 'upper', 'crit')], 0, speed_b_out),
            ("outucast", interface.outucast, None, None, None, None),
            ("outnucast", saveint(interface.outmcast) + saveint(interface.outbcast), nucast_warn,
             nucast_crit, None, None),
            ("outdisc", interface.ifOutDiscards, disc_warn, disc_crit, None, None),
            ("outerr", interface.ifOutErrors, err_out_warn, err_out_crit, None, None),
        ]:

            try:
                if node is None:
                    rate = get_rate("if.%s.%s" % (name, item),
                                    this_time,
                                    saveint(counter),
                                    onwrap=RAISE)
                    if force_counter_wrap:
                        raise MKCounterWrapped("Forced counter wrap")
                else:  # clustered check needs one counter per variable, item AND NODE
                    rate = get_rate("if.%s.%s.%s" % (node, name, item),
                                    this_time,
                                    saveint(counter),
                                    onwrap=RAISE)
                    if force_counter_wrap:
                        raise MKCounterWrapped("Forced counter wrap")
                rates.append(rate)
                perfdata.append((name, rate, warn, crit, mmin, mmax))
            except MKCounterWrapped:
                wrapped = True
                # continue, other counters might wrap as well

        # if at least one counter wrapped, we do not handle the counters at all
        if wrapped:
            # If there is a threshold on the bandwidth, we cannot proceed
            # further (the check would be flapping to green on a wrap)
            if any(traffic_levels.values()):
                raise MKCounterWrapped("Counter wrap, skipping checks this time")
            perfdata = []
        else:
            perfdata.append(("outqlen", saveint(interface.ifOutQLen)))

            def format_value(value):
                if unit == "Bit":
                    return get_nic_speed_human_readable(value * 8)
                return "%s/s" % get_bytes_human_readable(value)

            # loop over incoming and outgoing traffic
            for what, traffic, urate, nurate, discrate, errorrate, speed in [
                ("in", rates[0], rates[1], rates[2], rates[3], rates[4], speed_b_in),
                ("out", rates[5], rates[6], rates[7], rates[8], rates[9], speed_b_out),
            ]:
                if (what, 'predictive') in traffic_levels:
                    params = traffic_levels[(what, 'predictive')]
                    bw_warn, bw_crit = None, None
                else:
                    bw_warn = traffic_levels[(what, 'upper', 'warn')]
                    bw_crit = traffic_levels[(what, 'upper', 'crit')]
                    bw_warn_min = traffic_levels[(what, 'lower', 'warn')]
                    bw_crit_min = traffic_levels[(what, 'lower', 'crit')]
                    params = (bw_warn, bw_crit, bw_warn_min, bw_crit_min)

                # handle computation of average
                if average:
                    traffic_avg = get_average("if.%s.%s.avg" % (what, item), this_time, traffic,
                                              average)
                    dsname = "%s_avg_%d" % (what, average)
                    perfdata.append((dsname, traffic_avg, bw_warn, bw_crit, 0, speed))
                    traffic = traffic_avg  # apply levels to average traffic
                    title = "%s average %dmin" % (what.title(), average)
                else:
                    dsname = what
                    title = what.title()

                # Check bandwidth thresholds incl. prediction
                result = check_levels(traffic,
                                      dsname,
                                      params,
                                      statemarkers=True,
                                      human_readable_func=format_value,
                                      infoname=title)
                state = max(state, result[0])
                infotext += ", " + result[1]
                perfdata += result[2][1:]  # reference curve for predictive levels

                if speed:
                    perc_used = 100.0 * traffic / speed

                    assumed_info = ""
                    if assumed_speed_in or assumed_speed_out:
                        assumed_info = "/" + format_value(speed)
                    infotext += " (%.1f%%%s)" % (perc_used, assumed_info)

                # check percentage of error packets
                pacrate = urate + nurate + errorrate
                if pacrate > 0.0:  # any packets transmitted?
                    errperc = 100.0 * errorrate / pacrate
                    if errperc > 0:
                        if isinstance(err_crit, float):  # percentual levels
                            result = check_levels(errperc,
                                                  dsname, (err_warn, err_crit),
                                                  statemarkers=True,
                                                  human_readable_func=get_percent_human_readable,
                                                  infoname=what + "-errors")
                        elif isinstance(err_crit, int):  # absolute levels
                            result = check_levels(errorrate,
                                                  dsname, (err_warn, err_crit),
                                                  statemarkers=True,
                                                  human_readable_func=lambda x: "%d" % x,
                                                  infoname=what + "-errors packets")
                        state = max(state, result[0])
                        infotext += ", " + result[1]

                # check rate of non-unicast packets and discards
                for _txt, _rate, _warn, _crit in [("non-unicast packets", nurate, nucast_warn,
                                                   nucast_crit),
                                                  ("discards", discrate, disc_warn, disc_crit)]:

                    if _crit is not None and _warn is not None:
                        result = check_levels(_rate,
                                              _txt, (_warn, _crit),
                                              statemarkers=True,
                                              unit="/s",
                                              infoname="%s %s" % (what, _txt))
                        state = max(state, result[0])
                        infotext += ", " + result[1]

        if node:
            cluster_items[node] = (state, infotext, perfdata)
        else:
            return (state, infotext, perfdata)

    # if system is a cluster we have more than one line per item with
    # different node, results are collected in cluster_items
    # we choose the node with the highest outgoing traffic
    # since in a cluster environment this is likely the node
    # which is master
    if cluster_items:
        maxval = 0
        choosen_node = None
        for node, result in cluster_items.items():
            state, infotext, perfdata = result
            for entry in perfdata:
                name, value = entry[:2]
                if name == "out":
                    maxval = max(maxval, value)
                    if maxval == value:
                        choosen_node = node
        # In case that each node has a counter wrap for
        # out, we use the last note from the list as source
        if not choosen_node:
            choosen_node = node
        return cluster_items[choosen_node]

    return 3, "No such interface"


# possible port types are:

# other(1), regular1822(2), hdh1822(3), ddnX25(4), rfc877x25(5),
# ethernetCsmacd(6), iso88023Csmacd(7), iso88024TokenBus(8),
# iso88025TokenRing(9), iso88026Man(10), starLan(11), proteon10Mbit(12),
# proteon80Mbit(13), hyperchannel(14), fddi(15), lapb(16), sdlc(17), ds1(18),
# e1(19), basicISDN(20), primaryISDN(21), propPointToPointSerial(22),
# ppp(23), softwareLoopback(24), eon(25), ethernet3Mbit(26),
# nsip(27), slip(28), ultra(29), ds3(30), sip(31), frameRelay(32),
# rs232(33), para(34), arcnet(35), arcnetPlus(36), atm(37), miox25(38),
# sonet(39), x25ple(40), iso88022llc(41), localTalk(42), smdsDxi(43),
# frameRelayService(44), v35(45), hssi(46), hippi(47), modem(48),
# aal5(49), sonetPath(50), sonetVT(51), smdsIcip(52), propVirtual(53),
# propMultiplexor(54), ieee80212(55), fibreChannel(56), hippiInterface(57),
# frameRelayInterconnect(58), aflane8023(59), aflane8025(60), cctEmul(61),
# fastEther(62), isdn(63), v11(64), v36(65), g703at64k(66), g703at2mb(67),
# qllc(68), fastEtherFX(69), channel(70), ieee80211(71), ibm370parChan(72),
# escon(73), dlsw(74), isdns(75), isdnu(76), lapd(77), ipSwitch(78),
# rsrb(79), atmLogical(80), ds0(81), ds0Bundle(82), bsc(83), async(84),
# cnr(85), iso88025Dtr(86), eplrs(87), arap(88), propCnls(89), hostPad(90),
# termPad(91), frameRelayMPI(92), x213(93), adsl(94), radsl(95), sdsl(96),
# vdsl(97), iso88025CRFPInt(98), myrinet(99), voiceEM(100), voiceFXO(101),
# voiceFXS(102), voiceEncap(103), voiceOverIp(104), atmDxi(105), atmFuni(106),
# atmIma(107), pppMultilinkBundle(108), ipOverCdlc(109), ipOverClaw(110),
# stackToStack(111), virtualIpAddress(112), mpc(113), ipOverAtm(114),
# iso88025Fiber(115), tdlc(116), gigabitEthernet(117), hdlc(118), lapf(119),
# v37(120), x25mlp(121), x25huntGroup(122), trasnpHdlc(123), interleave(124),
# fast(125), ip(126), docsCableMaclayer(127), docsCableDownstream(128),
# docsCableUpstream(129), a12MppSwitch(130), tunnel(131), coffee(132),
# ces(133), atmSubInterface(134), l2vlan(135), l3ipvlan(136), l3ipxvlan(137),
# digitalPowerline(138), mediaMailOverIp(139), dtm(140), dcn(141),
# ipForward(142), msdsl(143), ieee1394(144), if-gsn(145), dvbRccMacLayer(146),
# dvbRccDownstream(147), dvbRccUpstream(148), atmVirtual(149), mplsTunnel(150),
# srp(151), voiceOverAtm(152), voiceOverFrameRelay(153), idsl(154),
# compositeLink(155), ss7SigLink(156), propWirelessP2P(157), frForward(158),
# rfc1483(159), usb(160), ieee8023adLag(161), bgppolicyaccounting(162),
# frf16MfrBundle(163), h323Gatekeeper(164), h323Proxy(165), mpls(166),
# mfSigLink(167), hdsl2(168), shdsl(169), ds1FDL(170), pos(171), dvbAsiIn(172),
# dvbAsiOut(173), plc(174), nfas(175), tr008(176), gr303RDT(177), gr303IDT(178),
# isup(179), propDocsWirelessMaclayer(180), propDocsWirelessDownstream(181),
# propDocsWirelessUpstream(182), hiperlan2(183), propBWAp2Mp(184),
# sonetOverheadChannel(185), digitalWrapperOverheadChannel(186),
# aal2(187), radioMAC(188), atmRadio(189), imt(190), mvl(191), reachDSL(192),
# frDlciEndPt(193), atmVciEndPt(194), opticalChannel(195), opticalTransport(196),
# propAtm(197), voiceOverCable(198), infiniband(199), teLink(200), q2931(201),
# virtualTg(202), sipTg(203), sipSig(204), docsCableUpstreamChannel(205),
# econet(206), pon155(207), pon622(208), bridge(209), linegroup(210),
# voiceEMFGD(211), voiceFGDEANA(212), voiceDID(213), mpegTransport(214),
# sixToFour(215), gtp(216), pdnEtherLoop1(217), pdnEtherLoop2(218),
# opticalChannelGroup(219), homepna(220), gfp(221), ciscoISLvlan(222),
# actelisMetaLOOP(223), fcipLink(224), rpr(225), qam(226), lmp(227),
# cblVectaStar(228), docsCableMCmtsDownstream(229), adsl2(230)


def _convert_type(if_type):
    try:
        int(if_type)
    except ValueError:
        return str(if64_port_types.get(if_type, '1'))
    else:
        return if_type


def _convert_status(if_status):
    try:
        int(if_status)
    except ValueError:
        return str(if64_status_names.get(if_status, '4'))
    else:
        return if_status


def parse_if64(info):
    parsed = []
    for line in info:
        # some DLINK switches apparently report a broken interface with index 0,
        # filter that out
        if saveint(line[1]) > 0:
            # ifHighSpeed (idx 21) can't represent interfaces with less than  10^6 bit bandwidth,
            # ifSpeed (idx 4) is capped at 4GBit.
            # combine the two to get the actual interface speed
            if line[-1] in ["0", ""]:
                real_speed = saveint(line[4])
            else:
                real_speed = saveint(line[-1]) * 1000000

            # Fujitsu SC2 Servers do not use numeric values for port state and type
            if_type = _convert_type(line[3])
            if_oper_status = _convert_status(line[5])

            parsed.append(line[:3] + [if_type, real_speed, if_oper_status] + line[6:-1])
    return parsed


if64_snmp_end_oids = [
    "2.2.1.1",  # ifIndex                   0
    "2.2.1.2",  # ifDescr                   1
    "2.2.1.3",  # ifType                    2
    "2.2.1.5",  # ifSpeed                   3
    "2.2.1.8",  # ifOperStatus              4
    "31.1.1.1.6",  # ifHCInOctets              5
    "31.1.1.1.7",  # ifHCInUcastPkts           6
    "31.1.1.1.8",  # ifHCInMulticastPkts       7
    "31.1.1.1.9",  # ifHCInBroadcastPkts       8
    "2.2.1.13",  # ifInDiscards              9
    "2.2.1.14",  # ifInErrors               10
    "31.1.1.1.10",  # ifHCOutOctets            11
    "31.1.1.1.11",  # ifHCOutUcastPkts         12
    "31.1.1.1.12",  # ifHCOutMulticastPkts     13
    "31.1.1.1.13",  # ifHCOutBroadcastPkts     14
    "2.2.1.19",  # ifOutDiscards            15
    "2.2.1.20",  # ifOutErrors              16
    "2.2.1.21",  # ifOutQLen                17
    "31.1.1.1.18",  # ifAlias                  18
    BINARY("2.2.1.6"),  # ifPhysAddress            19
    "31.1.1.1.15",  # ifHighSpeed              -1  (parse_if64 assumes this is the last element)
]

if64_status_names = {
    'up': '1',
    'down': '2',
    'testing': '3',
    'unknown': '4',
    'dormant': '5',
    'not present': '6',
    'lower layer down': '7',
    'degraded': '8',
    'admin down': '9',
}

if64_port_types = {
    'other': '1',
    'regular1822': '2',
    'hdh1822': '3',
    'ddnX25': '4',
    'rfc877x25': '5',
    'ethernetCsmacd': '6',
    'iso88023Csmacd': '7',
    'iso88024TokenBus': '8',
    'iso88025TokenRing': '9',
    'iso88026Man': '10',
    'starLan': '11',
    'proteon10Mbit': '12',
    'proteon80Mbit': '13',
    'hyperchannel': '14',
    'fddi': '15',
    'lapb': '16',
    'sdlc': '17',
    'ds1': '18',
    'e1': '19',
    'basicISDN': '20',
    'primaryISDN': '21',
    'propPointToPointSerial': '22',
    'ppp': '23',
    'softwareLoopback': '24',
    'eon': '25',
    'ethernet3Mbit': '26',
    'nsip': '27',
    'slip': '28',
    'ultra': '29',
    'ds3': '30',
    'sip': '31',
    'frameRelay': '32',
    'rs232': '33',
    'para': '34',
    'arcnet': '35',
    'arcnetPlus': '36',
    'atm': '37',
    'miox25': '38',
    'sonet': '39',
    'x25ple': '40',
    'iso88022llc': '41',
    'localTalk': '42',
    'smdsDxi': '43',
    'frameRelayService': '44',
    'v35': '45',
    'hssi': '46',
    'hippi': '47',
    'modem': '48',
    'aal5': '49',
    'sonetPath': '50',
    'sonetVT': '51',
    'smdsIcip': '52',
    'propVirtual': '53',
    'propMultiplexor': '54',
    'ieee80212': '55',
    'fibreChannel': '56',
    'hippiInterface': '57',
    'frameRelayInterconnect': '58',
    'aflane8023': '59',
    'aflane8025': '60',
    'cctEmul': '61',
    'fastEther': '62',
    'isdn': '63',
    'v11': '64',
    'v36': '65',
    'g703at64k': '66',
    'g703at2mb': '67',
    'qllc': '68',
    'fastEtherFX': '69',
    'channel': '70',
    'ieee80211': '71',
    'ibm370parChan': '72',
    'escon': '73',
    'dlsw': '74',
    'isdns': '75',
    'isdnu': '76',
    'lapd': '77',
    'ipSwitch': '78',
    'rsrb': '79',
    'atmLogical': '80',
    'ds0': '81',
    'ds0Bundle': '82',
    'bsc': '83',
    'async': '84',
    'cnr': '85',
    'iso88025Dtr': '86',
    'eplrs': '87',
    'arap': '88',
    'propCnls': '89',
    'hostPad': '90',
    'termPad': '91',
    'frameRelayMPI': '92',
    'x213': '93',
    'adsl': '94',
    'radsl': '95',
    'sdsl': '96',
    'vdsl': '97',
    'iso88025CRFPInt': '98',
    'myrinet': '99',
    'voiceEM': '100',
    'voiceFXO': '101',
    'voiceFXS': '102',
    'voiceEncap': '103',
    'voiceOverIp': '104',
    'atmDxi': '105',
    'atmFuni': '106',
    'atmIma': '107',
    'pppMultilinkBundle': '108',
    'ipOverCdlc': '109',
    'ipOverClaw': '110',
    'stackToStack': '111',
    'virtualIpAddress': '112',
    'mpc': '113',
    'ipOverAtm': '114',
    'iso88025Fiber': '115',
    'tdlc': '116',
    'gigabitEthernet': '117',
    'hdlc': '118',
    'lapf': '119',
    'v37': '120',
    'x25mlp': '121',
    'x25huntGroup': '122',
    'trasnpHdlc': '123',
    'interleave': '124',
    'fast': '125',
    'ip': '126',
    'docsCableMaclayer': '127',
    'docsCableDownstream': '128',
    'docsCableUpstream': '129',
    'a12MppSwitch': '130',
    'tunnel': '131',
    'coffee': '132',
    'ces': '133',
    'atmSubInterface': '134',
    'l2vlan': '135',
    'l3ipvlan': '136',
    'l3ipxvlan': '137',
    'digitalPowerline': '138',
    'mediaMailOverIp': '139',
    'dtm': '140',
    'dcn': '141',
    'ipForward': '142',
    'msdsl': '143',
    'ieee1394': '144',
    'if-gsn': '145',
    'dvbRccMacLayer': '146',
    'dvbRccDownstream': '147',
    'dvbRccUpstream': '148',
    'atmVirtual': '149',
    'mplsTunnel': '150',
    'srp': '151',
    'voiceOverAtm': '152',
    'voiceOverFrameRelay': '153',
    'idsl': '154',
    'compositeLink': '155',
    'ss7SigLink': '156',
    'propWirelessP2P': '157',
    'frForward': '158',
    'rfc1483': '159',
    'usb': '160',
    'ieee8023adLag': '161',
    'bgppolicyaccounting': '162',
    'frf16MfrBundle': '163',
    'h323Gatekeeper': '164',
    'h323Proxy': '165',
    'mpls': '166',
    'mfSigLink': '167',
    'hdsl2': '168',
    'shdsl': '169',
    'ds1FDL': '170',
    'pos': '171',
    'dvbAsiIn': '172',
    'dvbAsiOut': '173',
    'plc': '174',
    'nfas': '175',
    'tr008': '176',
    'gr303RDT': '177',
    'gr303IDT': '178',
    'isup': '179',
    'propDocsWirelessMaclayer': '180',
    'propDocsWirelessDownstream': '181',
    'propDocsWirelessUpstream': '182',
    'hiperlan2': '183',
    'propBWAp2Mp': '184',
    'sonetOverheadChannel': '185',
    'digitalWrapperOverheadChannel': '186',
    'aal2': '187',
    'radioMAC': '188',
    'atmRadio': '189',
    'imt': '190',
    'mvl': '191',
    'reachDSL': '192',
    'frDlciEndPt': '193',
    'atmVciEndPt': '194',
    'opticalChannel': '195',
    'opticalTransport': '196',
    'propAtm': '197',
    'voiceOverCable': '198',
    'infiniband': '199',
    'teLink': '200',
    'q2931': '201',
    'virtualTg': '202',
    'sipTg': '203',
    'sipSig': '204',
    'docsCableUpstreamChannel': '205',
    'econet': '206',
    'pon155': '207',
    'pon622': '208',
    'bridge': '209',
    'linegroup': '210',
    'voiceEMFGD': '211',
    'voiceFGDEANA': '212',
    'voiceDID': '213',
    'mpegTransport': '214',
    'sixToFour': '215',
    'gtp': '216',
    'pdnEtherLoop1': '217',
    'pdnEtherLoop2': '218',
    'opticalChannelGroup': '219',
    'homepna': '220',
    'gfp': '221',
    'ciscoISLvlan': '222',
    'actelisMetaLOOP': '223',
    'fcipLink': '224',
    'rpr': '225',
    'qam': '226',
    'lmp': '227',
    'cblVectaStar': '228',
    'docsCableMCmtsDownstream': '229',
    'adsl2': '230',
}
