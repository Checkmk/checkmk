#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
from typing import NamedTuple

memused_default_levels = (150.0, 200.0)

factory_settings["memory_default_levels"] = {
    "levels": memused_default_levels,
}


# Parse /proc/meminfo into the canonical form: into bytes, not kB
# This function is also used by the ps check
def parse_proc_meminfo_bytes(info):
    meminfo = {}
    for line in info:
        value = int(line[1])
        if len(line) > 2 and line[2] == 'kB':
            value *= 1024
        meminfo[line[0][:-1]] = value
    return meminfo


class MemBytes(NamedTuple('MemBytes', [('bytes', int), ('kb', float), ('mb', float),
                                       ('base', int)])):
    def __new__(cls, value, base):
        return super(MemBytes, cls).__new__(cls, int(value * 1024), float(value), value / 1024.0,
                                            int(base))

    def render(self):
        return get_bytes_human_readable(self.bytes, base=self.base)


def get_levels_mode_from_value(warn):
    """get levels mode by looking at the value

    Levels may be given either as
     * positive int -> absolute levels on used
     * negative int -> absolute levels on free
     * positive float -> percentages on used
     * negative float -> percentages on free
    """
    type_ = "perc" if isinstance(warn, float) else "abs"
    reference = "used" if warn > 0 else "free"
    return "%s_%s" % (type_, reference)


def normalize_mem_levels(mode,
                         warn,
                         crit,
                         total,
                         _perc_total=None,
                         render_base=1024,
                         render_unit=1):
    """get normalized levels and formatter

    Levels may be given either as
     * Absolute levels on used
     * Absolute levels on free
     * Percentage levels on used
     * Percentage levels on free
    Normalize levels to absolute posive levels and return formatted levels text
    """
    # TODO: remove this weird case of different reference values.
    if _perc_total is None:
        _perc_total = total

    if warn is None or crit is None:
        return None, None, ""

    mode_split = mode.split('_', 1)
    if mode_split[0] not in ('perc', 'abs') or mode_split[-1] not in ('used', 'free'):
        raise NotImplementedError("unknown levels mode: %r" % (mode,))

    # normalize percent -> absolute
    if mode.startswith("perc"):
        warn_used = warn / 100.0 * _perc_total
        crit_used = crit / 100.0 * _perc_total
        levels_text = "%s/%s" % (
            get_percent_human_readable(warn),
            get_percent_human_readable(crit),
        )
    else:  # absolute
        warn_used = float(warn)
        crit_used = float(crit)
        levels_text = "%s/%s" % (
            get_bytes_human_readable(warn * render_unit, base=render_base),
            get_bytes_human_readable(crit * render_unit, base=render_base),
        )

    # normalize free -> used
    if mode.endswith("free"):
        warn_used = float(total - warn_used)
        crit_used = float(total - crit_used)
        levels_text = "warn/crit below %s free" % levels_text
    else:  # used
        levels_text = "warn/crit at %s used" % levels_text

    return warn_used, crit_used, levels_text


def _compute_state(value, warn, crit):
    if crit is not None and value >= crit:
        return 2
    if warn is not None and value >= warn:
        return 1
    return 0


def check_memory_element(label,
                         used,
                         total,
                         levels,
                         label_total="",
                         show_free=False,
                         metric_name=None,
                         render_base=1024,
                         create_percent_metric=False):
    """Return a check result for one memory element
    """
    if show_free:
        show_value = total - used
        show_text = " free"
    else:
        show_value = used
        show_text = ""

    infotext = "%s: %s%s - %s of %s%s" % (
        label,
        get_percent_human_readable(100.0 * show_value / total),
        show_text,
        get_bytes_human_readable(show_value, base=render_base),
        get_bytes_human_readable(total, base=render_base),
        (" %s" % label_total).rstrip(),
    )

    try:
        mode, (warn, crit) = levels
    except (ValueError, TypeError):  # handle None, "ignore"
        mode, (warn, crit) = "ignore", (None, None)

    warn, crit, levels_text = normalize_mem_levels(mode, warn, crit, total, render_base=render_base)
    state = _compute_state(used, warn, crit)
    if state and levels_text:
        infotext = "%s (%s)" % (infotext, levels_text)

    perf = []
    if metric_name:
        perf.append((metric_name, used, warn, crit, 0, total))
    if create_percent_metric:
        scale_to_perc = 100.0 / total
        perf.append((
            "mem_used_percent",
            used * scale_to_perc,
            warn * scale_to_perc if warn is not None else None,
            crit * scale_to_perc if crit is not None else None,
            0.0,
            None,  # some times over 100%!
        ))

    return state, infotext, perf


def _get_total_usage(ramused, swapused, pagetables):
    """get total usage and a description how it was computed
    """
    totalused_kb = ramused.kb
    details = ["RAM"]

    if swapused:
        totalused_kb += swapused.kb
        details.append("Swap")

    if pagetables:
        totalused_kb += pagetables.kb
        details.append("Pagetables")

    totalused = MemBytes(totalused_kb, ramused.base)
    if len(details) == 1:
        return totalused, details[0]
    return totalused, "Total (%s)" % " + ".join(details)


def check_memory(params, meminfo, render_base=1024):
    if isinstance(params, tuple):
        params = {"levels": params}

    memtotal = MemBytes(meminfo['MemTotal'], render_base)
    memused = MemBytes(memtotal.kb - meminfo['MemFree'], render_base)

    if "SwapFree" in meminfo:
        swaptotal = MemBytes(meminfo['SwapTotal'], render_base)
        swapused = MemBytes(swaptotal.kb - meminfo['SwapFree'], render_base)
        perfdata = [('swapused', swapused.mb, None, None, 0, swaptotal.mb)]
    else:
        swaptotal = None
        swapused = None
        perfdata = []

    # Size of Pagetable on Linux can be relevant e.g. on ORACLE
    # servers with much memory, that do not use HugeTables. We account
    # that for used
    if 'PageTables' in meminfo:
        pagetables = MemBytes(meminfo['PageTables'], render_base)
        perfdata.append(('pagetables', pagetables.mb))
    else:
        pagetables = None

    # Buffers and Cached are optional. On Linux both mean basically the same.
    caches = MemBytes(meminfo.get('Buffers', 0) + meminfo.get('Cached', 0), render_base)

    ramused = MemBytes(memused.kb - caches.kb, render_base)
    if perfdata:
        # if perfdata is empty here, ramused and totalused would be the same anyway.
        perfdata.append(('ramused', ramused.mb, None, None, 0, memtotal.mb))

    totalused, totalused_descr = _get_total_usage(ramused, swapused, pagetables)

    infotext = check_memory_element(
        totalused_descr,
        totalused.bytes,
        memtotal.bytes,
        None,
        label_total="RAM" if totalused_descr != "RAM" else "",
    )[1]

    # Take into account averaging
    average_min = params.get("average")
    if average_min:
        totalused_mb_avg = get_average("mem.used.total",
                                       time.time(),
                                       totalused.mb,
                                       average_min,
                                       initialize_zero=False)
        totalused_perc_avg = totalused_mb_avg / memtotal.mb * 100
        infotext += ", %d min average %.1f%%" % (average_min, totalused_perc_avg)
        perfdata.append(('memusedavg', totalused_mb_avg))
        comp_mb = totalused_mb_avg
    else:
        comp_mb = totalused.mb

    # Normalize levels and check them
    totalvirt = MemBytes((swaptotal.kb if swaptotal is not None else 0) + memtotal.kb, render_base)
    warn, crit = params.get("levels", (None, None))
    mode = get_levels_mode_from_value(warn)
    warn_mb, crit_mb, levels_text = normalize_mem_levels(
        mode,
        abs(warn),
        abs(crit),
        totalvirt.mb,
        _perc_total=memtotal.mb,
        render_base=render_base,
        render_unit=1024**2,
    )
    perfdata.append(('memused', totalused.mb, warn_mb, crit_mb, 0, totalvirt.mb))

    # Check levels
    state = _compute_state(comp_mb, warn_mb, crit_mb)
    if state and levels_text:
        infotext = "%s (%s)" % (infotext, levels_text)

    yield state, infotext, perfdata

    if totalused_descr != "RAM":
        yield check_memory_element(
            "RAM",
            ramused.bytes,  # <- caches subtracted
            memtotal.bytes,
            None,
        )
        if swaptotal and swaptotal.bytes:
            yield check_memory_element(
                "Swap",
                swapused.bytes,
                swaptotal.bytes,
                None,
            )
        if pagetables:
            yield 0, "Pagetables: %s" % pagetables.render(), []

    # Add additional metrics, provided by Linux.
    if meminfo.get('Mapped'):
        for key, label, metric in (
            ('Mapped', 'Mapped', 'mapped'),
            ('Committed_AS', 'Committed', 'committed_as'),
            ('Shmem', 'Shared', 'shared'),
        ):
            value = MemBytes(meminfo.get(key, 0), render_base)
            yield 0, "%s: %s" % (label, value.render()), [(metric, value.mb)]
