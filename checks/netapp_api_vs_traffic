#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# NOTE: Careful when replacing the *-import below with a more specific import. This can cause
# problems because it might remove variables from the check-context which are necessary for
# resolving legacy discovery results such as [("SUMMARY", "diskstat_default_levels")]. Furthermore,
# it might also remove variables needed for accessing discovery rulesets.
from cmk.base.check_legacy_includes.netapp_api import *  # pylint: disable=wildcard-import,unused-wildcard-import

# <<<netapp_api_vs_traffic:sep(9)>>>
# lif:vserver        instance_uuid 4294967295        instance_name sb1        sent_errors 0        recv_errors 0 ...
# lif:vserver        instance_uuid 16        instance_name vsFS        sent_errors 0        recv_errors 0        ..
# cifs:vserver        session_timed_out 17731        sd_max_ace_size         cifs_latency 9403817108427        ..
# iscsi_lif:vserver        iscsi_read_ops 4071295661        avg_write_latency 3429809602514        ..

# A list of counter name is available at
# https://library.netapp.com/ecmdocs/ECMP1608437/html/GUID-04407796-688E-489D-901C-A6C9EAC2A7A2.html


def inventory_netapp_api_vs_traffic(parsed):
    vservers = {x.split(".", 1)[1] for x in parsed}
    for vserver in vservers:
        yield vserver, {}


def check_netapp_api_vs_traffic(item, _no_params, parsed):
    protocol_map = {
        "lif:vserver": (
            "Ethernet",
            # ( what         perfname        perftext      scale     format_func)
            [
                ("recv_data", "if_in_octets", "received data", 1, get_bytes_human_readable),
                ("sent_data", "if_out_octets", "sent data", 1, get_bytes_human_readable),
                ("recv_errors", "if_in_errors", "received errors", 1, int),
                ("sent_errors", "if_out_errors", "sent errors", 1, int),
                ("recv_packet", "if_in_pkts", "received packets", 1, int),
                ("sent_packet", "if_out_pkts", "sent packets", 1, int),
            ],
        ),
        "fcp_lif:vserver": (
            "FCP",
            [
                (
                    "fcp_read_latency",
                    "fcp_read_latency",
                    "avg. Read latency",
                    0.001,
                    lambda x: "%.2f ms" % (x * 1000),
                ),
                (
                    "fcp_write_latency",
                    "fcp_write_latency",
                    "avg. Write latency",
                    0.001,
                    lambda x: "%.2f ms" % (x * 1000),
                ),
                ("read_data", "fcp_read_data", "read data", 1, get_bytes_human_readable),
                ("write_data", "fcp_write_data", "write data", 1, get_bytes_human_readable),
            ],
        ),
        "cifs:vserver": (
            "CIFS",
            [
                (
                    "cifs_read_latency",
                    "cifs_read_latency",
                    "read latency",
                    0.000000001,
                    lambda x: "%.2f ms" % (x * 1000),
                ),
                (
                    "cifs_write_latency",
                    "cifs_write_latency",
                    "write latency",
                    0.000000001,
                    lambda x: "%.2f ms" % (x * 1000),
                ),
                ("cifs_read_ops", "cifs_read_ios", "read OPs", 1, int),
                ("cifs_write_ops", "cifs_write_ios", "write OPs", 1, int),
            ],
        ),
        "iscsi_lif:vserver": (
            "iSCSI",
            [
                (
                    "iscsi_read_latency",
                    "iscsi_read_latency",
                    "avg. Read latency",
                    0.001,
                    lambda x: "%.2f ms" % (x * 1000),
                ),
                (
                    "iscsi_write_latency",
                    "iscsi_write_latency",
                    "avg. Write latency",
                    0.001,
                    lambda x: "%.2f ms" % (x * 1000),
                ),
                ("read_data", "iscsi_read_data", "read data", 1, get_bytes_human_readable),
                ("write_data", "iscsi_write_data", "write data", 1, get_bytes_human_readable),
            ],
        ),
        "nfsv3": (
            "NFS",
            [
                ("nfsv3_read_ops", "nfs_read_ios", "read OPs", 1, int),
                ("nfsv3_write_ops", "nfs_write_ios", "write OPs", 1, int),
                (
                    "nfsv3_read_throughput",
                    "nfs_read_throughput",
                    "read throughput",
                    1,
                    lambda x: get_bytes_human_readable(x) + "/s",
                ),
                (
                    "nfsv3_write_throughput",
                    "nfs_write_throughput",
                    "write throughput",
                    1,
                    lambda x: get_bytes_human_readable(x) + "/s",
                ),
                ("nfsv3_ops", "nfs_ios", "OPs", 1, int),
            ],
        ),
        "nfsv4": (
            "NFSv4",
            [
                ("nfsv4_read_ops", "nfsv4_read_ios", "read OPs", 1, int),
                ("nfsv4_write_ops", "nfsv4_write_ios", "write OPs", 1, int),
                (
                    "nfs4_read_throughput",
                    "nfsv4_read_throughput",
                    "read throughput",
                    1,
                    lambda x: get_bytes_human_readable(x) + "/s",
                ),
                (
                    "nfs4_write_throughput",
                    "nfsv4_write_throughput",
                    "write throughput",
                    1,
                    lambda x: get_bytes_human_readable(x) + "/s",
                ),
                ("nfsv4_ops", "nfsv4_ios", "OPs", 1, int),
            ],
        ),
        "nfsv4_1": (
            "NFSv4.1",
            [
                ("nfsv4_1_ops", "nfsv4_1_ios", "OPs", 1, int),
                (
                    "nfs41_read_throughput",
                    "nfsv4_1_read_throughput",
                    "read throughput",
                    1,
                    lambda x: get_bytes_human_readable(x) + "/s",
                ),
                (
                    "nfs41_write_throughput",
                    "nfsv4_1_write_throughput",
                    "write throughput",
                    1,
                    lambda x: get_bytes_human_readable(x) + "/s",
                ),
            ],
        ),
    }

    def get_ref(what, data):
        # According to "NetAppÂ® Unified Storage Performance Management",
        # latency calculation is a function of the number of ops.
        refname = {
            "iscsi_read_latency": "iscsi_read_ops",
            "iscsi_write_latency": "iscsi_write_ops",
            "fcp_read_latency": "fcp_read_ops",
            "fcp_write_latency": "fcp_write_ops",
            "cifs_read_latency": "cifs_read_ops",
            "cifs_write_latency": "cifs_write_ops",
        }.get(what)
        try:
            return int(data[refname])
        except KeyError:
            return None

    now = time.time()
    for protocol, (protoname, values) in protocol_map.items():
        data = parsed.get("%s.%s" % (protocol, item))
        if not data:
            continue

        for what, perfname, perftext, scale, format_func in values:
            if what not in data:
                continue

            ref = get_ref(what, data)
            if ref is None:
                ref = now

            try:
                rate = get_rate(
                    f"{protocol}.{what}",
                    ref,
                    int(data[what]) * scale,
                    onwrap=RAISE,
                )
                yield (
                    0,
                    f"{protoname} {perftext}: {format_func(rate)}",  # pylint: disable=not-callable
                    [(perfname, rate)],
                )
            except MKCounterWrapped as exc:
                yield (0, f"{protoname} {perftext}: -")


check_info["netapp_api_vs_traffic"] = {
    "parse_function": lambda info: netapp_api_parse_lines(
        info, custom_keys=["protocol", "instance_name"]
    ),
    "inventory_function": inventory_netapp_api_vs_traffic,
    "check_function": check_netapp_api_vs_traffic,
    "service_description": "Traffic vServer %s",
    "has_perfdata": True,
}
