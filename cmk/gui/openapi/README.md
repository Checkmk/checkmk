Checkmk OpenAPI
===============

Implementer. THIS IS IMPORTANT! PLEASE READ!

When writing a new API endpoint please make sure to adhere to these standards:

 * All API endpoints return a dictionary-structure which follows the
  "Restful Objects" specification. This specification defines `domain types`
  and their representations as single-objects or collections. To always adhere
  to this standard, please refer to the helper functions in the
  `restful_objects.constructors` module.

 * All API endpoints need to have a doc-string for documentation purposes.
   Keep the first line short, as there is limited space in the documentation
   for the overview.

 * If you create a new module in `endpoints`, make sure to add a short
   doc-string on top for documentation purposes.

Overview
--------

The main entities of the REST API system are `User`, `Request`, `Response`, `Endpoint`, `Decorator`, `API WSGI App`, `Request Schema`, `Response Schema`, `Path Schema`, `Header Schema`, `Permission Object` and `Endpoint registry`.

A `Endpoint` needs to be decorated by `Decorator`.

`Decorator` uses the `Request Schema` to determine if the `Request` sent by `User` is correct.

## Developer Documentation

To see the user/customer perspective a good starting point is the documentation
(Help -> Rest API documentation)
or the docstring at `cmk/gui/openapi/restful_objects/specification.py`

### Introduction

Strictly speaking the REST API consists of endpoints that can be called via
HTTP-Requests. The REST API comes with a few features or artifacts:

* The OpenAPI document: A YAML document describing all available Endpoints
  with their request and response objects.
* The Swagger GUI: A single page web application to explore the REST API, based
  on the OpenAPI document.
* ReDoc: A human-readable representation of the OpenAPI document that includes code
  snippets.

The REST API itself is modeled according to the [Restful Objects Spec
](https://www.restfulobjects.org/).

#### OpenAPI document

The central piece of the REST API is the OpenAPI document. It's a formal,
machine- and human-readable description of all possible requests and their
responses. Currently this document is generated on demand and reflects the
current configuration of Checkmk. This will change in the near future. It is
planned to make the OpenAPI document more static to ease working with generated
clients.

What's possible within a OpenAPI document is defined in the OpenAPI
specification. You can read an introduction at the [OpenAPI
Documentation](https://oai.github.io/Documentation/). But normally you would
not come in direct contact with the OpenAPI document, as this is generated by
the [apispec](https://apispec.readthedocs.io/) library, based on the Endpoint
definition described later on.

ReDoc also defines some Extensions to the OpenAPI specification, to display
code samples (`x-codeSamples`) or group the API endpoints (`x-tagGroups`).
Those are described in the [redocly
documentation](https://redoc.ly/docs/api-reference-docs/spec-extensions/).

The OpenAPI document is generated on the fly when requested and can be received
as json or yaml document.

#### Swagger GUI

The Swagger GUI (Help -> REST API interactive GUI) lists almost all REST API
endpoints and presents a simple interface to call each endpoint. This makes it
perfect to get familiar with the REST API or to reproduce errors found in more
complex scripts.

Among others, the host list endpoints are not displayed in the Swagger GUI as
it is not possible to generate JSON dictionaries in queries strings within
Swagger.

The Swagger GUI itself consists of static html files, served by the Python
WSGI-App. To inject the actual URL of the OpenAPI document, the `index.html`
file is modified on the fly. The Swagger GUI loads the OpenAPI document via
AJAX and transforms it's content via JavaScript.

#### ReDoc

ReDoc (Help -> REST API documentation) shows the OpenAPI document in an
interactive way so one can explore the field definitions and see all possible
HTTP status codes and other information.

ReDoc is a self contained JavaScript file that is served similar to how Swagger
is served. The configuration (the `index.html` file) is also served as static
file directly via apache. ReDoc loads the OpenAPI document via AJAX and
transforms its content via JavaScript.

### Endpoints

Strictly speaking an endpoint is the touchpoint between two systems
communicating with each other. In the case of a REST API the endpoint normally
is described by a URL and HTTP-method. In the Checkmk REST API backend the API
is completely described by its endpoints. That means all aspects of the REST
API are defined in each endpoint:

* the python function called when the endpoint is called
* the URL under which the endpoint can be reached, including:
    * the placeholders defined in the URL
    * possible keys and values of the query string
* the valid HTTP methods you can call the endpoint with
* the request schema of the request body for POST and PUT methods
* the response schema for all endpoints

All these attributes are defined with the help of a decorator, decorating the
python function that should be executed when the endpoint is called. The
docstring of the function is used to display a short description of the
endpoint in the ReDoc and Swagger pages.

In order to group all endpoints (e.g. that modify or return passwords) into one
section, the ReDoc extension `x-tagGroups` is used. This should not be confused
with the host tag groups within Checkmk.

#### Function

In most cases the function doing the hard work is already defined in
`cmk.gui.watolib` and is simply called within the endpoint function. All
parsing and data validation should be made by the defined schemata and **not**
within the function.

#### URL, method and query string.

The method is a simple string containing the HTTP method the function should
be reachable with, e.g. `post`. The URL is a bit more complex:

The URL itself can contain placeholders like `{variable_name}`. If the URL
contains a placeholder, the type of the placeholder has to be defined in the
list `path_params`. The content can be accessed via the only argument passed to
the endpoint function, called `params`: `params['variable_name']`.

The Schema for the query string can be defined as a list of dictionaries passed
to the `query_params` argument of the endpoint decorator. This defines a
mapping between the key of the query parameter and the marshmallow definition
of the value. The value can be accessed the same way as the placeholder: via
the `params` argument.

#### Request and Response Schema

All data validation and therefore also request and response schema are defined
with the help of [mashmallow](https://marshmallow.readthedocs.io/).

Each endpoint can describe its valid request and response HTTP-bodies via
`request_schema` and `response_schema` arguments.

Checkmk Forms are based on ValueSpec. This can be used to restrict user input
and create form layouts. For many Checkmk specific fields (for example host
names or IP-addresses) special ValueSpec classes exist that validate the
entered values. These ValueSpecs have a method `openapi_field`...

#### Etag

In order to detect [edit
conflicts](https://en.wikipedia.org/wiki/Edit_conflict) one have to provide the
`If-Match` HTTP-Header. The work flow looks like this:

* Request an object, receive `ETag` HTTP-Header
* Make local modification to the object
* Save modified object, specify content of the `ETag` Header in the `If-Match`
  HTTP-Header

The content of the `Etag` HTTP-Header is a checksum or the last modified
timestamp the corresponding `.mk` file. This way the backend can detect if the
contents changed since the object was received and deny the request.

The described work flow can be activated by providing the `etag` argument to
the Endpoint decorator.
