load("@rules_foreign_cc//foreign_cc:defs.bzl", "configure_make")
load("@omd_packages//:package_versions.bzl", "PROTOBUF_LIB_VERSION", "PYTHON_MAJOR_DOT_MINOR")

# For unknown reasons the version of the libraries differes from the package version
PROTOBUF_LIB_VERSION_ARRAY = PROTOBUF_LIB_VERSION.split(".")

PROTOBUF_LIB_VERSION_MAJOR = PROTOBUF_LIB_VERSION_ARRAY[0]

MAKE_PARALLEL = "-j4"

filegroup(
    name = "all_srcs",
    srcs = glob(
        ["**/*"],
        exclude = ["bazel-*"],
    ),
)

configure_make(
    name = "protobuf",
    args = ["%s" % MAKE_PARALLEL],
    build_data = ["@omd_packages//omd/packages/perl-modules:perl-modules"],
    configure_in_place = True,
    configure_options = [
        "-v",
        "--disable-option-checking",
        "--prefix=/",
    ],
    copts = [
        "-I$BUILD_TMPDIR/include",
        "-I${EXT_BUILD_DEPS}/python/include/python%s/" % PYTHON_MAJOR_DOT_MINOR,
        "-I$EXT_BUILD_DEPS/python/lib/",
    ],
    env = {
        "ORIGIN_VAR": "\\\\$$\\$$ORIGIN",
        "RANLIB": "ranlib",
        "LD_LIBRARY_PATH": "$$EXT_BUILD_DEPS/python/lib/",
        "PERL_DIR": "$(execpath @omd_packages//omd/packages/perl-modules:perl-modules)",
        "HOME": "/home/\\$$\\$${USER}/",
        "CXXFLAGS": "-Wno-stringop-overflow",
    },
    lib_source = ":all_srcs",
    out_binaries = [
        "protoc",
    ],
    out_data_dirs = [
        "share/man/",
        "lib/python%s/site-packages/" % PYTHON_MAJOR_DOT_MINOR,
    ],
    out_shared_libs = [
        "libprotobuf-lite.so",
        "libprotobuf-lite.so.%s" % PROTOBUF_LIB_VERSION_MAJOR,
        "libprotobuf-lite.so.%s" % PROTOBUF_LIB_VERSION,
        "libprotobuf.so",
        "libprotobuf.so.%s" % PROTOBUF_LIB_VERSION_MAJOR,
        "libprotobuf.so.%s" % PROTOBUF_LIB_VERSION,
        "libprotoc.so",
        "libprotoc.so.%s" % PROTOBUF_LIB_VERSION_MAJOR,
        "libprotoc.so.%s" % PROTOBUF_LIB_VERSION,
    ],
    out_static_libs = [
        "libprotobuf-lite.a",
        "libprotobuf.a",
        "libprotoc.a",
    ],
    postfix_script = """
        set -ex
        # static compilation
        # Hack needed for protoc to be linked statically. Tried a lot of different things to make it
        # work with the standard Makefile and libtool stuff, but had no luck. It always ended with a
        # protoc with dynamic dependencies on libgcc and libstdc++. And we really need to have a
        # statically linked binary at the moment. The following is a hand crafted linker command.
        # Let me know in case you got a cleaner approach.
        cd src
        rm protoc
        echo -e '\nprotoc-static: $(protoc_OBJECTS) $(protoc_DEPENDENCIES) $(EXTRA_protoc_DEPENDENCIES)\n\tg++ -pthread -DHAVE_PTHREAD=1 -DHAVE_ZLIB=1 -Wall -Wno-sign-compare -static-libgcc -static-libstdc++ -s -o protoc google/protobuf/compiler/main.o -lpthread ./.libs/libprotoc.a ./.libs/libprotobuf.a' >> Makefile && \
        make %s protoc-static && \
        file protoc | grep ELF >/dev/null && \
        ldd protoc | grep -v libstdc++ >/dev/null
        cd -
        # compile python package
        cd python
        CPPFLAGS=-I${EXT_BUILD_DEPS}/python/include/python%s/ ${EXT_BUILD_DEPS}/python/bin/python3 setup.py build --cpp_implementation
    ${EXT_BUILD_DEPS}/python/bin/python3 setup.py install \
           --cpp_implementation \
           --root=${INSTALLDIR} \
           --prefix=''
        cd -
        # install
        make %s DESTDIR=${INSTALLDIR} install
    """ % (MAKE_PARALLEL, PYTHON_MAJOR_DOT_MINOR, MAKE_PARALLEL),
    targets = [
        "",  # default target is install, but we only want to build at first
    ],
    deps = ["@python"],
)
